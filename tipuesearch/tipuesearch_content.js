var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine is a software library for researching concurrent, large-batch inference and training of deep, feed-forward neural networks.  Inference-Engine targets high-performance computing (HPC) applications with performance-critical inference and training needs.  The initial target application is in situ training of a cloud microphysics model proxy for the Intermediate Complexity Atmospheric Research ( ICAR ) model.  Such a proxy must support concurrent inference at every grid point at every time step of an ICAR run.  For validation purposes, Inference-Engine can also import neural networks exported from Python by the companion package nexport . The training capability is currently experimental. Current unit tests verify that Inference-Engine's network-training feature works for networks with one hidden layer.  Future work will include developing unit tests that verify that the training works for deep neural networks. Inference-Engine's implementation language, Fortran 2018, makes it suitable for integration into high-performance computing (HPC).\nThe novel features of Inference-Engine include Exposing concurrency via An elemental , polymorphic, and implicitly pure inference strategy, An elemental , polymorphic, and implicitly pure activation strategy , and A pure training subroutine. Gathering network weights and biases into contiguous arrays Runtime selection of inferences strategy and activation strategy. Item 1 facilitates invoking Inference-Engine's infer function inside Fortran's do concurrent constructs, which some compilers can offload automatically to graphics processing units (GPUs).  We envision this being useful in applications that require large numbers of independent inferences or or multiple networks to train concurrently.  Item 2 exploits the special case where the number of neurons is uniform across the network layers.  The use of contiguous arrays facilitates spatial locality in memory access patterns.  Item 3 offers the possibility of adaptive inference method selection based on runtime information.  The current methods include ones based on intrinsic functions, dot_product or matmul .  Future options will explore the use of OpenMP and OpenACC for vectorization, multithreading, and/or accelerator offloading. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the examples in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"network_increment_t – Inference-Engine ","text":"type, public :: network_increment_t Contents Variables delta_b_hidden_ delta_b_out_ delta_w_hidden_ delta_w_in_ delta_w_out_ Constructor network_increment_t Type-Bound Procedures delta_b_hidden delta_b_out delta_w_hidden delta_w_in delta_w_out operator(+) operator(/) add divide Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: delta_b_hidden_ (:,:) real(kind=rkind), private, allocatable :: delta_b_out_ (:) real(kind=rkind), private, allocatable :: delta_w_hidden_ (:,:,:) real(kind=rkind), private, allocatable :: delta_w_in_ (:,:) real(kind=rkind), private, allocatable :: delta_w_out_ (:,:) Constructor public interface network_increment_t private pure module function construct(delta_w_in, delta_w_hidden, delta_w_out, delta_b_hidden, delta_b_out) result(network_increment) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: delta_w_in (:,:) real(kind=rkind), intent(in) :: delta_w_hidden (:,:,:) real(kind=rkind), intent(in) :: delta_w_out (:,:) real(kind=rkind), intent(in) :: delta_b_hidden (:,:) real(kind=rkind), intent(in) :: delta_b_out (:) Return Value type( network_increment_t ) Type-Bound Procedures procedure, public :: delta_b_hidden interface private pure module module function delta_b_hidden(self) result(my_delta_b_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: delta_b_out interface private pure module module function delta_b_out(self) result(my_delta_b_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) procedure, public :: delta_w_hidden interface private pure module module function delta_w_hidden(self) result(my_delta_w_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) procedure, public :: delta_w_in interface private pure module module function delta_w_in(self) result(my_delta_w_in) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: delta_w_out interface private pure module module function delta_w_out(self) result(my_delta_w_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) generic, public :: operator(+) => add private interface add () Arguments None generic, public :: operator(/) => divide private interface divide () Arguments None procedure, private :: add interface private pure module module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: lhs type( network_increment_t ), intent(in) :: rhs Return Value type( network_increment_t ) procedure, private :: divide interface private pure module module function divide(numerator, denominator) result(ratio) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: numerator integer, intent(in) :: denominator Return Value type( network_increment_t )","tags":"","loc":"type/network_increment_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/step_t.html"},{"title":"mini_batch_t – Inference-Engine ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~inputs_t inputs_t type~input_output_pair_t->type~inputs_t inputs_ type~expected_outputs_t expected_outputs_t type~input_output_pair_t->type~expected_outputs_t expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_output_pairs_ Constructor mini_batch_t Type-Bound Procedures input_output_pairs Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) Type-Bound Procedures procedure, public :: input_output_pairs interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"type/mini_batch_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~step_t step_t type~step_t->type~activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables neuron next Constructor layer_t Type-Bound Procedures count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target Type-Bound Procedures procedure, public :: count_layers interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) procedure, public :: hidden_biases interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: hidden_weights interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) procedure, public :: input_weights interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: neurons_per_layer interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer procedure, public :: output_biases interface private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) procedure, public :: output_weights interface private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:)","tags":"","loc":"type/layer_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ hidden_weights_ input_weights_ metadata_ output_biases_ output_weights_ Constructor inference_engine_t Type-Bound Procedures activation_function_name assert_conformable_with assert_consistent hidden_weights increment infer input_weights neurons_per_layer norm num_hidden_layers num_inputs num_outputs operator(-) output_weights skip to_json infer_from_array_of_inputs infer_from_inputs_object subtract Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) real(kind=rkind), private, allocatable :: input_weights_ (:,:) type(string_t), private :: metadata_ (size(key)) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor public interface inference_engine_t private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine procedure, public :: assert_consistent interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self procedure, public :: hidden_weights interface private pure module module function hidden_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) procedure, public :: increment interface private pure module module subroutine increment(self, network_increment) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(inout) :: self type( network_increment_t ), intent(in) :: network_increment generic, public :: infer => infer_from_array_of_inputs , infer_from_inputs_object private interface infer_from_array_of_inputs () Arguments None private interface infer_from_inputs_object () Arguments None procedure, public :: input_weights interface private pure module module function input_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: neurons_per_layer interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: num_hidden_layers interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: output_weights interface private pure module module function output_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: skip interface private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: infer_from_array_of_inputs interface private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) procedure, private :: infer_from_inputs_object interface private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) procedure, private :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"input_output_pair_t – Inference-Engine ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~inputs_t inputs_t type~input_output_pair_t->type~inputs_t inputs_ type~expected_outputs_t expected_outputs_t type~input_output_pair_t->type~expected_outputs_t expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables expected_outputs_ inputs_ Constructor input_output_pair_t Type-Bound Procedures expected_outputs inputs Components Type Visibility Attributes Name Initial type( expected_outputs_t ), private :: expected_outputs_ type( inputs_t ), private :: inputs_ Constructor public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( inputs_t ), intent(in) :: inputs type( expected_outputs_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) Type-Bound Procedures procedure, public :: expected_outputs interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( expected_outputs_t ) procedure, public :: inputs interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( inputs_t )","tags":"","loc":"type/input_output_pair_t.html"},{"title":"inputs_t – Inference-Engine ","text":"type, public :: inputs_t Inherited by type~~inputs_t~~InheritedByGraph type~inputs_t inputs_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~inputs_t inputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables values values_ Constructor inputs_t Components Type Visibility Attributes Name Initial procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor public interface inputs_t private pure module function construct_from_components(values) result(inputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( inputs_t )","tags":"","loc":"type/inputs_t.html"},{"title":"expected_outputs_t – Inference-Engine ","text":"type, public :: expected_outputs_t Inherited by type~~expected_outputs_t~~InheritedByGraph type~expected_outputs_t expected_outputs_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~expected_outputs_t expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables outputs_ Constructor expected_outputs_t Type-Bound Procedures outputs Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: outputs_ (:) Constructor public interface expected_outputs_t private pure module function construct(outputs) result(expected_outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) Return Value type( expected_outputs_t ) Type-Bound Procedures procedure, public :: outputs interface private pure module module function outputs(self) result(my_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( expected_outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/expected_outputs_t.html"},{"title":"inference_strategy_t – Inference-Engine ","text":"type, public, abstract :: inference_strategy_t Inherited by type~~inference_strategy_t~~InheritedByGraph type~inference_strategy_t inference_strategy_t type~matmul_t matmul_t type~matmul_t->type~inference_strategy_t type~concurrent_dot_products_t concurrent_dot_products_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure( infer_interface ), public, deferred, nopass :: infer pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/inference_strategy_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/swish_t.html"},{"title":"matmul_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: matmul_t Inherits type~~matmul_t~~InheritsGraph type~matmul_t matmul_t type~inference_strategy_t inference_strategy_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/matmul_t.html"},{"title":"outputs_t – Inference-Engine ","text":"type, public :: outputs_t Contents Variables outputs pre_activation_in pre_activation_out outputs_ pre_activation_in_ pre_activation_out_ Constructor outputs_t Components Type Visibility Attributes Name Initial procedure, public :: outputs procedure, public :: pre_activation_in procedure, public :: pre_activation_out real(kind=rkind), private, allocatable :: outputs_ (:) network outputs real(kind=rkind), private, allocatable :: pre_activation_in_ (:,:) weighted & biased hidden-layer inputs for training real(kind=rkind), private, allocatable :: pre_activation_out_ (:) weighted & biased output for training Constructor public interface outputs_t private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t )","tags":"","loc":"type/outputs_t.html"},{"title":"concurrent_dot_products_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Inherits type~~concurrent_dot_products_t~~InheritsGraph type~concurrent_dot_products_t concurrent_dot_products_t type~inference_strategy_t inference_strategy_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/concurrent_dot_products_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"trainable_engine_t – Inference-Engine ","text":"type, public :: trainable_engine_t Encapsulate the information needed to perform training Inherits type~~trainable_engine_t~~InheritsGraph type~trainable_engine_t trainable_engine_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables b differentiable_activation_strategy_ n w Constructor trainable_engine_t Type-Bound Procedures assert_consistent infer num_inputs num_layers train Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor public interface trainable_engine_t private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) Type-Bound Procedures procedure, public :: assert_consistent interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self procedure, public :: infer interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_layers interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: train interface private pure module module subroutine train(self, mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:)","tags":"","loc":"type/trainable_engine_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bias_ next weights_ Constructor neuron_t Type-Bound Procedures bias next_allocated next_pointer num_inputs weights Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer procedure, public :: num_inputs interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/sigmoid_t.html"},{"title":"activation_i – Inference-Engine","text":"abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"function_name_i – Inference-Engine","text":"abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name_i.html"},{"title":"infer_interface – Inference-Engine","text":"abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer_interface.html"},{"title":"set_activation_name – Inference-Engine","text":"pure subroutine set_activation_name(inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Called by proc~~set_activation_name~~CalledByGraph proc~set_activation_name set_activation_name proc~construct_from_components construct_from_components proc~construct_from_components->proc~set_activation_name proc~construct_from_json construct_from_json proc~construct_from_json->proc~set_activation_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_activation_name.html"},{"title":"network_increment_t – Inference-Engine","text":"public interface network_increment_t Contents Functions construct Functions private pure module function construct(delta_w_in, delta_w_hidden, delta_w_out, delta_b_hidden, delta_b_out) result(network_increment) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: delta_w_in (:,:) real(kind=rkind), intent(in) :: delta_w_hidden (:,:,:) real(kind=rkind), intent(in) :: delta_w_out (:,:) real(kind=rkind), intent(in) :: delta_b_hidden (:,:) real(kind=rkind), intent(in) :: delta_b_out (:) Return Value type( network_increment_t )","tags":"","loc":"interface/network_increment_t.html"},{"title":"operator(.average.) – Inference-Engine","text":"public interface operator(.average.) Contents Functions average Functions private pure module function average(rhs) result(average_increment) Arguments Type Intent Optional Attributes Name type( network_increment_t ), intent(in) :: rhs (:) Return Value type( network_increment_t )","tags":"","loc":"interface/operator(.average.).html"},{"title":"add – Inference-Engine","text":"interface Calls interface~~add~~CallsGraph interface~add add proc~add add interface~add->proc~add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: lhs type( network_increment_t ), intent(in) :: rhs Return Value type( network_increment_t )","tags":"","loc":"interface/add.html"},{"title":"delta_b_hidden – Inference-Engine","text":"interface Calls interface~~delta_b_hidden~~CallsGraph interface~delta_b_hidden delta_b_hidden proc~delta_b_hidden delta_b_hidden interface~delta_b_hidden->proc~delta_b_hidden Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function delta_b_hidden(self) result(my_delta_b_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/delta_b_hidden.html"},{"title":"delta_b_out – Inference-Engine","text":"interface Calls interface~~delta_b_out~~CallsGraph interface~delta_b_out delta_b_out proc~delta_b_out delta_b_out interface~delta_b_out->proc~delta_b_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function delta_b_out(self) result(my_delta_b_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/delta_b_out.html"},{"title":"delta_w_hidden – Inference-Engine","text":"interface Calls interface~~delta_w_hidden~~CallsGraph interface~delta_w_hidden delta_w_hidden proc~delta_w_hidden delta_w_hidden interface~delta_w_hidden->proc~delta_w_hidden Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function delta_w_hidden(self) result(my_delta_w_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:,:)","tags":"","loc":"interface/delta_w_hidden.html"},{"title":"delta_w_in – Inference-Engine","text":"interface Calls interface~~delta_w_in~~CallsGraph interface~delta_w_in delta_w_in proc~delta_w_in delta_w_in interface~delta_w_in->proc~delta_w_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function delta_w_in(self) result(my_delta_w_in) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/delta_w_in.html"},{"title":"delta_w_out – Inference-Engine","text":"interface Calls interface~~delta_w_out~~CallsGraph interface~delta_w_out delta_w_out proc~delta_w_out delta_w_out interface~delta_w_out->proc~delta_w_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function delta_w_out(self) result(my_delta_w_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/delta_w_out.html"},{"title":"divide – Inference-Engine","text":"interface Calls interface~~divide~~CallsGraph interface~divide divide proc~divide divide interface~divide->proc~divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function divide(numerator, denominator) result(ratio) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: numerator integer, intent(in) :: denominator Return Value type( network_increment_t )","tags":"","loc":"interface/divide.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~~CallsGraph interface~function_name function_name proc~function_name function_name interface~function_name->proc~function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"mini_batch_t – Inference-Engine","text":"public interface mini_batch_t Contents Functions construct Functions private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"interface/mini_batch_t.html"},{"title":"input_output_pairs – Inference-Engine","text":"interface Calls interface~~input_output_pairs~~CallsGraph interface~input_output_pairs input_output_pairs proc~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/input_output_pairs.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Contents Functions construct Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target","tags":"","loc":"interface/layer_t.html"},{"title":"count_layers – Inference-Engine","text":"interface Calls interface~~count_layers~~CallsGraph interface~count_layers count_layers proc~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Calls interface~~count_neurons~~CallsGraph interface~count_neurons count_neurons proc~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"interface Calls interface~~hidden_biases~~CallsGraph interface~hidden_biases hidden_biases proc~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"interface Calls interface~~hidden_weights~~CallsGraph interface~hidden_weights hidden_weights proc~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:)","tags":"","loc":"interface/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"interface Calls interface~~input_weights~~CallsGraph interface~input_weights input_weights proc~input_weights input_weights interface~input_weights->proc~input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~~CallsGraph interface~next_allocated next_allocated proc~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~~CallsGraph interface~next_pointer next_pointer proc~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"output_biases – Inference-Engine","text":"interface Calls interface~~output_biases~~CallsGraph interface~output_biases output_biases proc~output_biases output_biases interface~output_biases->proc~output_biases assert assert proc~output_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/output_biases.html"},{"title":"output_weights – Inference-Engine","text":"interface Calls interface~~output_weights~~CallsGraph interface~output_weights output_weights proc~output_weights output_weights interface~output_weights->proc~output_weights assert assert proc~output_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/output_weights.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct_from_components construct_from_json Functions private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Calls interface~~activation_function_name~~CallsGraph interface~activation_function_name activation_function_name proc~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface Calls interface~~assert_conformable_with~~CallsGraph interface~assert_conformable_with assert_conformable_with proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t assert assert proc~assert_conformable_with->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"assert_consistent – Inference-Engine","text":"interface Calls interface~~assert_consistent~~CallsGraph interface~assert_consistent assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~assert_consistent~~CalledByGraph interface~assert_consistent assert_consistent proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs->interface~assert_consistent proc~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object->interface~assert_consistent proc~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2->interface~assert_consistent proc~num_hidden_layers num_hidden_layers proc~num_hidden_layers->interface~assert_consistent proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistent proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistent proc~to_json to_json proc~to_json->interface~assert_consistent interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent.html"},{"title":"hidden_weights – Inference-Engine","text":"interface Calls interface~~hidden_weights~2~~CallsGraph interface~hidden_weights~2 hidden_weights proc~hidden_weights~2 hidden_weights interface~hidden_weights~2->proc~hidden_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~hidden_weights~2~~CalledByGraph interface~hidden_weights~2 hidden_weights proc~construct_from_components construct_from_components proc~construct_from_components->interface~hidden_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function hidden_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:,:)","tags":"","loc":"interface/hidden_weights~2.html"},{"title":"increment – Inference-Engine","text":"interface Calls interface~~increment~~CallsGraph interface~increment increment proc~increment increment interface~increment->proc~increment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine increment(self, network_increment) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(inout) :: self type( network_increment_t ), intent(in) :: network_increment","tags":"","loc":"interface/increment.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"interface Calls interface~~infer_from_array_of_inputs~~CallsGraph interface~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs interface~assert_consistent assert_consistent proc~infer_from_array_of_inputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t )","tags":"","loc":"interface/infer_from_array_of_inputs.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"interface Calls interface~~infer_from_inputs_object~~CallsGraph interface~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object interface~assert_consistent assert_consistent proc~infer_from_inputs_object->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t )","tags":"","loc":"interface/infer_from_inputs_object.html"},{"title":"input_weights – Inference-Engine","text":"interface Calls interface~~input_weights~2~~CallsGraph interface~input_weights~2 input_weights proc~input_weights~2 input_weights interface~input_weights~2->proc~input_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function input_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/input_weights~2.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~2~~CallsGraph interface~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 interface~assert_consistent assert_consistent proc~neurons_per_layer~2->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer~2.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"interface Calls interface~~num_hidden_layers~~CallsGraph interface~num_hidden_layers num_hidden_layers proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers interface~assert_consistent assert_consistent proc~num_hidden_layers->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~assert_consistent assert_consistent proc~num_inputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~assert_consistent assert_consistent proc~num_outputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"output_weights – Inference-Engine","text":"interface Calls interface~~output_weights~2~~CallsGraph interface~output_weights~2 output_weights proc~output_weights~2 output_weights interface~output_weights~2->proc~output_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function output_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/output_weights~2.html"},{"title":"skip – Inference-Engine","text":"interface Calls interface~~skip~~CallsGraph interface~skip skip proc~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~~CallsGraph interface~to_json to_json proc~to_json to_json interface~to_json->proc~to_json separated_values separated_values proc~to_json->separated_values assert assert proc~to_json->assert string_t string_t proc~to_json->string_t intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t interface~assert_consistent assert_consistent proc~to_json->interface~assert_consistent file_t file_t proc~to_json->file_t proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent proc~assert_consistent->assert proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json.html"},{"title":"input_output_pair_t – Inference-Engine","text":"public interface input_output_pair_t Contents Functions construct Functions private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( inputs_t ), intent(in) :: inputs type( expected_outputs_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"expected_outputs – Inference-Engine","text":"interface Calls interface~~expected_outputs~~CallsGraph interface~expected_outputs expected_outputs proc~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( expected_outputs_t )","tags":"","loc":"interface/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"interface Calls interface~~inputs~~CallsGraph interface~inputs inputs proc~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( inputs_t )","tags":"","loc":"interface/inputs.html"},{"title":"inputs_t – Inference-Engine","text":"public interface inputs_t Contents Functions construct_from_components Functions private pure module function construct_from_components(values) result(inputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( inputs_t )","tags":"","loc":"interface/inputs_t.html"},{"title":"values – Inference-Engine","text":"interface Calls interface~~values~~CallsGraph interface~values values proc~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function values(self) result(inputs) Implementation → Arguments Type Intent Optional Attributes Name class( inputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/values.html"},{"title":"expected_outputs_t – Inference-Engine","text":"public interface expected_outputs_t Contents Functions construct Functions private pure module function construct(outputs) result(expected_outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) Return Value type( expected_outputs_t )","tags":"","loc":"interface/expected_outputs_t.html"},{"title":"outputs – Inference-Engine","text":"interface Calls interface~~outputs~~CallsGraph interface~outputs outputs proc~outputs outputs interface~outputs->proc~outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function outputs(self) result(my_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( expected_outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/outputs.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~2~~CallsGraph interface~activation~2 activation proc~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~~CallsGraph interface~activation_derivative activation_derivative proc~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~2~~CallsGraph interface~function_name~2 function_name proc~function_name~2 function_name interface~function_name~2->proc~function_name~2 string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~2.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer.html"},{"title":"outputs_t – Inference-Engine","text":"public interface outputs_t Contents Functions construct_from_compoents Functions private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t )","tags":"","loc":"interface/outputs_t.html"},{"title":"outputs – Inference-Engine","text":"interface Calls interface~~outputs~2~~CallsGraph interface~outputs~2 outputs proc~outputs~2 outputs interface~outputs~2->proc~outputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function outputs(self) result(output_values) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/outputs~2.html"},{"title":"pre_activation_in – Inference-Engine","text":"interface Calls interface~~pre_activation_in~~CallsGraph interface~pre_activation_in pre_activation_in proc~pre_activation_in pre_activation_in interface~pre_activation_in->proc~pre_activation_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function pre_activation_in(self) result(z) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/pre_activation_in.html"},{"title":"pre_activation_out – Inference-Engine","text":"interface Calls interface~~pre_activation_out~~CallsGraph interface~pre_activation_out pre_activation_out proc~pre_activation_out pre_activation_out interface~pre_activation_out->proc~pre_activation_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function pre_activation_out(self) result(z_L) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/pre_activation_out.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer~2.html"},{"title":"trainable_engine_t – Inference-Engine","text":"public interface trainable_engine_t Contents Functions construct_from_padded_arrays Functions private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t )","tags":"","loc":"interface/trainable_engine_t.html"},{"title":"assert_consistent – Inference-Engine","text":"interface Calls interface~~assert_consistent~2~~CallsGraph interface~assert_consistent~2 assert_consistent proc~assert_consistent~2 assert_consistent interface~assert_consistent~2->proc~assert_consistent~2 intrinsic_array_t intrinsic_array_t proc~assert_consistent~2->intrinsic_array_t assert assert proc~assert_consistent~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent~2.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~3~~CallsGraph interface~infer~3 infer proc~infer~3 infer interface~infer~3->proc~infer~3 n n proc~infer~3->n w w proc~infer~3->w b b proc~infer~3->b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t )","tags":"","loc":"interface/infer~3.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~2~~CallsGraph interface~num_inputs~2 num_inputs proc~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"interface Calls interface~~num_layers~~CallsGraph interface~num_layers num_layers proc~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_layers.html"},{"title":"train – Inference-Engine","text":"interface Calls interface~~train~~CallsGraph interface~train train proc~train train interface~train->proc~train n n proc~train->n w w proc~train->w b b proc~train->b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine train(self, mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:)","tags":"","loc":"interface/train.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Contents Functions construct Functions private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface Calls interface~~bias~~CallsGraph interface~bias bias proc~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~2~~CallsGraph interface~next_allocated~2 next_allocated proc~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~2~~CallsGraph interface~next_pointer~2 next_pointer proc~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~3~~CallsGraph interface~num_inputs~3 num_inputs proc~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~3.html"},{"title":"weights – Inference-Engine","text":"interface Calls interface~~weights~~CallsGraph interface~weights weights proc~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~3~~CallsGraph interface~activation~3 activation proc~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~2~~CallsGraph interface~activation_derivative~2 activation_derivative proc~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~3~~CallsGraph interface~function_name~3 function_name proc~function_name~3 function_name interface~function_name~3->proc~function_name~3 string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~3.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"netCDF_read – Inference-Engine","text":"subroutine netCDF_read(file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) Calls proc~~netcdf_read~~CallsGraph proc~netcdf_read netCDF_read nf90_strerror nf90_strerror proc~netcdf_read->nf90_strerror assert assert proc~netcdf_read->assert data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_read~~CalledByGraph proc~netcdf_read netCDF_read program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_read.html"},{"title":"netCDF_write – Inference-Engine","text":"subroutine netCDF_write(file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Calls proc~~netcdf_write~~CallsGraph proc~netcdf_write netCDF_write nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror assert assert proc~netcdf_write->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_write~~CalledByGraph proc~netcdf_write netCDF_write program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_write.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer string_t string_t proc~write_read_query_infer->string_t file_t file_t proc~write_read_query_infer->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_query_infer Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( outputs_t ) network_outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & metadata = [ string_t ( \"XOR\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-02-18\" ), string_t ( \"step\" ), string_t ( \"false\" )], & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ] & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"number of hidden layers:\" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer:\" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ([ real ( rkind ) :: 0. , 1. ], matmul_t ()) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % outputs () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"activation_function_name – Inference-Engine","text":"module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) Called by proc~~activation_function_name~~CalledByGraph proc~activation_function_name activation_function_name interface~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Calls proc~~assert_conformable_with~~CallsGraph proc~assert_conformable_with assert_conformable_with intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t assert assert proc~assert_conformable_with->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_conformable_with~~CalledByGraph proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_conformable_with.html"},{"title":"assert_consistent – Inference-Engine","text":"module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent interface~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs->interface~assert_consistent proc~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object->interface~assert_consistent proc~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2->interface~assert_consistent proc~num_hidden_layers num_hidden_layers proc~num_hidden_layers->interface~assert_consistent proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistent proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistent proc~to_json to_json proc~to_json->interface~assert_consistent interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components module procedure construct_from_components() Arguments None Calls proc~~construct_from_components~~CallsGraph proc~construct_from_components construct_from_components interface~hidden_weights~2 hidden_weights proc~construct_from_components->interface~hidden_weights~2 proc~set_activation_name set_activation_name proc~construct_from_components->proc~set_activation_name proc~hidden_weights~2 hidden_weights interface~hidden_weights~2->proc~hidden_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_components.html"},{"title":"construct_from_json – Inference-Engine","text":"module procedure construct_from_json module procedure construct_from_json() Arguments None Calls proc~~construct_from_json~~CallsGraph proc~construct_from_json construct_from_json assert assert proc~construct_from_json->assert string_t string_t proc~construct_from_json->string_t proc~set_activation_name set_activation_name proc~construct_from_json->proc~set_activation_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_json.html"},{"title":"hidden_weights – Inference-Engine","text":"module procedure hidden_weights pure module module function hidden_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:,:) Called by proc~~hidden_weights~2~~CalledByGraph proc~hidden_weights~2 hidden_weights interface~hidden_weights~2 hidden_weights interface~hidden_weights~2->proc~hidden_weights~2 proc~construct_from_components construct_from_components proc~construct_from_components->interface~hidden_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_weights~2.html"},{"title":"increment – Inference-Engine","text":"module procedure increment pure module module subroutine increment(self, network_increment) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(inout) :: self type( network_increment_t ), intent(in) :: network_increment Called by proc~~increment~~CalledByGraph proc~increment increment interface~increment increment interface~increment->proc~increment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/increment.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) Calls proc~~infer_from_array_of_inputs~~CallsGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~assert_consistent assert_consistent proc~infer_from_array_of_inputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_array_of_inputs~~CalledByGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_array_of_inputs.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) Calls proc~~infer_from_inputs_object~~CallsGraph proc~infer_from_inputs_object infer_from_inputs_object interface~assert_consistent assert_consistent proc~infer_from_inputs_object->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_inputs_object~~CalledByGraph proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_inputs_object.html"},{"title":"input_weights – Inference-Engine","text":"module procedure input_weights pure module module function input_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~input_weights~2~~CalledByGraph proc~input_weights~2 input_weights interface~input_weights~2 input_weights interface~input_weights~2->proc~input_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_weights~2.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~neurons_per_layer~2~~CallsGraph proc~neurons_per_layer~2 neurons_per_layer interface~assert_consistent assert_consistent proc~neurons_per_layer~2->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~neurons_per_layer~2~~CalledByGraph proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer~2.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_hidden_layers~~CallsGraph proc~num_hidden_layers num_hidden_layers interface~assert_consistent assert_consistent proc~num_hidden_layers->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_hidden_layers~~CalledByGraph proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~~CallsGraph proc~num_inputs num_inputs interface~assert_consistent assert_consistent proc~num_inputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs interface~assert_consistent assert_consistent proc~num_outputs->interface~assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"output_weights – Inference-Engine","text":"module procedure output_weights pure module module function output_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~output_weights~2~~CalledByGraph proc~output_weights~2 output_weights interface~output_weights~2 output_weights interface~output_weights~2->proc~output_weights~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output_weights~2.html"},{"title":"skip – Inference-Engine","text":"module procedure skip elemental module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical Called by proc~~skip~~CalledByGraph proc~skip skip interface~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Calls proc~~to_json~~CallsGraph proc~to_json to_json separated_values separated_values proc~to_json->separated_values assert assert proc~to_json->assert string_t string_t proc~to_json->string_t intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t interface~assert_consistent assert_consistent proc~to_json->interface~assert_consistent file_t file_t proc~to_json->file_t proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent proc~assert_consistent->assert proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~~CalledByGraph proc~to_json to_json interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json.html"},{"title":"assert_consistent – Inference-Engine","text":"module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Calls proc~~assert_consistent~2~~CallsGraph proc~assert_consistent~2 assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_consistent~2->intrinsic_array_t assert assert proc~assert_consistent~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~2~~CalledByGraph proc~assert_consistent~2 assert_consistent interface~assert_consistent~2 assert_consistent interface~assert_consistent~2->proc~assert_consistent~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent~2.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None Contents None","tags":"","loc":"proc/construct_from_padded_arrays.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) Calls proc~~infer~3~~CallsGraph proc~infer~3 infer n n proc~infer~3->n w w proc~infer~3->w b b proc~infer~3->b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~3~~CalledByGraph proc~infer~3 infer interface~infer~3 infer interface~infer~3->proc~infer~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~3.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~2~~CalledByGraph proc~num_inputs~2 num_inputs interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_layers~~CalledByGraph proc~num_layers num_layers interface~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_layers.html"},{"title":"train – Inference-Engine","text":"module procedure train pure module module subroutine train(self, mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) Calls proc~~train~~CallsGraph proc~train train n n proc~train->n w w proc~train->w b b proc~train->b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~train~~CalledByGraph proc~train train interface~train train interface~train->proc~train Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/train.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components module procedure construct_from_components() Arguments None Contents None","tags":"","loc":"proc/construct_from_components~2.html"},{"title":"values – Inference-Engine","text":"module procedure values pure module module function values(self) result(inputs) Interface → Arguments Type Intent Optional Attributes Name class( inputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~values~~CalledByGraph proc~values values interface~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/values.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~~CallsGraph proc~construct construct layer_lines layer_lines proc~construct->layer_lines assert assert proc~construct->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer Called by proc~~count_layers~~CalledByGraph proc~count_layers count_layers interface~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:) Called by proc~~count_neurons~~CalledByGraph proc~count_neurons count_neurons interface~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~hidden_biases~~CallsGraph proc~hidden_biases hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_biases~~CalledByGraph proc~hidden_biases hidden_biases interface~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:) Calls proc~~hidden_weights~~CallsGraph proc~hidden_weights hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_weights~~CalledByGraph proc~hidden_weights hidden_weights interface~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~input_weights~~CallsGraph proc~input_weights input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_weights~~CalledByGraph proc~input_weights input_weights interface~input_weights input_weights interface~input_weights->proc~input_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~~CalledByGraph proc~next_allocated next_allocated interface~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Called by proc~~next_pointer~~CalledByGraph proc~next_pointer next_pointer interface~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer.html"},{"title":"output_biases – Inference-Engine","text":"module procedure output_biases module module function output_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:) Calls proc~~output_biases~~CallsGraph proc~output_biases output_biases assert assert proc~output_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~output_biases~~CalledByGraph proc~output_biases output_biases interface~output_biases output_biases interface~output_biases->proc~output_biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output_biases.html"},{"title":"output_weights – Inference-Engine","text":"module procedure output_weights module module function output_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~output_weights~~CallsGraph proc~output_weights output_weights assert assert proc~output_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~output_weights~~CalledByGraph proc~output_weights output_weights interface~output_weights output_weights interface~output_weights->proc~output_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output_weights.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"input_output_pairs – Inference-Engine","text":"module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:) Called by proc~~input_output_pairs~~CalledByGraph proc~input_output_pairs input_output_pairs interface~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_output_pairs.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~~CalledByGraph proc~function_name function_name interface~function_name function_name interface~function_name->proc~function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~2~~CalledByGraph proc~activation~2 activation interface~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~~CalledByGraph proc~activation_derivative activation_derivative interface~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~2~~CallsGraph proc~function_name~2 function_name string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~2~~CalledByGraph proc~function_name~2 function_name interface~function_name~2 function_name interface~function_name~2->proc~function_name~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~2.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~bias~~CalledByGraph proc~bias bias interface~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~3~~CallsGraph proc~construct~3 construct neuron_lines neuron_lines proc~construct~3->neuron_lines assert assert proc~construct~3->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~3.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~2~~CalledByGraph proc~next_allocated~2 next_allocated interface~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer Called by proc~~next_pointer~2~~CalledByGraph proc~next_pointer~2 next_pointer interface~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~3~~CalledByGraph proc~num_inputs~3 num_inputs interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~3.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~weights~~CalledByGraph proc~weights weights interface~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/weights.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~4.html"},{"title":"expected_outputs – Inference-Engine","text":"module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( expected_outputs_t ) Called by proc~~expected_outputs~~CalledByGraph proc~expected_outputs expected_outputs interface~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( inputs_t ) Called by proc~~inputs~~CalledByGraph proc~inputs inputs interface~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inputs.html"},{"title":"construct_from_compoents – Inference-Engine","text":"module procedure construct_from_compoents module procedure construct_from_compoents() Arguments None Contents None","tags":"","loc":"proc/construct_from_compoents.html"},{"title":"outputs – Inference-Engine","text":"module procedure outputs pure module module function outputs(self) result(output_values) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~outputs~2~~CalledByGraph proc~outputs~2 outputs interface~outputs~2 outputs interface~outputs~2->proc~outputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/outputs~2.html"},{"title":"pre_activation_in – Inference-Engine","text":"module procedure pre_activation_in pure module module function pre_activation_in(self) result(z) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~pre_activation_in~~CalledByGraph proc~pre_activation_in pre_activation_in interface~pre_activation_in pre_activation_in interface~pre_activation_in->proc~pre_activation_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pre_activation_in.html"},{"title":"pre_activation_out – Inference-Engine","text":"module procedure pre_activation_out pure module module function pre_activation_out(self) result(z_L) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~pre_activation_out~~CalledByGraph proc~pre_activation_out pre_activation_out interface~pre_activation_out pre_activation_out interface~pre_activation_out->proc~pre_activation_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pre_activation_out.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~5.html"},{"title":"outputs – Inference-Engine","text":"module procedure outputs pure module module function outputs(self) result(my_outputs) Interface → Arguments Type Intent Optional Attributes Name class( expected_outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~outputs~~CalledByGraph proc~outputs outputs interface~outputs outputs interface~outputs->proc~outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/outputs.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~3~~CalledByGraph proc~activation~3 activation interface~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~2~~CalledByGraph proc~activation_derivative~2 activation_derivative interface~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~3~~CallsGraph proc~function_name~3 function_name string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~3~~CalledByGraph proc~function_name~3 function_name interface~function_name~3 function_name interface~function_name~3->proc~function_name~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~3.html"},{"title":"add – Inference-Engine","text":"module procedure add pure module module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: lhs type( network_increment_t ), intent(in) :: rhs Return Value type( network_increment_t ) Called by proc~~add~~CalledByGraph proc~add add interface~add add interface~add->proc~add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/add.html"},{"title":"average – Inference-Engine","text":"module procedure average module procedure average() Arguments None Calls proc~~average~~CallsGraph proc~average average assert assert proc~average->assert rhs rhs proc~average->rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/average.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~6.html"},{"title":"delta_b_hidden – Inference-Engine","text":"module procedure delta_b_hidden pure module module function delta_b_hidden(self) result(my_delta_b_hidden) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~delta_b_hidden~~CalledByGraph proc~delta_b_hidden delta_b_hidden interface~delta_b_hidden delta_b_hidden interface~delta_b_hidden->proc~delta_b_hidden Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delta_b_hidden.html"},{"title":"delta_b_out – Inference-Engine","text":"module procedure delta_b_out pure module module function delta_b_out(self) result(my_delta_b_out) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~delta_b_out~~CalledByGraph proc~delta_b_out delta_b_out interface~delta_b_out delta_b_out interface~delta_b_out->proc~delta_b_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delta_b_out.html"},{"title":"delta_w_hidden – Inference-Engine","text":"module procedure delta_w_hidden pure module module function delta_w_hidden(self) result(my_delta_w_hidden) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:,:) Called by proc~~delta_w_hidden~~CalledByGraph proc~delta_w_hidden delta_w_hidden interface~delta_w_hidden delta_w_hidden interface~delta_w_hidden->proc~delta_w_hidden Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delta_w_hidden.html"},{"title":"delta_w_in – Inference-Engine","text":"module procedure delta_w_in pure module module function delta_w_in(self) result(my_delta_w_in) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~delta_w_in~~CalledByGraph proc~delta_w_in delta_w_in interface~delta_w_in delta_w_in interface~delta_w_in->proc~delta_w_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delta_w_in.html"},{"title":"delta_w_out – Inference-Engine","text":"module procedure delta_w_out pure module module function delta_w_out(self) result(my_delta_w_out) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:,:) Called by proc~~delta_w_out~~CalledByGraph proc~delta_w_out delta_w_out interface~delta_w_out delta_w_out interface~delta_w_out->proc~delta_w_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delta_w_out.html"},{"title":"divide – Inference-Engine","text":"module procedure divide pure module module function divide(numerator, denominator) result(ratio) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: numerator integer, intent(in) :: denominator Return Value type( network_increment_t ) Called by proc~~divide~~CalledByGraph proc~divide divide interface~divide divide interface~divide->proc~divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/divide.html"},{"title":"inference_engine_m – Inference-Engine","text":"Uses step_m inference_strategy_m matmul_m sigmoid_m swish_m activation_strategy_m neuron_m outputs_m concurrent_dot_products_m mini_batch_m inference_engine_m_ kind_parameters_m differentiable_activation_strategy_m layer_m input_output_pair_m trainable_engine_m inputs_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~matmul_m matmul_m module~inference_engine_m->module~matmul_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~neuron_m neuron_m module~inference_engine_m->module~neuron_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~outputs_m outputs_m module~inference_engine_m->module~outputs_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m string_m string_m module~step_m->string_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~matmul_m->module~inference_strategy_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~outputs_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~outputs_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~outputs_m module~inference_engine_m_->string_m file_m file_m module~inference_engine_m_->file_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~inference_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inputs_m module~trainable_engine_m->module~outputs_m module~trainable_engine_m->string_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~outputs_m->module~kind_parameters_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~outputs_m module~layer_m->module~neuron_m module~layer_m->module~kind_parameters_m module~layer_m->string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m module~network_increment_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/inference_engine_m.html"},{"title":"network_increment_m – Inference-Engine","text":"Uses kind_parameters_m module~~network_increment_m~~UsesGraph module~network_increment_m network_increment_m module~kind_parameters_m kind_parameters_m module~network_increment_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: network_increment_s module~~network_increment_m~~UsedByGraph module~network_increment_m network_increment_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~network_increment_m module~network_increment_s network_increment_s module~network_increment_s->module~network_increment_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~network_increment_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces network_increment_t operator(.average.) add delta_b_hidden delta_b_out delta_w_hidden delta_w_in delta_w_out divide Derived Types network_increment_t Interfaces public interface network_increment_t private pure module function construct(delta_w_in, delta_w_hidden, delta_w_out, delta_b_hidden, delta_b_out) result(network_increment) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: delta_w_in (:,:) real(kind=rkind), intent(in) :: delta_w_hidden (:,:,:) real(kind=rkind), intent(in) :: delta_w_out (:,:) real(kind=rkind), intent(in) :: delta_b_hidden (:,:) real(kind=rkind), intent(in) :: delta_b_out (:) Return Value type( network_increment_t ) public interface operator(.average.) private pure module function average(rhs) result(average_increment) Arguments Type Intent Optional Attributes Name type( network_increment_t ), intent(in) :: rhs (:) Return Value type( network_increment_t ) interface private pure module module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: lhs type( network_increment_t ), intent(in) :: rhs Return Value type( network_increment_t ) interface private pure module module function delta_b_hidden(self) result(my_delta_b_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private pure module module function delta_b_out(self) result(my_delta_b_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) interface private pure module module function delta_w_hidden(self) result(my_delta_w_hidden) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) interface private pure module module function delta_w_in(self) result(my_delta_w_in) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private pure module module function delta_w_out(self) result(my_delta_w_out) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private pure module module function divide(numerator, denominator) result(ratio) Implementation → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: numerator integer, intent(in) :: denominator Return Value type( network_increment_t ) Derived Types type, public :: network_increment_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: delta_b_hidden_ (:,:) real(kind=rkind), private, allocatable :: delta_b_out_ (:) real(kind=rkind), private, allocatable :: delta_w_hidden_ (:,:,:) real(kind=rkind), private, allocatable :: delta_w_in_ (:,:) real(kind=rkind), private, allocatable :: delta_w_out_ (:,:) Constructor private pure,module function construct (delta_w_in, delta_w_hidden, delta_w_out, delta_b_hidden, delta_b_out) Type-Bound Procedures procedure, public :: delta_b_hidden procedure, public :: delta_b_out procedure, public :: delta_w_hidden procedure, public :: delta_w_in procedure, public :: delta_w_out generic, public :: operator(+) => add generic, public :: operator(/) => divide procedure, private :: add procedure, private :: divide","tags":"","loc":"module/network_increment_m.html"},{"title":"step_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m string_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m string_m string_m module~step_m->string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~inference_engine_m->module~step_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~step_m module~step_s step_s module~step_s->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m program~read_json read_json program~read_json->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation function_name Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: function_name","tags":"","loc":"module/step_m.html"},{"title":"mini_batch_m – Inference-Engine","text":"Uses kind_parameters_m input_output_pair_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_m->module~kind_parameters_m module~inputs_m inputs_m module~input_output_pair_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~input_output_pair_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~trainable_engine_m->module~mini_batch_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces mini_batch_t input_output_pairs Derived Types mini_batch_t Interfaces public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor private pure,module function construct (input_output_pairs) Type-Bound Procedures procedure, public :: input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~inference_strategy_m inference_strategy_m module~inference_strategy_m->module~kind_parameters_m module~outputs_m outputs_m module~inference_strategy_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m program~write_read_infer->module~outputs_m module~step_m step_m program~write_read_infer->module~step_m module~matmul_m matmul_m program~write_read_infer->module~matmul_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~inference_strategy_m module~trainable_engine_m->module~mini_batch_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~trainable_engine_m->module~outputs_m module~inputs_m inputs_m module~trainable_engine_m->module~inputs_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~expected_outputs_m->module~kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~sigmoid_m module~neuron_m neuron_m module~inference_engine_m->module~neuron_m module~inference_engine_m->module~outputs_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~activation_strategy_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~inference_engine_m->module~differentiable_activation_strategy_m module~neuron_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~expected_outputs_m module~input_output_pair_m->module~inputs_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~kind_parameters_m program~icar_qr_network->module~inference_engine_m program~icar_qr_network->module~outputs_m program~icar_qr_network->module~matmul_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m_->module~outputs_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~activation_strategy_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~outputs_m module~concurrent_dot_products_m->module~activation_strategy_m module~layer_m->module~kind_parameters_m module~layer_m->module~neuron_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~inference_strategy_m module~matmul_m->module~outputs_m module~matmul_m->module~activation_strategy_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~network_increment_m->module~kind_parameters_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~network_increment_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m program~read_json read_json program~read_json->module~inference_engine_m program~read_json->module~matmul_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_s layer_s module~layer_s->module~layer_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~neuron_m module~inference_engine_s->module~outputs_m module~inference_engine_s->module~step_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~layer_m module~inference_engine_s->module~matmul_m module~inference_engine_s->module~activation_strategy_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~differentiable_activation_strategy_m module~expected_outputs_s expected_outputs_s module~expected_outputs_s->module~expected_outputs_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~outputs_s outputs_s module~outputs_s->module~outputs_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~step_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~concurrent_dot_products_s->module~activation_strategy_m module~inputs_s inputs_s module~inputs_s->module~inputs_m module~network_increment_s network_increment_s module~network_increment_s->module~network_increment_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses kind_parameters_m string_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~step_m step_m module~step_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~matmul_m matmul_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~step_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~inference_engine_m_ module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~activation_strategy_m module~inference_engine_s->module~step_m module~inference_engine_s->module~differentiable_activation_strategy_m module~inference_engine_s->module~matmul_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_s->module~step_m module~concurrent_dot_products_s->module~concurrent_dot_products_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m program~write_read_infer->module~matmul_m program~write_read_infer->module~inference_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_strategy_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~step_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~matmul_m program~icar_qr_network->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_i function_name_i Derived Types activation_strategy_t Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/activation_strategy_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses neuron_m kind_parameters_m string_m module~~layer_m~~UsesGraph module~layer_m layer_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m string_m string_m module~layer_m->string_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces layer_t count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Derived Types layer_t Interfaces public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer interface private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) interface private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private recursive,module function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: hidden_biases procedure, public :: hidden_weights procedure, public :: input_weights procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: output_biases procedure, public :: output_weights","tags":"","loc":"module/layer_m.html"},{"title":"inference_engine_m_ – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses network_increment_m inference_strategy_m activation_strategy_m outputs_m differentiable_activation_strategy_m kind_parameters_m string_m file_m inputs_m module~~inference_engine_m_~~UsesGraph module~inference_engine_m_ inference_engine_m_ module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~inputs_m inputs_m module~inference_engine_m_->module~inputs_m module~inference_strategy_m inference_strategy_m module~inference_engine_m_->module~inference_strategy_m file_m file_m module~inference_engine_m_->file_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~outputs_m outputs_m module~inference_engine_m_->module~outputs_m string_m string_m module~inference_engine_m_->string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inputs_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~outputs_m module~network_increment_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m_~~UsedByGraph module~inference_engine_m_ inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables key Interfaces inference_engine_t activation_function_name assert_conformable_with assert_consistent hidden_weights increment infer_from_array_of_inputs infer_from_inputs_object input_weights neurons_per_layer norm num_hidden_layers num_inputs num_outputs output_weights skip subtract to_json Derived Types inference_engine_t Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces public interface inference_engine_t private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self interface private pure module module function hidden_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) interface private pure module module subroutine increment(self, network_increment) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(inout) :: self type( network_increment_t ), intent(in) :: network_increment interface private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) interface private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) interface private pure module module function input_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private pure module module function output_weights(self) result(w) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) real(kind=rkind), private, allocatable :: input_weights_ (:,:) type(string_t), private :: metadata_ (size(key)) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor private pure,module function construct_from_components (metadata, input_weights, hidden_weights, output_weights, biases, output_biases) private impure,elemental,module function construct_from_json (file_) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with procedure, public :: assert_consistent procedure, public :: hidden_weights procedure, public :: increment generic, public :: infer => infer_from_array_of_inputs, infer_from_inputs_object procedure, public :: input_weights procedure, public :: neurons_per_layer procedure, public :: norm procedure, public :: num_hidden_layers procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: output_weights procedure, public :: skip procedure, public :: to_json procedure, private :: infer_from_array_of_inputs procedure, private :: infer_from_inputs_object procedure, private :: subtract","tags":"","loc":"module/inference_engine_m_.html"},{"title":"input_output_pair_m – Inference-Engine","text":"Uses inputs_m kind_parameters_m expected_outputs_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~inputs_m inputs_m module~input_output_pair_m->module~inputs_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~expected_outputs_m expected_outputs_m module~input_output_pair_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_m->module~mini_batch_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces input_output_pair_t expected_outputs inputs Derived Types input_output_pair_t Interfaces public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( inputs_t ), intent(in) :: inputs type( expected_outputs_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( expected_outputs_t ) interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( inputs_t ) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial type( expected_outputs_t ), private :: expected_outputs_ type( inputs_t ), private :: inputs_ Constructor private elemental,module function construct (inputs, expected_outputs) Type-Bound Procedures procedure, public :: expected_outputs procedure, public :: inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"inputs_m – Inference-Engine","text":"Uses kind_parameters_m module~~inputs_m~~UsesGraph module~inputs_m inputs_m module~kind_parameters_m kind_parameters_m module~inputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inputs_s module~~inputs_m~~UsedByGraph module~inputs_m inputs_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~inputs_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~inputs_m module~input_output_pair_m input_output_pair_m module~input_output_pair_m->module~inputs_m module~inputs_s inputs_s module~inputs_s->module~inputs_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces inputs_t values Derived Types inputs_t Interfaces public interface inputs_t private pure module function construct_from_components(values) result(inputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( inputs_t ) interface private pure module module function values(self) result(inputs) Implementation → Arguments Type Intent Optional Attributes Name class( inputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: inputs_t Components Type Visibility Attributes Name Initial procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor private pure,module function construct_from_components (values)","tags":"","loc":"module/inputs_m.html"},{"title":"expected_outputs_m – Inference-Engine","text":"Uses kind_parameters_m module~~expected_outputs_m~~UsesGraph module~expected_outputs_m expected_outputs_m module~kind_parameters_m kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: expected_outputs_s module~~expected_outputs_m~~UsedByGraph module~expected_outputs_m expected_outputs_m module~input_output_pair_m input_output_pair_m module~input_output_pair_m->module~expected_outputs_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~expected_outputs_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~expected_outputs_s expected_outputs_s module~expected_outputs_s->module~expected_outputs_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces expected_outputs_t outputs Derived Types expected_outputs_t Interfaces public interface expected_outputs_t private pure module function construct(outputs) result(expected_outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) Return Value type( expected_outputs_t ) interface private pure module module function outputs(self) result(my_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( expected_outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: expected_outputs_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: outputs_ (:) Constructor private pure,module function construct (outputs) Type-Bound Procedures procedure, public :: outputs","tags":"","loc":"module/expected_outputs_m.html"},{"title":"inference_strategy_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m outputs_m module~~inference_strategy_m~~UsesGraph module~inference_strategy_m inference_strategy_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~outputs_m outputs_m module~inference_strategy_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_strategy_m~~UsedByGraph module~inference_strategy_m inference_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~inference_strategy_m module~matmul_m matmul_m module~matmul_m->module~inference_strategy_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~matmul_m module~inference_engine_m->module~trainable_engine_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~concurrent_dot_products_m->module~inference_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~matmul_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~matmul_m program~icar_qr_network->module~inference_engine_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces infer_interface Derived Types inference_strategy_t Abstract Interfaces abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, abstract :: inference_strategy_t Type-Bound Procedures procedure(infer_interface), public, nopass :: infer","tags":"","loc":"module/inference_strategy_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m string_m module~~swish_m~~UsesGraph module~swish_m swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m string_m string_m module~swish_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types swish_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/swish_m.html"},{"title":"matmul_m – Inference-Engine","text":"Perform inference using the matrix multiplication intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses activation_strategy_m inference_strategy_m outputs_m kind_parameters_m module~~matmul_m~~UsesGraph module~matmul_m matmul_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: matmul_s module~~matmul_m~~UsedByGraph module~matmul_m matmul_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~matmul_m program~icar_qr_network->module~inference_engine_m module~inference_engine_m->module~matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types matmul_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, extends( inference_strategy_t ) :: matmul_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/matmul_m.html"},{"title":"outputs_m – Inference-Engine","text":"Uses kind_parameters_m module~~outputs_m~~UsesGraph module~outputs_m outputs_m module~kind_parameters_m kind_parameters_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: outputs_s module~~outputs_m~~UsedByGraph module~outputs_m outputs_m module~inference_strategy_m inference_strategy_m module~inference_strategy_m->module~outputs_m program~write_read_infer write_read_infer program~write_read_infer->module~outputs_m module~matmul_m matmul_m program~write_read_infer->module~matmul_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~matmul_m->module~outputs_m module~matmul_m->module~inference_strategy_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~outputs_m module~trainable_engine_m->module~inference_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~outputs_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m->module~outputs_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~inference_engine_m_ module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~concurrent_dot_products_m->module~outputs_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~outputs_m module~inference_engine_s->module~matmul_m module~inference_engine_s->module~inference_engine_m_ program~icar_qr_network icar_qr_network program~icar_qr_network->module~outputs_m program~icar_qr_network->module~matmul_m program~icar_qr_network->module~inference_engine_m module~outputs_s outputs_s module~outputs_s->module~outputs_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces outputs_t outputs pre_activation_in pre_activation_out Derived Types outputs_t Interfaces public interface outputs_t private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t ) interface private pure module module function outputs(self) result(output_values) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) interface private pure module module function pre_activation_in(self) result(z) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) interface private pure module module function pre_activation_out(self) result(z_L) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: outputs_t Components Type Visibility Attributes Name Initial procedure, public :: outputs procedure, public :: pre_activation_in procedure, public :: pre_activation_out real(kind=rkind), private, allocatable :: outputs_ (:) network outputs real(kind=rkind), private, allocatable :: pre_activation_in_ (:,:) weighted & biased hidden-layer inputs for training real(kind=rkind), private, allocatable :: pre_activation_out_ (:) weighted & biased output for training Constructor private pure,module function construct_from_compoents (outputs, pre_activation_in, pre_activation_out)","tags":"","loc":"module/outputs_m.html"},{"title":"concurrent_dot_products_m – Inference-Engine","text":"Perform inference using the dot_product intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses activation_strategy_m inference_strategy_m outputs_m kind_parameters_m module~~concurrent_dot_products_m~~UsesGraph module~concurrent_dot_products_m concurrent_dot_products_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~outputs_m outputs_m module~concurrent_dot_products_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: concurrent_dot_products_s module~~concurrent_dot_products_m~~UsedByGraph module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~concurrent_dot_products_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types concurrent_dot_products_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/concurrent_dot_products_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~differentiable_activation_strategy_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m swish_m module~swish_m->module~differentiable_activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~sigmoid_m module~inference_engine_m->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~differentiable_activation_strategy_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types differentiable_activation_strategy_t Derived Types type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(activation_i), public, nopass :: activation_derivative procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"trainable_engine_m – Inference-Engine","text":"Define an abstraction that supports training a neural network Uses inference_strategy_m outputs_m expected_outputs_m mini_batch_m kind_parameters_m string_m differentiable_activation_strategy_m inputs_m module~~trainable_engine_m~~UsesGraph module~trainable_engine_m trainable_engine_m module~inference_strategy_m inference_strategy_m module~trainable_engine_m->module~inference_strategy_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inputs_m inputs_m module~trainable_engine_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~outputs_m outputs_m module~trainable_engine_m->module~outputs_m string_m string_m module~trainable_engine_m->string_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: trainable_engine_s module~~trainable_engine_m~~UsedByGraph module~trainable_engine_m trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Interfaces trainable_engine_t assert_consistent infer num_inputs num_layers train Derived Types trainable_engine_t Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Interfaces public interface trainable_engine_t private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private pure module module subroutine train(self, mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) Derived Types type, public :: trainable_engine_t Encapsulate the information needed to perform training Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor private pure,module function construct_from_padded_arrays (nodes, weights, biases, differentiable_activation_strategy, metadata) Type-Bound Procedures procedure, public :: assert_consistent procedure, public :: infer procedure, public :: num_inputs procedure, public :: num_layers procedure, public :: train","tags":"","loc":"module/trainable_engine_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses kind_parameters_m string_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m string_m string_m module~neuron_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~neuron_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~layer_m->module~neuron_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~inference_engine_s->module~layer_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces neuron_t bias next_allocated next_pointer num_inputs weights Derived Types neuron_t Interfaces public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private pure,recursive,module function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m string_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types sigmoid_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/sigmoid_m.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses step_m matmul_m sigmoid_m swish_m activation_strategy_m outputs_m differentiable_activation_strategy_m intrinsic_array_m assert_m formats_m iso_fortran_env file_m layer_m neuron_m Ancestors: inference_engine_m_ module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s module~step_m step_m module~inference_engine_s->module~step_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_s->module~differentiable_activation_strategy_m module~matmul_m matmul_m module~inference_engine_s->module~matmul_m intrinsic_array_m intrinsic_array_m module~inference_engine_s->intrinsic_array_m formats_m formats_m module~inference_engine_s->formats_m file_m file_m module~inference_engine_s->file_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_s->module~inference_engine_m_ module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m module~swish_m swish_m module~inference_engine_s->module~swish_m module~activation_strategy_m activation_strategy_m module~inference_engine_s->module~activation_strategy_m module~outputs_m outputs_m module~inference_engine_s->module~outputs_m assert_m assert_m module~inference_engine_s->assert_m iso_fortran_env iso_fortran_env module~inference_engine_s->iso_fortran_env module~layer_m layer_m module~inference_engine_s->module~layer_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m string_m string_m module~step_m->string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~outputs_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->file_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~outputs_m module~inference_engine_m_->module~kind_parameters_m module~inputs_m inputs_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~inference_strategy_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~inference_engine_m_->string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~outputs_m->module~kind_parameters_m module~layer_m->module~neuron_m module~layer_m->module~kind_parameters_m module~layer_m->string_m module~inputs_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~kind_parameters_m module~network_increment_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_activation_name Module Procedures activation_function_name assert_conformable_with assert_consistent construct_from_components construct_from_json hidden_weights increment infer_from_array_of_inputs infer_from_inputs_object input_weights neurons_per_layer norm num_hidden_layers num_inputs num_outputs output_weights skip subtract to_json Subroutines pure subroutine set_activation_name (inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Module Procedures module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self module procedure construct_from_components module procedure construct_from_components() Arguments None module procedure construct_from_json module procedure construct_from_json() Arguments None module procedure hidden_weights pure module module function hidden_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) module procedure increment pure module module subroutine increment(self, network_increment) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(inout) :: self type( network_increment_t ), intent(in) :: network_increment module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) module procedure input_weights pure module module function input_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure output_weights pure module module function output_weights(self) result(w) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure skip elemental module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/inference_engine_s.html"},{"title":"trainable_engine_s – Inference-Engine","text":"Uses network_increment_m sigmoid_m intrinsic_array_m assert_m input_output_pair_m Ancestors: trainable_engine_m module~~trainable_engine_s~~UsesGraph module~trainable_engine_s trainable_engine_s intrinsic_array_m intrinsic_array_m module~trainable_engine_s->intrinsic_array_m module~trainable_engine_m trainable_engine_m module~trainable_engine_s->module~trainable_engine_m module~sigmoid_m sigmoid_m module~trainable_engine_s->module~sigmoid_m assert_m assert_m module~trainable_engine_s->assert_m module~network_increment_m network_increment_m module~trainable_engine_s->module~network_increment_m module~input_output_pair_m input_output_pair_m module~trainable_engine_s->module~input_output_pair_m module~inference_strategy_m inference_strategy_m module~trainable_engine_m->module~inference_strategy_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inputs_m inputs_m module~trainable_engine_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~outputs_m outputs_m module~trainable_engine_m->module~outputs_m string_m string_m module~trainable_engine_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->string_m module~network_increment_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Module Procedures assert_consistent construct_from_padded_arrays infer num_inputs num_layers train Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure train pure module module subroutine train(self, mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:)","tags":"","loc":"module/trainable_engine_s.html"},{"title":"inputs_s – Inference-Engine","text":"Uses Ancestors: inputs_m module~~inputs_s~~UsesGraph module~inputs_s inputs_s module~inputs_m inputs_m module~inputs_s->module~inputs_m module~kind_parameters_m kind_parameters_m module~inputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_components values Module Procedures module procedure construct_from_components module procedure construct_from_components() Arguments None module procedure values pure module module function values(self) result(inputs) Interface → Arguments Type Intent Optional Attributes Name class( inputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/inputs_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses intrinsic_array_m assert_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m assert_m assert_m module~layer_s->assert_m module~layer_m layer_m module~layer_s->module~layer_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m string_m string_m module~layer_m->string_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Module Procedures module procedure construct module procedure construct() Arguments None module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer module procedure output_biases module module function output_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) module procedure output_weights module module function output_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:)","tags":"","loc":"module/layer_s.html"},{"title":"concurrent_dot_products_s – Inference-Engine","text":"Uses activation_strategy_m assert_m step_m Ancestors: concurrent_dot_products_m module~~concurrent_dot_products_s~~UsesGraph module~concurrent_dot_products_s concurrent_dot_products_s module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_s->module~activation_strategy_m assert_m assert_m module~concurrent_dot_products_s->assert_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~outputs_m outputs_m module~concurrent_dot_products_m->module~outputs_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->string_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"module/concurrent_dot_products_s.html"},{"title":"mini_batch_s – Inference-Engine","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_m->module~kind_parameters_m module~inputs_m inputs_m module~input_output_pair_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~input_output_pair_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct input_output_pairs Module Procedures module procedure construct module procedure construct() Arguments None module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m string_m string_m module~step_m->string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/step_s.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/swish_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m string_m string_m module~neuron_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bias construct next_allocated next_pointer num_inputs weights Module Procedures module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure construct module procedure construct() Arguments None module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"input_output_pair_s – Inference-Engine","text":"Uses Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~inputs_m inputs_m module~input_output_pair_m->module~inputs_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~expected_outputs_m expected_outputs_m module~input_output_pair_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct expected_outputs inputs Module Procedures module procedure construct module procedure construct() Arguments None module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( expected_outputs_t ) module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( inputs_t )","tags":"","loc":"module/input_output_pair_s.html"},{"title":"outputs_s – Inference-Engine","text":"Uses Ancestors: outputs_m module~~outputs_s~~UsesGraph module~outputs_s outputs_s module~outputs_m outputs_m module~outputs_s->module~outputs_m module~kind_parameters_m kind_parameters_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_compoents outputs pre_activation_in pre_activation_out Module Procedures module procedure construct_from_compoents module procedure construct_from_compoents() Arguments None module procedure outputs pure module module function outputs(self) result(output_values) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) module procedure pre_activation_in pure module module function pre_activation_in(self) result(z) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure pre_activation_out pure module module function pre_activation_out(self) result(z_L) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/outputs_s.html"},{"title":"matmul_s – Inference-Engine","text":"Uses Ancestors: matmul_m module~~matmul_s~~UsesGraph module~matmul_s matmul_s module~matmul_m matmul_m module~matmul_s->module~matmul_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m string_m string_m module~activation_strategy_m->string_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"module/matmul_s.html"},{"title":"expected_outputs_s – Inference-Engine","text":"Uses Ancestors: expected_outputs_m module~~expected_outputs_s~~UsesGraph module~expected_outputs_s expected_outputs_s module~expected_outputs_m expected_outputs_m module~expected_outputs_s->module~expected_outputs_m module~kind_parameters_m kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct outputs Module Procedures module procedure construct module procedure construct() Arguments None module procedure outputs pure module module function outputs(self) result(my_outputs) Interface → Arguments Type Intent Optional Attributes Name class( expected_outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/expected_outputs_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/sigmoid_s.html"},{"title":"network_increment_s – Inference-Engine","text":"Uses assert_m Ancestors: network_increment_m module~~network_increment_s~~UsesGraph module~network_increment_s network_increment_s assert_m assert_m module~network_increment_s->assert_m module~network_increment_m network_increment_m module~network_increment_s->module~network_increment_m module~kind_parameters_m kind_parameters_m module~network_increment_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures add average construct delta_b_hidden delta_b_out delta_w_hidden delta_w_in delta_w_out divide Module Procedures module procedure add pure module module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: lhs type( network_increment_t ), intent(in) :: rhs Return Value type( network_increment_t ) module procedure average module procedure average() Arguments None module procedure construct module procedure construct() Arguments None module procedure delta_b_hidden pure module module function delta_b_hidden(self) result(my_delta_b_hidden) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure delta_b_out pure module module function delta_b_out(self) result(my_delta_b_out) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) module procedure delta_w_hidden pure module module function delta_w_hidden(self) result(my_delta_w_hidden) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:,:) module procedure delta_w_in pure module module function delta_w_in(self) result(my_delta_w_in) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure delta_w_out pure module module function delta_w_out(self) result(my_delta_w_out) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure divide pure module module function divide(numerator, denominator) result(ratio) Interface → Arguments Type Intent Optional Attributes Name class( network_increment_t ), intent(in) :: numerator integer, intent(in) :: denominator Return Value type( network_increment_t )","tags":"","loc":"module/network_increment_s.html"},{"title":"read_json – Inference-Engine","text":"Uses command_line_m matmul_m inference_engine_m string_m file_m program~~read_json~~UsesGraph program~read_json read_json file_m file_m program~read_json->file_m module~matmul_m matmul_m program~read_json->module~matmul_m command_line_m command_line_m program~read_json->command_line_m string_m string_m program~read_json->string_m module~inference_engine_m inference_engine_m program~read_json->module~inference_engine_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inference_strategy_m module~step_m step_m module~inference_engine_m->module~step_m module~neuron_m neuron_m module~inference_engine_m->module~neuron_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~outputs_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~outputs_m module~step_m->string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~neuron_m->string_m module~neuron_m->module~kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~inference_engine_m_->file_m module~inference_engine_m_->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~outputs_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->string_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~inference_strategy_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inputs_m module~trainable_engine_m->module~outputs_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->string_m module~activation_strategy_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~sigmoid_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~outputs_m module~layer_m->string_m module~layer_m->module~kind_parameters_m module~layer_m->module~neuron_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m module~network_increment_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~read_json~~CallsGraph program~read_json read_json string_t string_t program~read_json->string_t file_t file_t program~read_json->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name command_line inference_engine input_file_name Variables Type Attributes Name Initial type(string_t) :: activation_name type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/read_json.html"},{"title":"netCDF_IO – Inference-Engine","text":"Uses netcdf assert_m program~~netcdf_io~~UsesGraph program~netcdf_io netCDF_IO netcdf netcdf program~netcdf_io->netcdf assert_m assert_m program~netcdf_io->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~netcdf_io~~CallsGraph program~netcdf_io netCDF_IO proc~netcdf_write netCDF_write program~netcdf_io->proc~netcdf_write assert assert program~netcdf_io->assert proc~netcdf_read netCDF_read program~netcdf_io->proc~netcdf_read proc~netcdf_write->assert nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror proc~netcdf_read->assert proc~netcdf_read->nf90_strerror data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_read data_written file_name i j nx ny Functions get_shape Subroutines netCDF_read netCDF_write Source Code netCDF_IO Variables Type Attributes Name Initial integer, allocatable :: data_read (:,:) integer, parameter :: data_written (*,*) = reshape([((i*j, i=1, nx), j=1, ny)], [ny, nx]) character(len=*), parameter :: file_name = \"netCDF_example.nc\" integer :: i integer :: j integer, parameter :: nx = 6 integer, parameter :: ny = 12 Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Subroutines subroutine netCDF_read (file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) subroutine netCDF_write (file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Source Code program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"program/netcdf_io.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses command_line_m step_m matmul_m inference_engine_m outputs_m kind_parameters_m string_m file_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer module~matmul_m matmul_m program~write_read_infer->module~matmul_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m file_m file_m program~write_read_infer->file_m module~step_m step_m program~write_read_infer->module~step_m command_line_m command_line_m program~write_read_infer->command_line_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~outputs_m outputs_m program~write_read_infer->module~outputs_m string_m string_m program~write_read_infer->string_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->string_m module~step_m->module~activation_strategy_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~step_m module~inference_engine_m->module~outputs_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m->module~inference_strategy_m module~neuron_m neuron_m module~inference_engine_m->module~neuron_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~activation_strategy_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~outputs_m->module~kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->file_m module~inference_engine_m_->module~outputs_m module~inference_engine_m_->string_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~activation_strategy_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~outputs_m module~trainable_engine_m->string_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~inference_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->string_m module~swish_m->module~differentiable_activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~outputs_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~layer_m->module~kind_parameters_m module~layer_m->string_m module~layer_m->module~neuron_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m module~network_increment_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer string_t string_t program~write_read_infer->string_t proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer proc~write_read_query_infer->string_t file_t file_t proc~write_read_query_infer->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line file_name Subroutines write_read_query_infer Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"icar_qr_network – Inference-Engine","text":"Uses command_line_m matmul_m inference_engine_m outputs_m kind_parameters_m string_m file_m program~~icar_qr_network~~UsesGraph program~icar_qr_network icar_qr_network module~kind_parameters_m kind_parameters_m program~icar_qr_network->module~kind_parameters_m file_m file_m program~icar_qr_network->file_m module~matmul_m matmul_m program~icar_qr_network->module~matmul_m module~inference_engine_m inference_engine_m program~icar_qr_network->module~inference_engine_m command_line_m command_line_m program~icar_qr_network->command_line_m module~outputs_m outputs_m program~icar_qr_network->module~outputs_m string_m string_m program~icar_qr_network->string_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~matmul_m module~inference_engine_m->module~outputs_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m->module~inference_strategy_m module~neuron_m neuron_m module~inference_engine_m->module~neuron_m module~step_m step_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~activation_strategy_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_m->module~concurrent_dot_products_m module~layer_m layer_m module~inference_engine_m->module~layer_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~outputs_m->module~kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~step_m->module~kind_parameters_m module~step_m->string_m module~step_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->file_m module~inference_engine_m_->module~outputs_m module~inference_engine_m_->string_m module~inference_engine_m_->module~inference_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~inputs_m module~inference_engine_m_->module~activation_strategy_m module~network_increment_m network_increment_m module~inference_engine_m_->module~network_increment_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~outputs_m module~trainable_engine_m->string_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~inference_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inputs_m module~expected_outputs_m expected_outputs_m module~trainable_engine_m->module~expected_outputs_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->string_m module~swish_m->module~differentiable_activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~outputs_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~layer_m->module~kind_parameters_m module~layer_m->string_m module~layer_m->module~neuron_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~inputs_m module~input_output_pair_m->module~expected_outputs_m module~network_increment_m->module~kind_parameters_m module~expected_outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~icar_qr_network~~CallsGraph program~icar_qr_network icar_qr_network string_t string_t program~icar_qr_network->string_t file_t file_t program~icar_qr_network->file_t inputs inputs program~icar_qr_network->inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name command_line inference_engine input_file_name Variables Type Attributes Name Initial type(string_t) :: activation_name type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/icar_qr_network.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m use activation_strategy_m use concurrent_dot_products_m use differentiable_activation_strategy_m use inputs_m use inference_engine_m_ use inference_strategy_m use kind_parameters_m use layer_m use matmul_m use mini_batch_m use input_output_pair_m use neuron_m use outputs_m use sigmoid_m use step_m use swish_m use trainable_engine_m implicit none end module","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_s.f90->sourcefile~outputs_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m_ ) inference_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use matmul_m , only : matmul_t use step_m , only : step_t use swish_m , only : swish_t use sigmoid_m , only : sigmoid_t use layer_m , only : layer_t use neuron_m , only : neuron_t use file_m , only : file_t use formats_m , only : separated_values use iso_fortran_env , only : iostat_end use activation_strategy_m , only : activation_i use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use outputs_m , only : outputs_t implicit none contains pure subroutine set_activation_name ( inference_engine ) type ( inference_engine_t ), intent ( inout ) :: inference_engine ! This code is called in both constructors and and can't be refactored into a factory method ! pattern because the result would need to be allocatable and polymorphic, which would preclude ! the function being pure so it wouldn't be possible to call it from inside the pure constructor ! functions. select case ( inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string ()) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case default error stop \"inference_engine_t construct_from_components: unrecognized activation strategy\" end select end subroutine module procedure construct_from_components real ( rkind ), allocatable :: transposed (:,:,:) integer layer allocate ( transposed ( size ( hidden_weights , 2 ), size ( hidden_weights , 1 ), size ( hidden_weights , 3 ))) do concurrent ( layer = 1 : size ( hidden_weights , 3 )) transposed (:,:, layer ) = transpose ( hidden_weights (:,:, layer )) end do inference_engine % metadata_ = metadata inference_engine % input_weights_ = transpose ( input_weights ) inference_engine % hidden_weights_ = transposed inference_engine % output_weights_ = output_weights inference_engine % biases_ = biases inference_engine % output_biases_ = output_biases call set_activation_name ( inference_engine ) call inference_engine % assert_consistent end procedure module procedure construct_from_json type ( string_t ), allocatable :: lines (:) type ( layer_t ) hidden_layers , output_layer type ( neuron_t ) output_neuron real ( rkind ), allocatable :: hidden_weights (:,:,:) integer l lines = file_ % lines () l = 1 call assert ( adjustl ( lines ( l )% string ()) == \"{\" , \"construct_from_json: expecting '{' to start outermost object\" , lines ( l )% string ()) l = 2 inference_engine % metadata_ = [ string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"false\" )] if ( adjustl ( lines ( l )% string ()) == '\"metadata\": {' ) then block character ( len = :), allocatable :: justified_line do l = l + 1 justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == \"},\" ) exit inference_engine % metadata_ ( findloc ( key , trim ( get_key_string ( justified_line )), dim = 1 )) = get_key_value ( justified_line ) end do l = l + 1 end block end if call assert ( adjustl ( lines ( l )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( l )% string ()) l = l + 1 block integer , parameter :: lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l ) associate ( output_layer_line_number => l + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end block inference_engine % input_weights_ = transpose ( hidden_layers % input_weights ()) block type ( layer_t ), pointer :: next_layer real ( rkind ), allocatable :: transposed (:,:,:) integer layer next_layer => hidden_layers % next_pointer () if ( hidden_layers % next_allocated ()) then hidden_weights = next_layer % hidden_weights () else associate ( neurons_per_layer => size ( inference_engine % input_weights_ , 1 )) ! keep consistent with the eponymous function allocate ( hidden_weights ( neurons_per_layer , neurons_per_layer , 0 )) end associate end if inference_engine % biases_ = hidden_layers % hidden_biases () allocate ( transposed ( size ( hidden_weights , 2 ), size ( hidden_weights , 1 ), size ( hidden_weights , 3 ))) do concurrent ( layer = 1 : size ( hidden_weights , 3 )) transposed (:,:, layer ) = transpose ( hidden_weights (:,:, layer )) end do inference_engine % hidden_weights_ = transposed end block inference_engine % output_weights_ = output_layer % output_weights () inference_engine % output_biases_ = output_layer % output_biases () call set_activation_name ( inference_engine ) call inference_engine % assert_consistent contains pure function get_key_string ( line ) result ( unquoted_key ) character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: unquoted_key associate ( opening_key_quotes => index ( line , '\"' ), separator => index ( line , ':' )) associate ( closing_key_quotes => opening_key_quotes + index ( line ( opening_key_quotes + 1 :), '\"' )) unquoted_key = trim ( line ( opening_key_quotes + 1 : closing_key_quotes - 1 )) end associate end associate end function function get_key_value ( line ) result ( value_ ) character ( len =* ), intent ( in ) :: line type ( string_t ) value_ associate ( text_after_colon => line ( index ( line , ':' ) + 1 :)) associate ( opening_value_quotes => index ( text_after_colon , '\"' )) associate ( closing_value_quotes => opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' )) if ( any ([ opening_value_quotes , closing_value_quotes ] == 0 )) then value_ = string_t ( trim ( adjustl (( text_after_colon )))) else value_ = string_t ( text_after_colon ( opening_value_quotes + 1 : closing_value_quotes - 1 )) end if end associate end associate end associate end function end procedure construct_from_json module procedure assert_conformable_with call self % assert_consistent call inference_engine % assert_consistent associate ( equal_shapes => [ & shape ( self % input_weights_ ) == shape ( inference_engine % input_weights_ ), & shape ( self % hidden_weights_ ) == shape ( inference_engine % hidden_weights_ ), & shape ( self % output_weights_ ) == shape ( inference_engine % output_weights_ ), & shape ( self % biases_ ) == shape ( inference_engine % biases_ ), & shape ( self % output_biases_ ) == shape ( inference_engine % output_biases_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( same_type_as ( self % activation_strategy_ , inference_engine % activation_strategy_ ), \"assert_conformable_with: types)\" ) end procedure module procedure subtract call self % assert_conformable_with ( rhs ) difference % metadata_ = self % metadata_ difference % input_weights_ = self % input_weights_ - rhs % input_weights_ difference % hidden_weights_ = self % hidden_weights_ - rhs % hidden_weights_ difference % output_weights_ = self % output_weights_ - rhs % output_weights_ difference % biases_ = self % biases_ - rhs % biases_ difference % output_biases_ = self % output_biases_ - rhs % output_biases_ difference % activation_strategy_ = self % activation_strategy_ call difference % assert_consistent end procedure module procedure norm call self % assert_consistent norm_of_self = maxval ( abs ( self % input_weights_ )) + maxval ( abs ( self % hidden_weights_ )) + maxval ( abs ( self % output_weights_ )) + & maxval ( abs ( self % biases_ )) + maxval ( abs ( self % output_biases_ )) end procedure module procedure assert_consistent call assert ( all ( self % metadata_ % is_allocated ()), \"inference_engine_t%assert_consistent: self%metadata_s%is_allocated()\" ) call assert ( allocated ( self % activation_strategy_ ), \"inference_engine_t%assert_consistent: allocated(self%activation_strategy_)\" ) associate ( allocated_components => & [ allocated ( self % input_weights_ ), allocated ( self % hidden_weights_ ), allocated ( self % output_weights_ ), & allocated ( self % biases_ ), allocated ( self % output_biases_ )] & ) call assert ( all ( allocated_components ), \"inference_engine_s(assert_consistent): fully allocated object\" , & intrinsic_array_t ( allocated_components )) end associate associate ( num_neurons => 1 + & [ ubound ( self % biases_ , 1 ) - lbound ( self % biases_ , 1 ), & ubound ( self % hidden_weights_ , 1 ) - lbound ( self % hidden_weights_ , 1 ), & ubound ( self % hidden_weights_ , 2 ) - lbound ( self % hidden_weights_ , 2 ), & ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ), & ubound ( self % output_weights_ , 2 ) - lbound ( self % output_weights_ , 2 ) & ] ) call assert ( all ( num_neurons == num_neurons ( 1 )), \"inference_engine_s(assert_consistent): num_neurons\" , & intrinsic_array_t ( num_neurons ) & ) end associate associate ( output_count => 1 + & [ ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ), & ubound ( self % output_biases_ , 1 ) - lbound ( self % output_biases_ , 1 ) & ] ) call assert ( all ( output_count == output_count ( 1 )), \"inference_engine_s(assert_consistent): output_count\" , & intrinsic_array_t ( output_count ) & ) end associate end procedure module procedure num_outputs call assert_consistent ( self ) output_count = ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ) + 1 end procedure module procedure num_inputs call assert_consistent ( self ) input_count = ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ) + 1 end procedure module procedure neurons_per_layer call assert_consistent ( self ) neuron_count = ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ) + 1 end procedure module procedure num_hidden_layers call assert_consistent ( self ) hidden_layer_count = size ( self % hidden_weights_ , 3 ) + 1 end procedure module procedure infer_from_array_of_inputs integer layer call assert_consistent ( self ) outputs = inference_strategy % infer ( & input = input , & input_weights = self % input_weights_ , & hidden_weights = self % hidden_weights_ , & biases = self % biases_ , & output_biases = self % output_biases_ , & output_weights = self % output_weights_ , & activation_strategy = self % activation_strategy_ , & skip = self % skip () & ) end procedure module procedure infer_from_inputs_object integer layer call assert_consistent ( self ) outputs = inference_strategy % infer ( & input = inputs % values (), & input_weights = self % input_weights_ , & hidden_weights = self % hidden_weights_ , & biases = self % biases_ , & output_biases = self % output_biases_ , & output_weights = self % output_weights_ , & activation_strategy = self % activation_strategy_ , & skip = self % skip () & ) end procedure module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , metadata_outer_braces = 2 call assert_consistent ( self ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => self % num_hidden_layers (), neurons_per_layer => self % neurons_per_layer (), & num_outputs => self % num_outputs (), num_inputs => self % num_inputs ()) associate ( num_lines => & outer_object_braces & + metadata_outer_braces + size ( key ) & + hidden_layer_outer_brackets + ( num_hidden_layers ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '    \"metadata\": {' ) line = line + 1 lines ( line ) = string_t ( '        \"modelName\": \"' // & self % metadata_ ( findloc ( key , \"modelName\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"modelAuthor\": \"' // & self % metadata_ ( findloc ( key , \"modelAuthor\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"compilationDate\": \"' // & self % metadata_ ( findloc ( key , \"compilationDate\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"activationFunction\": \"' // & self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"usingSkipConnections\": ' // & self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string ()) line = line + 1 lines ( line ) = string_t ( '    },' ) line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % input_weights_ ( neuron ,:) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ] \" , \"         ],\" , any ( num_hidden_layers == [ 1 , line ])))) do layer = 1 , num_hidden_layers - 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % hidden_weights_ (:, neuron , layer ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers - 1 ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % output_weights_ ( neuron ,:) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % output_biases_ ( neuron ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" ) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure skip use_skip_connections = self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string () == \"true\" end procedure module procedure activation_function_name activation_name = self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 )) end procedure module procedure input_weights w = self % input_weights_ end procedure module procedure hidden_weights w = self % hidden_weights_ end procedure module procedure output_weights w = self % output_weights_ end procedure module procedure increment self % input_weights_ = self % input_weights_ + network_increment % delta_w_in () self % hidden_weights_ = self % hidden_weights_ + network_increment % delta_w_hidden () self % output_weights_ = self % output_weights_ + network_increment % delta_w_out () self % biases_ = self % biases_ + network_increment % delta_b_hidden () self % output_biases_ = self % output_biases_ + network_increment % delta_b_out () end procedure end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"network_increment_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~network_increment_m.f90~~EfferentGraph sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~network_increment_m.f90~~AfferentGraph sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~network_increment_m.f90 sourcefile~network_increment_s.f90 network_increment_s.f90 sourcefile~network_increment_s.f90->sourcefile~network_increment_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules network_increment_m Source Code network_increment_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module network_increment_m use kind_parameters_m , only : rkind implicit none private public :: network_increment_t public :: operator (. average .) type network_increment_t private real ( rkind ), allocatable :: delta_w_in_ (:,:) real ( rkind ), allocatable :: delta_w_hidden_ (:,:,:) real ( rkind ), allocatable :: delta_w_out_ (:,:) real ( rkind ), allocatable :: delta_b_hidden_ (:,:) real ( rkind ), allocatable :: delta_b_out_ (:) contains procedure , private :: add generic :: operator ( + ) => add procedure , private :: divide generic :: operator ( / ) => divide procedure :: delta_w_in procedure :: delta_w_hidden procedure :: delta_w_out procedure :: delta_b_hidden procedure :: delta_b_out end type interface network_increment_t pure module function construct ( delta_w_in , delta_w_hidden , delta_w_out , delta_b_hidden , delta_b_out ) result ( network_increment ) implicit none real ( rkind ), intent ( in ) :: delta_w_in (:,:) real ( rkind ), intent ( in ) :: delta_w_hidden (:,:,:) real ( rkind ), intent ( in ) :: delta_w_out (:,:) real ( rkind ), intent ( in ) :: delta_b_hidden (:,:) real ( rkind ), intent ( in ) :: delta_b_out (:) type ( network_increment_t ) network_increment end function end interface interface operator (. average .) pure module function average ( rhs ) result ( average_increment ) implicit none type ( network_increment_t ), intent ( in ) :: rhs (:) type ( network_increment_t ) average_increment end function end interface interface pure module function add ( lhs , rhs ) result ( total ) implicit none class ( network_increment_t ), intent ( in ) :: lhs type ( network_increment_t ), intent ( in ) :: rhs type ( network_increment_t ) total end function pure module function divide ( numerator , denominator ) result ( ratio ) implicit none class ( network_increment_t ), intent ( in ) :: numerator integer , intent ( in ) :: denominator type ( network_increment_t ) ratio end function pure module function delta_w_in ( self ) result ( my_delta_w_in ) implicit none class ( network_increment_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_delta_w_in (:,:) end function pure module function delta_w_hidden ( self ) result ( my_delta_w_hidden ) implicit none class ( network_increment_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_delta_w_hidden (:,:,:) end function pure module function delta_w_out ( self ) result ( my_delta_w_out ) implicit none class ( network_increment_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_delta_w_out (:,:) end function pure module function delta_b_hidden ( self ) result ( my_delta_b_hidden ) implicit none class ( network_increment_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_delta_b_hidden (:,:) end function pure module function delta_b_out ( self ) result ( my_delta_b_out ) implicit none class ( network_increment_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_delta_b_out (:) end function end interface end module network_increment_m","tags":"","loc":"sourcefile/network_increment_m.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"mini_batch_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mini_batch_m Source Code mini_batch_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : rkind implicit none private public :: mini_batch_t type mini_batch_t private type ( input_output_pair_t ), allocatable :: input_output_pairs_ (:) contains procedure :: input_output_pairs end type interface mini_batch_t pure module function construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function end interface interface pure module function input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"trainable_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_s.f90~~EfferentGraph sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~network_increment_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules trainable_engine_s Source Code trainable_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( trainable_engine_m ) trainable_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use network_increment_m , only : network_increment_t , operator (. average .) use input_output_pair_m , only : input_output_pair_t use sigmoid_m , only : sigmoid_t implicit none integer , parameter :: input_layer = 0 contains module procedure num_inputs n_in = self % n ( input_layer ) end procedure module procedure num_layers n_layers = size ( self % n , 1 ) end procedure module procedure assert_consistent associate ( & fully_allocated => [ allocated ( self % w ), allocated ( self % b ), allocated ( self % n ), allocated ( self % differentiable_activation_strategy_ )] & ) call assert ( all ( fully_allocated ), \"trainable_engine_s(assert_consistent): fully_allocated\" , intrinsic_array_t ( fully_allocated )) end associate associate ( max_width => maxval ( self % n ), component_dims => [ size ( self % b , 1 ), size ( self % w , 1 ), size ( self % w , 2 )]) call assert ( all ( component_dims == max_width ), \"trainable_engine_s(assert_consistent): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate call assert ( lbound ( self % n , 1 ) == input_layer , \"trainable_engine_s(assert_consistent): n base subsscript\" , lbound ( self % n , 1 )) end procedure module procedure infer real ( rkind ), allocatable :: z (:,:), a (:,:) integer l call self % assert_consistent associate ( w => self % w , b => self % b , n => self % n , output_layer => ubound ( self % b , 2 )) allocate ( z , mold = b ) allocate ( a ( maxval ( n ), input_layer : output_layer )) ! Activations a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward associate ( n_hidden => output_layer - 1 ) outputs = outputs_t ( & outputs = a ( 1 : n ( output_layer ), output_layer ), & pre_activation_in = z (:, 1 : n_hidden ), & pre_activation_out = z ( 1 : n ( output_layer ), output_layer ) & ) end associate end associate end procedure module procedure train integer i , j , k , l , batch , iter , mini_batch_size , pair real ( rkind ), parameter :: eta = 1.5e0 ! Learning parameter real ( rkind ), allocatable :: z (:,:), a (:,:), y (:), delta (:,:), dcdw (:,:,:), dcdb (:,:) real ( rkind ) cost type ( inputs_t ), allocatable :: inputs (:) type ( expected_outputs_t ), allocatable :: expected_outputs (:) call self % assert_consistent associate ( output_layer => ubound ( self % n , 1 )) allocate ( a ( maxval ( self % n ), input_layer : output_layer )) ! Activations allocate ( dcdw , mold = self % w ) ! Gradient of cost function with respect to weights allocate ( z , mold = self % b ) ! z-values: Sum z_j&#94;l = w_jk&#94;{l} a_k&#94;{l-1} + b_j&#94;l allocate ( delta , mold = self % b ) allocate ( dcdb , mold = self % b ) ! Gradient of cost function with respect with biases associate ( w => self % w , b => self % b , n => self % n ) iterate_across_batches : & do iter = 1 , size ( mini_batches ) cost = 0. ; dcdw = 0. ; dcdb = 0. associate ( input_output_pairs => mini_batches ( iter )% input_output_pairs ()) inputs = input_output_pairs % inputs () expected_outputs = input_output_pairs % expected_outputs () mini_batch_size = size ( input_output_pairs ) end associate iterate_through_batch : & do pair = 1 , mini_batch_size a ( 1 : self % num_inputs (), input_layer ) = inputs ( pair )% values () y = expected_outputs ( pair )% outputs () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward cost = cost + sum (( y ( 1 : n ( output_layer )) - a ( 1 : n ( output_layer ), output_layer )) ** 2 ) / ( 2.e0 * mini_batch_size ) delta ( 1 : n ( output_layer ), output_layer ) = & ( a ( 1 : n ( output_layer ), output_layer ) - y ( 1 : n ( output_layer ))) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( output_layer ), output_layer )) associate ( n_hidden => self % num_layers () - 2 ) back_propagate_error : & do l = n_hidden , 1 , - 1 delta ( 1 : n ( l ), l ) = matmul ( transpose ( w ( 1 : n ( l + 1 ), 1 : n ( l ), l + 1 )), delta ( 1 : n ( l + 1 ), l + 1 )) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( l ), l )) end do back_propagate_error end associate sum_gradients : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) + delta ( 1 : n ( l ), l ) do concurrent ( j = 1 : n ( l )) dcdw ( j , 1 : n ( l - 1 ), l ) = dcdw ( j , 1 : n ( l - 1 ), l ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do end do sum_gradients end do iterate_through_batch adjust_weights_and_biases : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - eta * dcdb ( 1 : n ( l ), l ) ! Adjust biases dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / mini_batch_size w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - eta * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ! Adjust weights end do adjust_weights_and_biases end do iterate_across_batches end associate end associate end procedure module procedure construct_from_padded_arrays trainable_engine % n = nodes trainable_engine % w = weights trainable_engine % b = biases trainable_engine % differentiable_activation_strategy_ = differentiable_activation_strategy call trainable_engine % assert_consistent end procedure end submodule trainable_engine_s","tags":"","loc":"sourcefile/trainable_engine_s.f90.html"},{"title":"inputs_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inputs_s.f90~~EfferentGraph sourcefile~inputs_s.f90 inputs_s.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inputs_s.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inputs_s Source Code inputs_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inputs_m ) inputs_s implicit none contains module procedure construct_from_components inputs % values_ = values end procedure module procedure values inputs = self % values_ end procedure end submodule inputs_s","tags":"","loc":"sourcefile/inputs_s.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~kind_parameters_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~network_increment_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~network_increment_s.f90 network_increment_s.f90 sourcefile~network_increment_s.f90->sourcefile~network_increment_m.f90 sourcefile~expected_outputs_s.f90 expected_outputs_s.f90 sourcefile~expected_outputs_s.f90->sourcefile~expected_outputs_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~inputs_s.f90 inputs_s.f90 sourcefile~inputs_s.f90->sourcefile~inputs_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kind_parameters_m Source Code kind_parameters_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: activation_strategy_t public :: activation_i public :: function_name_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation procedure ( function_name_i ), nopass , deferred :: function_name end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name_i () result ( string ) implicit none type ( string_t ) string end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layer_m Source Code layer_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: count_layers procedure :: count_neurons procedure :: input_weights procedure :: hidden_weights procedure :: output_weights procedure :: output_biases procedure :: hidden_biases procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function input_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:) end function module function hidden_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:,:) end function module function output_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:) end function module function output_biases ( self ) result ( biases ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: biases (:) end function module function hidden_biases ( self ) result ( biases ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: biases (:,:) end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules layer_s Source Code layer_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_t construct: layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer = [ neurons_per_layer , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure input_weights type ( neuron_t ), pointer :: neuron integer i associate ( num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer ()) allocate ( weights ( num_inputs , neurons_per_layer )) neuron => self % neuron weights (:, 1 ) = neuron % weights () do i = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%input_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, i ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%input_weights: constant number of inputs\" ) end do neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%input_weights: .not. neuron%next_allocated()\" ) if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer ) = neuron % weights () end associate end procedure module procedure hidden_weights type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( & num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( weights ( num_inputs , neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron weights (:, 1 , l ) = neuron % weights () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, n , l ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%hidden_weights: constant number of inputs\" , & intrinsic_array_t ([ num_inputs , neuron % num_inputs (), l , n ])) end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer , l ) = neuron % weights () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_weights: .not. layer%next_allocated()\" ) end if end do loop_over_Layers end associate end procedure module procedure output_weights type ( neuron_t ), pointer :: neuron integer n associate ( num_outputs => self % neurons_per_layer (), neurons_per_hidden_layer => self % neuron % num_inputs ()) neuron => self % neuron allocate ( weights ( num_outputs , neurons_per_hidden_layer )) weights ( 1 ,:) = neuron % weights () loop_over_output_neurons : & do n = 2 , num_outputs - 1 call assert ( neuron % next_allocated (), \"layer_t%output_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights ( n ,:) = neuron % weights () call assert ( neuron % num_inputs () == neurons_per_hidden_layer , \"layer_t%output_weights: constant number of inputs\" ) end do loop_over_output_neurons if ( num_outputs > 1 ) then call assert ( neuron % next_allocated (), \"layer_t%output_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights ( num_outputs ,:) = neuron % weights () ! avoid redundant assignment call assert (. not . self % next_allocated (), \"layer_t%output_weights: .not. layer%next_allocated()\" ) end if end associate end procedure module procedure output_biases type ( neuron_t ), pointer :: neuron integer n associate ( num_outputs => self % neurons_per_layer ()) neuron => self % neuron allocate ( biases ( num_outputs )) biases ( 1 ) = neuron % bias () loop_over_output_neurons : & do n = 2 , num_outputs - 1 call assert ( neuron % next_allocated (), \"layer_t%output_biases: neuron%next_allocated()\" ) neuron => neuron % next_pointer () biases ( n ) = neuron % bias () end do loop_over_output_neurons if ( num_outputs > 1 ) then call assert ( neuron % next_allocated (), \"layer_t%output_biases: neuron%next_allocated()\" ) neuron => neuron % next_pointer () biases ( num_outputs ) = neuron % bias () ! avoid redundant assignment call assert (. not . self % next_allocated (), \"layer_t%output_biases: .not. layer%next_allocated()\" ) end if end associate end procedure module procedure hidden_biases type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( biases ( neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron biases ( 1 , l ) = neuron % bias () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , intrinsic_array_t ([ l , n ])) neuron => neuron % next_pointer () biases ( n , l ) = neuron % bias () end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%hidden_biases: .not. neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) if ( neurons_per_layer /= 1 ) biases ( neurons_per_layer , l ) = neuron % bias () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_biases: .not. layer%next_allocated()\" ) end if end do loop_over_layers end associate end procedure hidden_biases module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"concurrent_dot_products_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_s.f90~~EfferentGraph sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules concurrent_dot_products_s Source Code concurrent_dot_products_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( concurrent_dot_products_m ) concurrent_dot_products_s use assert_m , only : assert use activation_strategy_m , only : activation_strategy_t use step_m , only : step_t implicit none contains module procedure infer integer n , layer , m integer , parameter :: input_layer = 1 real ( rkind ), allocatable :: neuron (:,:), output_values (:), pre_activation_in (:,:), pre_activation_out (:) associate ( neurons_per_layer => size ( input_weights , 1 ), num_layers => size ( biases , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) allocate ( pre_activation_in , mold = neuron ) do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , input_layer ) = dot_product ( input_weights ( n ,:), input (:)) + biases ( n , input_layer ) neuron ( n , input_layer ) = activation_strategy % activation ( pre_activation_in ( n , input_layer )) end do do layer = 2 , num_layers if ( skip ) then do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , layer ) = dot_product ( hidden_weights ( n ,:, layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer ) neuron ( n , layer ) = neuron ( n , layer - 1 ) + activation_strategy % activation ( pre_activation_in ( n , layer )) end do else do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , layer ) = dot_product ( hidden_weights ( n ,:, layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer ) neuron ( n , layer ) = activation_strategy % activation ( pre_activation_in ( n , layer )) end do end if end do associate ( num_outputs => size ( output_weights , 1 )) allocate ( output_values ( num_outputs ), pre_activation_out ( num_outputs )) do concurrent ( m = 1 : num_outputs ) pre_activation_out ( m ) = dot_product ( output_weights ( m ,:), neuron (:, num_layers )) + output_biases ( m ) output_values ( m ) = activation_strategy % activation ( pre_activation_out ( m )) end do outputs = outputs_t ( output_values , pre_activation_in , pre_activation_out ) end associate end associate end procedure end submodule concurrent_dot_products_s","tags":"","loc":"sourcefile/concurrent_dot_products_s.f90.html"},{"title":"mini_batch_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules mini_batch_s Source Code mini_batch_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"inference_engine_m_.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m_.f90~~EfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m_.f90~~AfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m_ Source Code inference_engine_m_.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m_ !! Define an abstraction that supports inference operationsn on a neural network use string_m , only : string_t use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use file_m , only : file_t use kind_parameters_m , only : rkind use inputs_m , only : inputs_t use outputs_m , only : outputs_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use network_increment_m , only : network_increment_t implicit none private public :: inference_engine_t character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference private type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: input_weights_ (:,:) ! weights applied to go from the inputs to first hidden layer real ( rkind ), allocatable :: hidden_weights_ (:,:,:) ! weights applied to go from one hidden layer to the next real ( rkind ), allocatable :: output_weights_ (:,:) ! weights applied to go from the final hidden layer to the outputs real ( rkind ), allocatable :: biases_ (:,:) ! neuronal offsets for each hidden layer real ( rkind ), allocatable :: output_biases_ (:) ! neuronal offsets applied to outputs class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: to_json procedure , private :: infer_from_array_of_inputs procedure , private :: infer_from_inputs_object generic :: infer => infer_from_array_of_inputs , infer_from_inputs_object procedure :: num_inputs procedure :: num_outputs procedure :: neurons_per_layer procedure :: num_hidden_layers procedure :: norm procedure :: assert_conformable_with procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: skip procedure :: activation_function_name procedure :: assert_consistent procedure :: input_weights procedure :: hidden_weights procedure :: output_weights procedure :: increment end type interface inference_engine_t pure module function construct_from_components ( metadata , input_weights , hidden_weights , output_weights , biases , output_biases ) & result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ), dimension (:,:) :: input_weights , output_weights , biases real ( rkind ), intent ( in ) :: hidden_weights (:,:,:), output_biases (:) type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( inference_engine_t ), intent ( in ) :: self end subroutine impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( inference_engine_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine pure module function infer_from_array_of_inputs ( self , input , inference_strategy ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), intent ( in ) :: input (:) class ( inference_strategy_t ), intent ( in ) :: inference_strategy type ( outputs_t ) outputs end function elemental module function infer_from_inputs_object ( self , inputs , inference_strategy ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inputs_t ), intent ( in ) :: inputs class ( inference_strategy_t ), intent ( in ) :: inference_strategy type ( outputs_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function elemental module function neurons_per_layer ( self ) result ( neuron_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer neuron_count end function elemental module function num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer hidden_layer_count end function elemental module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function pure module function input_weights ( self ) result ( w ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), allocatable :: w (:,:) end function pure module function hidden_weights ( self ) result ( w ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), allocatable :: w (:,:,:) end function pure module function output_weights ( self ) result ( w ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), allocatable :: w (:,:) end function pure module subroutine increment ( self , network_increment ) implicit none class ( inference_engine_t ), intent ( inout ) :: self type ( network_increment_t ), intent ( in ) :: network_increment end subroutine end interface end module inference_engine_m_","tags":"","loc":"sourcefile/inference_engine_m_.f90.html"},{"title":"input_output_pair_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules input_output_pair_m Source Code input_output_pair_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use expected_outputs_m , only : expected_outputs_t use kind_parameters_m , only : rkind use inputs_m , only : inputs_t implicit none private public :: input_output_pair_t type input_output_pair_t private type ( inputs_t ) inputs_ type ( expected_outputs_t ) expected_outputs_ contains procedure :: inputs procedure :: expected_outputs end type interface input_output_pair_t elemental module function construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( inputs_t ), intent ( in ) :: inputs type ( expected_outputs_t ), intent ( in ) :: expected_outputs type ( input_output_pair_t ) input_output_pair end function end interface interface elemental module function inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( inputs_t ) :: my_inputs end function elemental module function expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( expected_outputs_t ) :: my_expected_outputs end function end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"inputs_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inputs_m.f90~~EfferentGraph sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inputs_m.f90~~AfferentGraph sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inputs_s.f90 inputs_s.f90 sourcefile~inputs_s.f90->sourcefile~inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inputs_m Source Code inputs_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inputs_m use kind_parameters_m , only : rkind implicit none private public :: inputs_t type inputs_t private real ( rkind ), allocatable :: values_ (:) contains procedure values end type interface inputs_t pure module function construct_from_components ( values ) result ( inputs ) implicit none real ( rkind ), intent ( in ) :: values (:) type ( inputs_t ) inputs end function end interface interface pure module function values ( self ) result ( inputs ) implicit none class ( inputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: inputs (:) end function end interface end module inputs_m","tags":"","loc":"sourcefile/inputs_m.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure module procedure function_name string = string_t ( \"step\" ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"expected_outputs_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~expected_outputs_m.f90~~EfferentGraph sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~expected_outputs_m.f90~~AfferentGraph sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~expected_outputs_s.f90 expected_outputs_s.f90 sourcefile~expected_outputs_s.f90->sourcefile~expected_outputs_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules expected_outputs_m Source Code expected_outputs_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module expected_outputs_m use kind_parameters_m , only : rkind implicit none private public :: expected_outputs_t type expected_outputs_t private real ( rkind ), allocatable :: outputs_ (:) contains procedure :: outputs end type interface expected_outputs_t pure module function construct ( outputs ) result ( expected_outputs ) implicit none real ( rkind ), intent ( in ) :: outputs (:) type ( expected_outputs_t ) expected_outputs end function end interface interface pure module function outputs ( self ) result ( my_outputs ) implicit none class ( expected_outputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_outputs (:) end function end interface end module expected_outputs_m","tags":"","loc":"sourcefile/expected_outputs_m.f90.html"},{"title":"inference_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_strategy_m.f90~~EfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_strategy_m.f90~~AfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_strategy_m Source Code inference_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_strategy_m use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: inference_strategy_t type , abstract :: inference_strategy_t contains procedure ( infer_interface ), nopass , deferred :: infer end type abstract interface pure function infer_interface ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) import activation_strategy_t , rkind , outputs_t implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module inference_strategy_m","tags":"","loc":"sourcefile/inference_strategy_m.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules swish_s Source Code swish_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure module procedure function_name string = string_t ( \"swish\" ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules swish_m Source Code swish_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules neuron_s Source Code neuron_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"read_json: neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"read_json: neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"read_json: neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"read_json: neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"matmul_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_m.f90~~EfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~matmul_m.f90~~AfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules matmul_m Source Code matmul_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matmul_m !! Perform inference using the matrix multiplication intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: matmul_t type , extends ( inference_strategy_t ) :: matmul_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module matmul_m","tags":"","loc":"sourcefile/matmul_m.f90.html"},{"title":"outputs_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~outputs_m.f90~~EfferentGraph sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~outputs_m.f90~~AfferentGraph sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules outputs_m Source Code outputs_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module outputs_m use kind_parameters_m , only : rkind implicit none private public :: outputs_t type outputs_t private real ( rkind ), allocatable :: outputs_ (:) !! network outputs real ( rkind ), allocatable :: pre_activation_in_ (:,:) !! weighted & biased hidden-layer inputs for training real ( rkind ), allocatable :: pre_activation_out_ (:) !! weighted & biased output for training contains procedure outputs procedure pre_activation_in procedure pre_activation_out end type interface outputs_t pure module function construct_from_compoents ( outputs , pre_activation_in , pre_activation_out ) result ( new_outputs_t ) implicit none real ( rkind ), intent ( in ) :: outputs (:) real ( rkind ), intent ( in ) :: pre_activation_in (:,:), pre_activation_out (:) type ( outputs_t ) new_outputs_t end function end interface interface pure module function outputs ( self ) result ( output_values ) implicit none class ( outputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: output_values (:) end function pure module function pre_activation_out ( self ) result ( z_L ) implicit none class ( outputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: z_L (:) end function pure module function pre_activation_in ( self ) result ( z ) implicit none class ( outputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: z (:,:) end function end interface end module outputs_m","tags":"","loc":"sourcefile/outputs_m.f90.html"},{"title":"concurrent_dot_products_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_m.f90~~EfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~concurrent_dot_products_m.f90~~AfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules concurrent_dot_products_m Source Code concurrent_dot_products_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module concurrent_dot_products_m !! Perform inference using the dot_product intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: concurrent_dot_products_t type , extends ( inference_strategy_t ) :: concurrent_dot_products_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module concurrent_dot_products_m","tags":"","loc":"sourcefile/concurrent_dot_products_m.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules differentiable_activation_strategy_m Source Code differentiable_activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"trainable_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_m.f90~~EfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~trainable_engine_m.f90~~AfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules trainable_engine_m Source Code trainable_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module trainable_engine_m !! Define an abstraction that supports training a neural network use inference_strategy_m , only : inference_strategy_t use outputs_m , only : outputs_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use string_m , only : string_t use kind_parameters_m , only : rkind use inputs_m , only : inputs_t use expected_outputs_m , only : expected_outputs_t use mini_batch_m , only : mini_batch_t implicit none private public :: trainable_engine_t type trainable_engine_t !! Encapsulate the information needed to perform training private real ( rkind ), allocatable :: w (:,:,:) ! weights real ( rkind ), allocatable :: b (:,:) ! biases integer , allocatable :: n (:) ! nuerons per layer class ( differentiable_activation_strategy_t ), allocatable :: differentiable_activation_strategy_ contains procedure :: assert_consistent procedure :: train procedure :: infer procedure :: num_layers procedure :: num_inputs end type integer , parameter :: input_layer = 0 interface trainable_engine_t pure module function construct_from_padded_arrays ( nodes , weights , biases , differentiable_activation_strategy , metadata ) & result ( trainable_engine ) implicit none integer , intent ( in ) :: nodes ( input_layer :) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) class ( differentiable_activation_strategy_t ), intent ( in ) :: differentiable_activation_strategy type ( string_t ), intent ( in ) :: metadata (:) type ( trainable_engine_t ) trainable_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( trainable_engine_t ), intent ( in ) :: self end subroutine pure module subroutine train ( self , mini_batches ) implicit none class ( trainable_engine_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches (:) end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( inputs_t ), intent ( in ) :: inputs type ( outputs_t ) outputs end function elemental module function num_inputs ( self ) result ( n_in ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_in end function elemental module function num_layers ( self ) result ( n_layers ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_layers end function end interface end module trainable_engine_m","tags":"","loc":"sourcefile/trainable_engine_m.f90.html"},{"title":"input_output_pair_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules input_output_pair_s Source Code input_output_pair_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s implicit none contains module procedure construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure inputs my_inputs = self % inputs_ end procedure module procedure expected_outputs my_expected_outputs = self % expected_outputs_ end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"outputs_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~outputs_s.f90~~EfferentGraph sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules outputs_s Source Code outputs_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( outputs_m ) outputs_s implicit none contains module procedure outputs output_values = self % outputs_ end procedure module procedure construct_from_compoents new_outputs_t % outputs_ = outputs new_outputs_t % pre_activation_in_ = pre_activation_in new_outputs_t % pre_activation_out_ = pre_activation_out end procedure module procedure pre_activation_out z_L = self % pre_activation_out_ end procedure module procedure pre_activation_in z = self % pre_activation_in_ end procedure end submodule outputs_s","tags":"","loc":"sourcefile/outputs_s.f90.html"},{"title":"matmul_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_s.f90~~EfferentGraph sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules matmul_s Source Code matmul_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matmul_m ) matmul_s implicit none contains module procedure infer real ( rkind ), allocatable , dimension (:,:) :: neuron , pre_activation_in real ( rkind ), allocatable , dimension (:) :: pre_activation_out associate ( num_layers => size ( biases , 2 )) associate ( neurons_per_layer => size ( input_weights , 1 )) allocate ( neuron ( neurons_per_layer , num_layers )) allocate ( pre_activation_in , mold = neuron ) end associate block integer , parameter :: input_layer = 1 pre_activation_in (:, input_layer ) = matmul ( input_weights (:,:), input (:)) + biases (:, input_layer ) neuron (:, input_layer ) = activation_strategy % activation ( pre_activation_in (:, input_layer )) end block block integer layer if ( skip ) then do layer = 2 , num_layers pre_activation_in (:, layer ) = matmul ( hidden_weights (:,:, layer - 1 ), neuron (:, layer - 1 )) + biases (:, layer ) neuron (:, layer ) = neuron (:, layer - 1 ) + activation_strategy % activation ( pre_activation_in (:, layer )) end do else do layer = 2 , num_layers pre_activation_in (:, layer ) = matmul ( hidden_weights (:,:, layer - 1 ), neuron (:, layer - 1 )) + biases (:, layer ) neuron (:, layer ) = activation_strategy % activation ( pre_activation_in (:, layer )) end do end if end block pre_activation_out = matmul ( output_weights (:,:), neuron (:, num_layers )) + output_biases (:) outputs = outputs_t ( activation_strategy % activation ( pre_activation_out ), pre_activation_in , pre_activation_out ) end associate end procedure end submodule matmul_s","tags":"","loc":"sourcefile/matmul_s.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules neuron_m Source Code neuron_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"expected_outputs_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~expected_outputs_s.f90~~EfferentGraph sourcefile~expected_outputs_s.f90 expected_outputs_s.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~expected_outputs_s.f90->sourcefile~expected_outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules expected_outputs_s Source Code expected_outputs_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( expected_outputs_m ) expected_outputs_s implicit none contains module procedure construct expected_outputs % outputs_ = outputs end procedure module procedure outputs my_outputs = self % outputs_ end procedure end submodule expected_outputs_s","tags":"","loc":"sourcefile/expected_outputs_s.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules sigmoid_s Source Code sigmoid_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure module procedure function_name string = string_t ( \"sigmoid\" ) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"network_increment_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~network_increment_s.f90~~EfferentGraph sourcefile~network_increment_s.f90 network_increment_s.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~network_increment_s.f90->sourcefile~network_increment_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules network_increment_s Source Code network_increment_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( network_increment_m ) network_increment_s use assert_m , only : assert implicit none contains module procedure construct network_increment % delta_w_in_ = delta_w_in network_increment % delta_w_hidden_ = delta_w_hidden network_increment % delta_w_out_ = delta_w_out network_increment % delta_b_hidden_ = delta_b_hidden network_increment % delta_b_out_ = delta_b_out end procedure module procedure add total % delta_w_in_ = lhs % delta_w_in_ + rhs % delta_w_in_ total % delta_w_hidden_ = lhs % delta_w_hidden_ + rhs % delta_w_hidden_ total % delta_w_out_ = lhs % delta_w_out_ + rhs % delta_w_out_ total % delta_b_hidden_ = lhs % delta_b_hidden_ + rhs % delta_b_hidden_ total % delta_b_out_ = lhs % delta_b_out_ + rhs % delta_b_out_ end procedure module procedure divide ratio % delta_w_in_ = numerator % delta_w_in_ / denominator ratio % delta_w_hidden_ = numerator % delta_w_hidden_ / denominator ratio % delta_w_out_ = numerator % delta_w_out_ / denominator ratio % delta_b_hidden_ = numerator % delta_b_hidden_ / denominator ratio % delta_b_out_ = numerator % delta_b_out_ / denominator end procedure module procedure average type ( network_increment_t ) total integer i associate ( num_increments => size ( rhs )) call assert ( num_increments > 0 , \"mini_batch_s average_increment: num_increments > 0\" ) total = rhs ( 1 ) do i = 2 , num_increments ! In Fortran 2023, this could be a concurrent reduction total = total + rhs ( i ) end do average_increment = total % divide ( num_increments ) end associate end procedure module procedure delta_w_in my_delta_w_in = self % delta_w_in_ end procedure module procedure delta_w_hidden my_delta_w_hidden = self % delta_w_hidden_ end procedure module procedure delta_w_out my_delta_w_out = self % delta_w_out_ end procedure module procedure delta_b_hidden my_delta_b_hidden = self % delta_b_hidden_ end procedure module procedure delta_b_out my_delta_b_out = self % delta_b_out_ end procedure end submodule network_increment_s","tags":"","loc":"sourcefile/network_increment_s.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sigmoid_m Source Code sigmoid_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"read.f90 – Inference-Engine","text":"This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs read_json Source Code read.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_json !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use file_m , only : file_t implicit none type ( string_t ) input_file_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine type ( string_t ) activation_name input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example read -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name )) print * , \"number of inputs: \" , inference_engine % num_inputs () print * , \"number of outputs: \" , inference_engine % num_outputs () print * , \"number of hidden layers: \" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer: \" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) end program","tags":"","loc":"sourcefile/read.f90.html"},{"title":"netCDF_IO.f90 – Inference-Engine","text":"Contents Programs netCDF_IO Source Code netCDF_IO.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"sourcefile/netcdf_io.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs write_read_infer Source Code write-read-infer.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use step_m , only : step_t use matmul_m , only : matmul_t use file_m , only : file_t use kind_parameters_m , only : rkind use outputs_m , only : outputs_t implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example write-read-infer -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( outputs_t ) network_outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & metadata = [ string_t ( \"XOR\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-02-18\" ), string_t ( \"step\" ), string_t ( \"false\" )], & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ] & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"number of hidden layers:\" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer:\" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ([ real ( rkind ) :: 0. , 1. ], matmul_t ()) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % outputs () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"},{"title":"icar-qr-network.f90 – Inference-Engine","text":"This file depends on sourcefile~~icar-qr-network.f90~~EfferentGraph sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~icar-qr-network.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_m.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_m.f90->sourcefile~neuron_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m.f90->sourcefile~layer_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~network_increment_m.f90 network_increment_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~network_increment_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~inputs_m.f90 sourcefile~expected_outputs_m.f90 expected_outputs_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~expected_outputs_m.f90 sourcefile~network_increment_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~expected_outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs icar_qr_network Source Code icar-qr-network.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program icar_qr_network !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use file_m , only : file_t use kind_parameters_m , only : rkind use outputs_m , only : outputs_t implicit none type ( string_t ) input_file_name , activation_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example icar-qr-network -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name )) print * , \"num_inputs = \" , inference_engine % num_inputs () print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) block real ( rkind ), parameter :: inputs ( * ) = [ real ( rkind ) :: & 5.4041727707954124e-05_rkind , 1.8311046012797760e-09_rkind , 5.4236606525370767e-13_rkind , 0._rkind , 0._rkind , & 2.3016514256596565e-02_rkind , 1.0734779465337851e-07_rkind , 3.9603170742807947e-10_rkind , 2.3047807216644287e+00_rkind , & 5.3973675537109375e+02_rkind & ] type ( outputs_t ) network_outputs print * , \"inputs: \" , inputs network_outputs = inference_engine % infer ( inputs , matmul_t ()) print * , \"outputs: \" , network_outputs % outputs () end block end program","tags":"","loc":"sourcefile/icar-qr-network.f90.html"}]}