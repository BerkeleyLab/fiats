var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine is a software library that supports researching options for efficiently propagating inputs through deep, feed-forward neural networks to produce outputs.  Inference-Engine's implementation language, Fortran 2018, makes it suitable for integration into high-performance computing (HPC) applications.  Novel features include Exposing concurrency via A pure inference function and An elemental activation strategy Gathering network weights and biases into contiguous arrays Runtime selection of inference algorithm Item 1 ensures that the infer procedure can be invoked inside Fortran's do concurrent construct, which some compilers can offload automatically to graphics processing units (GPUs).  We envision this being useful in applications that require large numbers of independent inferences.  Item 2 exploits the special case where the number of neurons is uniform across the network layers.  The use of contiguous arrays facilitates spatial locality in memory access patterns.  Item 3 offers the possibility of adaptive inference method selection based on runtime information.  The current methods include ones based on intrinsic functions, dot_product or matmul .  Future options will explore the use of OpenMP and OpenACC for vectorization, multithreading, and/or accelerator offloading. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the examples in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to performance inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~inference_strategy_t inference_strategy_t type~inference_engine_t->type~inference_strategy_t inference_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ hidden_weights_ inference_strategy_ input_weights_ output_biases_ output_weights_ Constructor inference_engine_t Type-Bound Procedures conformable_with infer neurons_per_layer norm num_hidden_layers num_inputs num_outputs operator(-) read_network subtract write_network Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real, private, allocatable :: biases_ (:,:) real, private, allocatable :: hidden_weights_ (:,:,:) class( inference_strategy_t ), private, allocatable :: inference_strategy_ real, private, allocatable :: input_weights_ (:,:) real, private, allocatable :: output_biases_ (:) real, private, allocatable :: output_weights_ (:,:) Constructor public interface inference_engine_t private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: input_weights real, intent(in) :: hidden_weights (:,:,:) real, intent(in), dimension(:,:) :: output_weights real, intent(in), dimension(:,:) :: biases real, intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: conformable_with interface private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical procedure, public :: infer interface private pure module module function infer(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real, intent(in) :: input (:) Return Value real,allocatable, (:) procedure, public :: neurons_per_layer interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real procedure, public :: num_hidden_layers interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: read_network interface private impure elemental module module subroutine read_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name procedure, public :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) procedure, public :: write_network interface private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"type/inference_engine_t.html"},{"title":"concurrent_dot_products_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Inherits type~~concurrent_dot_products_t~~InheritsGraph type~concurrent_dot_products_t concurrent_dot_products_t type~inference_strategy_t inference_strategy_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:)","tags":"","loc":"type/concurrent_dot_products_t.html"},{"title":"matmul_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: matmul_t Inherits type~~matmul_t~~InheritsGraph type~matmul_t matmul_t type~inference_strategy_t inference_strategy_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:)","tags":"","loc":"type/matmul_t.html"},{"title":"inference_strategy_t – Inference-Engine ","text":"type, public, abstract :: inference_strategy_t Inherited by type~~inference_strategy_t~~InheritedByGraph type~inference_strategy_t inference_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~inference_strategy_t inference_strategy_ type~concurrent_dot_products_t concurrent_dot_products_t type~concurrent_dot_products_t->type~inference_strategy_t type~matmul_t matmul_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure( infer_interface ), public, deferred, nopass :: infer pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Prototype Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:)","tags":"","loc":"type/inference_strategy_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"type/step_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~step_t step_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure( activation_interface ), public, deferred, nopass :: activation elemental function activation_interface(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"type/activation_strategy_t.html"},{"title":"infer_interface – Inference-Engine","text":"abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable,(:)","tags":"","loc":"interface/infer_interface.html"},{"title":"activation_interface – Inference-Engine","text":"abstract interface private elemental function activation_interface(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"interface/activation_interface.html"},{"title":"assert_consistent – Inference-Engine","text":"pure subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent proc~infer infer proc~infer->proc~assert_consistent proc~read_network read_network proc~read_network->proc~assert_consistent proc~write_network write_network proc~write_network->proc~assert_consistent interface~infer infer interface~infer->proc~infer interface~write_network write_network interface~write_network->proc~write_network interface~read_network read_network interface~read_network->proc~read_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct Functions private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: input_weights real, intent(in) :: hidden_weights (:,:,:) real, intent(in), dimension(:,:) :: output_weights real, intent(in), dimension(:,:) :: biases real, intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"conformable_with – Inference-Engine","text":"interface Calls interface~~conformable_with~~CallsGraph interface~conformable_with conformable_with proc~conformable_with conformable_with interface~conformable_with->proc~conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical","tags":"","loc":"interface/conformable_with.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer proc~assert_consistent assert_consistent proc~infer->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real, intent(in) :: input (:) Return Value real,allocatable,(:)","tags":"","loc":"interface/infer.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer assert assert proc~neurons_per_layer->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"interface Calls interface~~num_hidden_layers~~CallsGraph interface~num_hidden_layers num_hidden_layers proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers assert assert proc~num_hidden_layers->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs assert assert proc~num_inputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs assert assert proc~num_outputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"read_network – Inference-Engine","text":"interface Calls interface~~read_network~~CallsGraph interface~read_network read_network proc~read_network read_network interface~read_network->proc~read_network assert assert proc~read_network->assert proc~assert_consistent assert_consistent proc~read_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine read_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"interface/read_network.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"interface/subtract.html"},{"title":"write_network – Inference-Engine","text":"interface Calls interface~~write_network~~CallsGraph interface~write_network write_network proc~write_network write_network interface~write_network->proc~write_network assert assert proc~write_network->assert proc~assert_consistent assert_consistent proc~write_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"interface/write_network.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable,(:)","tags":"","loc":"interface/infer~2.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~3~~CallsGraph interface~infer~3 infer proc~infer~3 infer interface~infer~3->proc~infer~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable,(:)","tags":"","loc":"interface/infer~3.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"interface/activation.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"netCDF_read – Inference-Engine","text":"subroutine netCDF_read(file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) Calls proc~~netcdf_read~~CallsGraph proc~netcdf_read netCDF_read nf90_strerror nf90_strerror proc~netcdf_read->nf90_strerror assert assert proc~netcdf_read->assert data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_read~~CalledByGraph proc~netcdf_read netCDF_read program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_read.html"},{"title":"netCDF_write – Inference-Engine","text":"subroutine netCDF_write(file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Calls proc~~netcdf_write~~CallsGraph proc~netcdf_write netCDF_write nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror assert assert proc~netcdf_write->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_write~~CalledByGraph proc~netcdf_write netCDF_write program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_write.html"},{"title":"conformable_with – Inference-Engine","text":"module procedure conformable_with elemental module module function conformable_with(self, inference_engine) result(conformable) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical Called by proc~~conformable_with~~CalledByGraph proc~conformable_with conformable_with interface~conformable_with conformable_with interface~conformable_with->proc~conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/conformable_with.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(self, input) result(output) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real, intent(in) :: input (:) Return Value real,allocatable,(:) Calls proc~~infer~~CallsGraph proc~infer infer proc~assert_consistent assert_consistent proc~infer->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~neurons_per_layer~~CallsGraph proc~neurons_per_layer neurons_per_layer assert assert proc~neurons_per_layer->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_hidden_layers~~CallsGraph proc~num_hidden_layers num_hidden_layers assert assert proc~num_hidden_layers->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_hidden_layers~~CalledByGraph proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~~CallsGraph proc~num_inputs num_inputs assert assert proc~num_inputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs assert assert proc~num_outputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"read_network – Inference-Engine","text":"module procedure read_network impure elemental module module subroutine read_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name Calls proc~~read_network~~CallsGraph proc~read_network read_network assert assert proc~read_network->assert proc~assert_consistent assert_consistent proc~read_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_network~~CalledByGraph proc~read_network read_network interface~read_network read_network interface~read_network->proc~read_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_network.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"write_network – Inference-Engine","text":"module procedure write_network impure elemental module module subroutine write_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name Calls proc~~write_network~~CallsGraph proc~write_network write_network assert assert proc~write_network->assert proc~assert_consistent assert_consistent proc~write_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_network~~CalledByGraph proc~write_network write_network interface~write_network write_network interface~write_network->proc~write_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_network.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable,(:) Called by proc~~infer~3~~CalledByGraph proc~infer~3 infer interface~infer~3 infer interface~infer~3->proc~infer~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~3.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable,(:) Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"inference_engine_m – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses string_m inference_strategy_m activation_strategy_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m string_m string_m module~inference_engine_m->string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m program~read_and_query read_and_query program~read_and_query->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces inference_engine_t conformable_with infer neurons_per_layer norm num_hidden_layers num_inputs num_outputs read_network subtract write_network Derived Types inference_engine_t Interfaces public interface inference_engine_t private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: input_weights real, intent(in) :: hidden_weights (:,:,:) real, intent(in), dimension(:,:) :: output_weights real, intent(in), dimension(:,:) :: biases real, intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t ) interface private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical interface private pure module module function infer(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real, intent(in) :: input (:) Return Value real,allocatable, (:) interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private impure elemental module module subroutine read_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) interface private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name Derived Types type, public :: inference_engine_t Encapsulate the minimal information needed to performance inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real, private, allocatable :: biases_ (:,:) real, private, allocatable :: hidden_weights_ (:,:,:) class( inference_strategy_t ), private, allocatable :: inference_strategy_ real, private, allocatable :: input_weights_ (:,:) real, private, allocatable :: output_biases_ (:) real, private, allocatable :: output_weights_ (:,:) Constructor private pure,module function construct (input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) Type-Bound Procedures procedure, public :: conformable_with procedure, public :: infer procedure, public :: neurons_per_layer procedure, public :: norm procedure, public :: num_hidden_layers procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: read_network procedure, public :: subtract procedure, public :: write_network","tags":"","loc":"module/inference_engine_m.html"},{"title":"concurrent_dot_products_m – Inference-Engine","text":"Perform inference using the dot_product intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses inference_strategy_m activation_strategy_m module~~concurrent_dot_products_m~~UsesGraph module~concurrent_dot_products_m concurrent_dot_products_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: concurrent_dot_products_s module~~concurrent_dot_products_m~~UsedByGraph module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~concurrent_dot_products_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types concurrent_dot_products_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:) Derived Types type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/concurrent_dot_products_m.html"},{"title":"matmul_m – Inference-Engine","text":"Perform inference using the matrix multiplication intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses inference_strategy_m activation_strategy_m module~~matmul_m~~UsesGraph module~matmul_m matmul_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: matmul_s module~~matmul_m~~UsedByGraph module~matmul_m matmul_m module~matmul_s matmul_s module~matmul_s->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types matmul_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:) Derived Types type, public, extends( inference_strategy_t ) :: matmul_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/matmul_m.html"},{"title":"inference_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~inference_strategy_m~~UsesGraph module~inference_strategy_m inference_strategy_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_strategy_m~~UsedByGraph module~inference_strategy_m inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~inference_strategy_m module~matmul_m matmul_m module~matmul_m->module~inference_strategy_m program~read_and_query read_and_query program~read_and_query->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~concurrent_dot_products_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces infer_interface Derived Types inference_strategy_t Abstract Interfaces abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:) Derived Types type, public, abstract :: inference_strategy_t Type-Bound Procedures procedure(infer_interface), public, nopass :: infer","tags":"","loc":"module/inference_strategy_m.html"},{"title":"step_m – Inference-Engine","text":"Uses activation_strategy_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m module~step_s step_s module~step_s->module~step_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation","tags":"","loc":"module/step_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~matmul_m matmul_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~step_m step_m module~step_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~concurrent_dot_products_s->module~step_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~concurrent_dot_products_m module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~step_m program~read_and_query read_and_query program~read_and_query->module~inference_engine_m module~step_s step_s module~step_s->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_interface Derived Types activation_strategy_t Abstract Interfaces abstract interface private elemental function activation_interface(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_interface), public, nopass :: activation","tags":"","loc":"module/activation_strategy_m.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses concurrent_dot_products_m assert_m intrinsic_array_m step_m Ancestors: inference_engine_m module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s intrinsic_array_m intrinsic_array_m module~inference_engine_s->intrinsic_array_m module~concurrent_dot_products_m concurrent_dot_products_m module~inference_engine_s->module~concurrent_dot_products_m module~inference_engine_m inference_engine_m module~inference_engine_s->module~inference_engine_m module~step_m step_m module~inference_engine_s->module~step_m assert_m assert_m module~inference_engine_s->assert_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~activation_strategy_m string_m string_m module~inference_engine_m->string_m module~step_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines assert_consistent Module Procedures conformable_with construct infer neurons_per_layer norm num_hidden_layers num_inputs num_outputs read_network subtract write_network Subroutines pure subroutine assert_consistent (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Module Procedures module procedure conformable_with elemental module module function conformable_with(self, inference_engine) result(conformable) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical module procedure construct module procedure construct() Arguments None module procedure infer pure module module function infer(self, input) result(output) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real, intent(in) :: input (:) Return Value real,allocatable, (:) module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure read_network impure elemental module module subroutine read_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) module procedure write_network impure elemental module module subroutine write_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"module/inference_engine_s.html"},{"title":"step_s – Inference-Engine","text":"Uses Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~step_m step_m module~step_s->module~step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"module/step_s.html"},{"title":"matmul_s – Inference-Engine","text":"Uses Ancestors: matmul_m module~~matmul_s~~UsesGraph module~matmul_s matmul_s module~matmul_m matmul_m module~matmul_s->module~matmul_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:)","tags":"","loc":"module/matmul_s.html"},{"title":"concurrent_dot_products_s – Inference-Engine","text":"Uses assert_m activation_strategy_m step_m Ancestors: concurrent_dot_products_m module~~concurrent_dot_products_s~~UsesGraph module~concurrent_dot_products_s concurrent_dot_products_s assert_m assert_m module~concurrent_dot_products_s->assert_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_s->module~activation_strategy_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~step_m->module~activation_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: input (:) real, intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real, intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real, intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real, intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real, intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real,allocatable, (:)","tags":"","loc":"module/concurrent_dot_products_s.html"},{"title":"read_and_query – Inference-Engine","text":"Uses inference_engine_m string_m command_line_m program~~read_and_query~~UsesGraph program~read_and_query read_and_query module~inference_engine_m inference_engine_m program~read_and_query->module~inference_engine_m command_line_m command_line_m program~read_and_query->command_line_m string_m string_m program~read_and_query->string_m module~inference_engine_m->string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a file into an\ninference_engine_t object and then query the resulting object for its properties. Calls program~~read_and_query~~CallsGraph program~read_and_query read_and_query string_t string_t program~read_and_query->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line inference_engine input_file_name Variables Type Attributes Name Initial type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine character(len=:), allocatable :: input_file_name","tags":"","loc":"program/read_and_query.html"},{"title":"concurrent_inferences – Inference-Engine","text":"Uses command_line_m string_m inference_engine_m program~~concurrent_inferences~~UsesGraph program~concurrent_inferences concurrent_inferences command_line_m command_line_m program~concurrent_inferences->command_line_m module~inference_engine_m inference_engine_m program~concurrent_inferences->module~inference_engine_m string_m string_m program~concurrent_inferences->string_m module~inference_engine_m->string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read multiple neural networks, each from a\nseparate file, into an array of inference_engine_t objects and then perform\ninference concurrently using the resulting inference_engine_t array. Calls program~~concurrent_inferences~~CallsGraph program~concurrent_inferences concurrent_inferences array_of_strings array_of_strings program~concurrent_inferences->array_of_strings inference inference program~concurrent_inferences->inference Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line expected_result false file_names i inference_engine input_array input_files test_passes tolerance true truth_table Variables Type Attributes Name Initial type(command_line_t) :: command_line real, parameter :: expected_result (*) = [false, true, true, false] real, parameter :: false = 0. type(string_t), allocatable :: file_names (:) integer :: i type( inference_engine_t ), allocatable :: inference_engine (:) real, parameter :: input_array (*,*) = reshape([true, true, false, true, true, false, false, false], shape=[2, 4]) character(len=:), allocatable :: input_files logical, allocatable :: test_passes (:) real, parameter :: tolerance = 1.E-08 real, parameter :: true = 1. real, allocatable :: truth_table (:)","tags":"","loc":"program/concurrent_inferences.html"},{"title":"netCDF_IO – Inference-Engine","text":"Uses assert_m netcdf program~~netcdf_io~~UsesGraph program~netcdf_io netCDF_IO assert_m assert_m program~netcdf_io->assert_m netcdf netcdf program~netcdf_io->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~netcdf_io~~CallsGraph program~netcdf_io netCDF_IO proc~netcdf_write netCDF_write program~netcdf_io->proc~netcdf_write assert assert program~netcdf_io->assert proc~netcdf_read netCDF_read program~netcdf_io->proc~netcdf_read proc~netcdf_write->assert nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror proc~netcdf_read->assert proc~netcdf_read->nf90_strerror data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_read data_written file_name i j nx ny Functions get_shape Subroutines netCDF_read netCDF_write Source Code netCDF_IO Variables Type Attributes Name Initial integer, allocatable :: data_read (:,:) integer, parameter :: data_written (*,*) = reshape([((i*j, i=1, nx), j=1, ny)], [ny, nx]) character(len=*), parameter :: file_name = \"netCDF_example.nc\" integer :: i integer :: j integer, parameter :: nx = 6 integer, parameter :: ny = 12 Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Subroutines subroutine netCDF_read (file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) subroutine netCDF_write (file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Source Code program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"program/netcdf_io.html"},{"title":"construct_and_write – Inference-Engine","text":"Uses inference_engine_m string_m command_line_m program~~construct_and_write~~UsesGraph program~construct_and_write construct_and_write module~inference_engine_m inference_engine_m program~construct_and_write->module~inference_engine_m command_line_m command_line_m program~construct_and_write->command_line_m string_m string_m program~construct_and_write->string_m module~inference_engine_m->string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to construct a neural network from arrays of weights and biases\nand how to write the resulting object to a file in the format that is readable by the\ninference_engine_t read_network type-bound procedure. Calls program~~construct_and_write~~CallsGraph program~construct_and_write construct_and_write string_t string_t program~construct_and_write->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line i identity j output_file_name xor Variables Type Attributes Name Initial type(command_line_t) :: command_line integer :: i integer, parameter :: identity (*,*,*) = reshape([((merge(1, 0, i==j), i=1, 3), j=1, 3)], shape=[3, 3, 1]) integer :: j character(len=:), allocatable :: output_file_name type( inference_engine_t ) :: xor","tags":"","loc":"program/construct_and_write.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m ) inference_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use concurrent_dot_products_m , only : concurrent_dot_products_t use step_m , only : step_t implicit none contains module procedure construct inference_engine % input_weights_ = input_weights inference_engine % hidden_weights_ = hidden_weights inference_engine % output_weights_ = output_weights inference_engine % biases_ = biases inference_engine % output_biases_ = output_biases if ( present ( activation_strategy )) then inference_engine % activation_strategy_ = activation_strategy else inference_engine % activation_strategy_ = step_t () end if if ( present ( inference_strategy )) then inference_engine % inference_strategy_ = inference_strategy else inference_engine % inference_strategy_ = concurrent_dot_products_t () end if end procedure module procedure conformable_with conformable = all ( & [ shape ( self % input_weights_ ) == shape ( inference_engine % input_weights_ ) , & [ shape ( self % hidden_weights_ ) == shape ( inference_engine % hidden_weights_ )], & [ shape ( self % output_weights_ ) == shape ( inference_engine % output_weights_ )], & [ shape ( self % biases_ ) == shape ( inference_engine % biases_ )], & [ shape ( self % output_biases_ ) == shape ( inference_engine % output_biases_ )] & ] & ) end procedure module procedure subtract call assert ( self % conformable_with ( rhs ), \"inference_engine_t%subtract: conformable operands\" ) difference % input_weights_ = self % input_weights_ - rhs % input_weights_ difference % hidden_weights_ = self % hidden_weights_ - rhs % hidden_weights_ difference % output_weights_ = self % output_weights_ - rhs % output_weights_ difference % biases_ = self % biases_ - rhs % biases_ difference % output_biases_ = self % output_biases_ - rhs % output_biases_ end procedure module procedure norm norm_of_self = maxval ( abs ( self % input_weights_ )) + maxval ( abs ( self % hidden_weights_ )) + maxval ( abs ( self % output_weights_ )) + & maxval ( abs ( self % biases_ )) + maxval ( abs ( self % output_biases_ )) end procedure pure subroutine assert_consistent ( self ) type ( inference_engine_t ), intent ( in ) :: self call assert ( allocated ( self % inference_strategy_ ), \"inference_engine%assert_consistent: allocated(self%inference_strategy_)\" ) call assert ( allocated ( self % activation_strategy_ ), \"inference_engine%assert_consistent: allocated(self%activation_strategy_)\" ) associate ( allocated_components => & [ allocated ( self % input_weights_ ), allocated ( self % hidden_weights_ ), allocated ( self % biases_ ), allocated ( self % output_weights_ )] & ) call assert ( all ( allocated_components ), \"inference_engine_s(assert_consistent): fully allocated object\" , & intrinsic_array_t ( allocated_components )) end associate associate ( num_neurons => 1 + & [ ubound ( self % biases_ , 1 ) - lbound ( self % biases_ , 1 ), & ubound ( self % hidden_weights_ , 1 ) - lbound ( self % hidden_weights_ , 1 ), & ubound ( self % hidden_weights_ , 2 ) - lbound ( self % hidden_weights_ , 2 ), & ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ), & ubound ( self % output_weights_ , 2 ) - lbound ( self % output_weights_ , 2 ) & ] ) call assert ( all ( self % neurons_per_layer () == num_neurons ), \"inference_engine_s(assert_consistent): num_neurons\" , & intrinsic_array_t ( num_neurons ) & ) end associate associate ( output_count => 1 + & [ ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ), & ubound ( self % output_biases_ , 1 ) - lbound ( self % output_biases_ , 1 ) & ] ) call assert ( all ( self % num_outputs () == output_count ), \"inference_engine_s(assert_consistent): num_outputs\" , & intrinsic_array_t ( output_count ) & ) end associate end subroutine module procedure num_outputs call assert ( allocated ( self % output_weights_ ), \"inference_engine_t%num_outputs: allocated(self%output_weights_)\" ) output_count = ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ) + 1 end procedure module procedure num_inputs call assert ( allocated ( self % input_weights_ ), \"inference_engine_t%num_inputs: allocated(self%input_weights_)\" ) input_count = ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ) + 1 end procedure module procedure neurons_per_layer call assert ( allocated ( self % input_weights_ ), \"inference_engine_t%neurons_per_layer: allocated(self%input_weights_)\" ) neuron_count = ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ) + 1 end procedure module procedure num_hidden_layers call assert ( allocated ( self % hidden_weights_ ), \"inference_engine_t%num_hidden_layers: allocated(self%hidden_weights_)\" ) hidden_layer_count = ubound ( self % hidden_weights_ , 3 ) - lbound ( self % hidden_weights_ , 3 ) + 1 end procedure module procedure infer integer , parameter :: input_layer = 1 call assert_consistent ( self ) output = self % inference_strategy_ % infer ( input , & self % input_weights_ , self % hidden_weights_ , self % biases_ , self % output_biases_ , self % output_weights_ , self % activation_strategy_ & ) end procedure module procedure write_network integer file_unit , io_status , input , layer , neuron open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'unknown' , iostat = io_status , action = 'write' ) call assert ( io_status == 0 , \"write_network: io_status==0 after 'open' statement\" , file_name % string ()) call assert_consistent ( self ) write_input_layer : & block input = 1 write ( file_unit , * ) \"[[\" , self % input_weights_ ( input ,:), trim ( merge ( \"]]\" , \"] \" , self % num_inputs () == 1 )) do input = 2 , self % num_inputs () - 1 write ( file_unit , * ) \"[\" , self % input_weights_ ( input ,:), \"]\" end do input = self % num_inputs () if ( input > 1 ) write ( file_unit , * ) \"[\" , self % input_weights_ ( self % num_inputs (), :), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % biases_ (:, 1 ), \"]\" end block write_input_layer write_hidden_layers : & do layer = 1 , self % num_hidden_layers () write ( file_unit , * ) neuron = 1 write ( file_unit , * ) \"[[\" , self % hidden_weights_ (:, neuron , layer ), trim ( merge ( \"]]\" , \"] \" , self % neurons_per_layer () == 1 )) do neuron = 2 , self % neurons_per_layer () - 1 write ( file_unit , * ) \"[\" , self % hidden_weights_ (: , neuron , layer ), \"]\" end do neuron = self % neurons_per_layer () if ( neuron > 1 ) write ( file_unit , * ) \"[\" , self % hidden_weights_ (:, neuron , layer ), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % biases_ (:, layer + 1 ), \"]\" end do write_hidden_layers write_output_layer : & block write ( file_unit , * ) neuron = 1 write ( file_unit , * ) \"[[\" , self % output_weights_ (:, neuron ), trim ( merge ( \"]]\" , \"] \" , self % neurons_per_layer () == 1 )) do neuron = 2 , self % neurons_per_layer () - 1 write ( file_unit , * ) \"[\" , self % output_weights_ (:, neuron ), \"]\" end do neuron = self % neurons_per_layer () if ( neuron > 1 ) write ( file_unit , * ) \"[\" , self % output_weights_ (:, neuron ), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % output_biases_ (:), \"]\" end block write_output_layer close ( file_unit ) end procedure module procedure read_network integer file_unit , io_status , num_inputs , num_hidden_layers , num_outputs character ( len = :), allocatable :: line open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) call assert ( io_status == 0 , \"read_network: io_status==0 after 'open' statement\" , file_name % string ()) call read_line_and_count_inputs ( file_unit , line , num_inputs ) call count_hidden_layers ( file_unit , len ( line ), num_hidden_layers ) call count_outputs ( file_unit , len ( line ), num_hidden_layers , num_outputs ) associate ( last_opening_bracket => index ( line , \"[\" , back = . true .), first_closing_bracket => index ( line , \"]\" )) associate ( unbracketed_line => line ( last_opening_bracket + 1 : first_closing_bracket - 1 )) associate ( neurons_per_layer => num_array_elements_in ( unbracketed_line )) call read_weights_and_biases ( file_unit , len ( line ), num_inputs , neurons_per_layer , num_hidden_layers , num_outputs , self ) end associate end associate end associate self % activation_strategy_ = step_t () self % inference_strategy_ = concurrent_dot_products_t () close ( file_unit ) call assert_consistent ( self ) contains function line_length ( file_unit ) result ( length ) integer , intent ( in ) :: file_unit integer length , io_status character ( len = 1 ) c rewind ( file_unit ) io_status = 0 length = 1 do read ( file_unit , '(a)' , advance = 'no' , iostat = io_status ) c if ( io_status /= 0 ) exit length = length + 1 end do rewind ( file_unit ) end function subroutine read_line_and_count_inputs ( file_unit , line , input_count ) integer , intent ( in ) :: file_unit character ( len = :), intent ( out ), allocatable :: line integer , intent ( out ) :: input_count integer io_status rewind ( file_unit ) allocate ( character ( len = line_length ( file_unit )) :: line ) input_count = 0 do read ( file_unit , '(a)' , iostat = io_status ) line call assert ( io_status == 0 , \"read_line_and_count_inputs: io_status==0\" , io_status ) input_count = input_count + 1 if ( index ( line , \"]]\" , back = . true .) /= 0 ) exit end do rewind ( file_unit ) end subroutine pure function num_array_elements_in ( space_delimited_reals ) result ( array_size ) character ( len =* ), intent ( in ) :: space_delimited_reals real , allocatable :: array (:) integer array_size , io_status io_status = 0 array_size = 1 do while ( io_status == 0 ) if ( allocated ( array )) deallocate ( array ) allocate ( array ( array_size )) read ( space_delimited_reals , * , iostat = io_status ) array array_size = array_size + 1 end do array_size = size ( array ) - 1 end function subroutine read_weights_and_biases ( & file_unit , buffer_size , num_inputs , neurons_per_layer , num_hidden_layers , num_outputs , self & ) integer , intent ( in ) :: file_unit , buffer_size , num_inputs , neurons_per_layer , num_hidden_layers , num_outputs type ( inference_engine_t ), intent ( out ) :: self character ( len = buffer_size ) line_buffer integer input , io_status , layer , neuron integer , parameter :: input_layer = 1 rewind ( file_unit ) allocate ( self % input_weights_ ( num_inputs , neurons_per_layer )) read_input_weights : & do input = 1 , size ( self % input_weights_ , 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_input_weights: io_status==0\" , io_status ) associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % input_weights_ ( input ,:) end associate end associate end do read_input_weights allocate ( self % biases_ ( neurons_per_layer , num_hidden_layers + input_layer )) allocate ( self % hidden_weights_ ( neurons_per_layer , neurons_per_layer , num_hidden_layers )) find_input_layer_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_input_layer_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_input_layer_biases read_input_layer_biases : & associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % biases_ (:, input_layer ) end associate end associate read_input_layer_biases read_hidden_layer_weights_biases : & do layer = 1 , num_hidden_layers find_weights : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[[\" ) /= 0 ) exit end do find_weights read_weights : & do neuron = 1 , size ( self % hidden_weights_ , 2 ) if ( neuron /= 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % hidden_weights_ (:, neuron , layer ) end associate end associate end do read_weights find_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_biases read_biases : & associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % biases_ (:, input_layer + layer ) end associate end associate read_biases end do read_hidden_layer_weights_biases allocate ( self % output_weights_ ( num_outputs , neurons_per_layer )) allocate ( self % output_biases_ ( num_outputs )) find_output_weights : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_outut_layer_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[[\" ) /= 0 ) exit end do find_output_weights read_output_weights : & do neuron = 1 , size ( self % hidden_weights_ , 2 ) if ( neuron /= 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % output_weights_ (:, neuron ) end associate end associate end do read_output_weights find_output_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_outut_layer_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_output_biases associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % output_biases_ (:) end associate end associate rewind ( file_unit ) end subroutine read_weights_and_biases subroutine count_hidden_layers ( file_unit , buffer_size , hidden_layers ) integer , intent ( in ) :: file_unit , buffer_size integer , intent ( out ) :: hidden_layers integer , parameter :: input_layer = 1 , output_layer = 1 integer layers , io_status character ( len = buffer_size ) line_buffer rewind ( file_unit ) layers = 0 io_status = 0 do while ( io_status == 0 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer if ( index ( line_buffer , \"[[\" ) /= 0 ) layers = layers + 1 end do hidden_layers = layers - ( input_layer + output_layer ) rewind ( file_unit ) end subroutine subroutine count_outputs ( file_unit , buffer_size , num_hidden_layers , output_count ) integer , intent ( in ) :: file_unit , buffer_size , num_hidden_layers integer , intent ( out ) :: output_count character ( len = buffer_size ) line_buffer integer , parameter :: input_layer = 1 , output_layer = 1 integer layer rewind ( file_unit ) layer = 0 find_end_of_hidden_layers : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_hidden_layers: io_status==0\" , io_status ) if ( index ( line_buffer , \"]]\" ) /= 0 ) layer = layer + 1 if ( layer == input_layer + num_hidden_layers + output_layer ) exit end do find_end_of_hidden_layers find_and_read_output_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_output_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_and_read_output_biases associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) output_count = num_array_elements_in ( unbracketed_line ) end associate end associate rewind ( file_unit ) end subroutine end procedure read_network end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s implicit none contains module procedure activation y = merge ( 1. , 0. , x > 0 ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~read-and-query.f90 read-and-query.f90 sourcefile~read-and-query.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Define an abstraction that supports inference operationsn on a neural network use string_m , only : string_t use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t implicit none private public :: inference_engine_t type inference_engine_t !! Encapsulate the minimal information needed to performance inference private real , allocatable :: input_weights_ (:,:) ! weights applied to go from the inputs to first hidden layer real , allocatable :: hidden_weights_ (:,:,:) ! weights applied to go from one hidden layer to the next real , allocatable :: output_weights_ (:,:) ! weights applied to go from the final hidden layer to the outputs real , allocatable :: biases_ (:,:) ! neuronal offsets for each hidden layer real , allocatable :: output_biases_ (:) ! neuronal offsets applied to outputs class ( activation_strategy_t ), allocatable :: activation_strategy_ class ( inference_strategy_t ), allocatable :: inference_strategy_ contains procedure :: read_network procedure :: write_network procedure :: infer procedure :: num_inputs procedure :: num_outputs procedure :: neurons_per_layer procedure :: num_hidden_layers procedure :: norm procedure :: conformable_with procedure :: subtract generic :: operator ( - ) => subtract end type interface inference_engine_t pure module function construct & ( input_weights , hidden_weights , output_weights , biases , output_biases , inference_strategy , activation_strategy ) & result ( inference_engine ) implicit none real , intent ( in ), dimension (:,:) :: input_weights , output_weights , biases real , intent ( in ) :: hidden_weights (:,:,:), output_biases (:) class ( inference_strategy_t ), intent ( in ), optional :: inference_strategy class ( activation_strategy_t ), intent ( in ), optional :: activation_strategy type ( inference_engine_t ) inference_engine end function end interface interface impure elemental module subroutine read_network ( self , file_name ) implicit none class ( inference_engine_t ), intent ( out ) :: self type ( string_t ), intent ( in ) :: file_name end subroutine impure elemental module subroutine write_network ( self , file_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ), intent ( in ) :: file_name end subroutine elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( inference_engine_t ), intent ( in ) :: self real norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( inference_engine_t ) difference end function elemental module function conformable_with ( self , inference_engine ) result ( conformable ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine logical conformable end function pure module function infer ( self , input ) result ( output ) implicit none class ( inference_engine_t ), intent ( in ) :: self real , intent ( in ) :: input (:) real , allocatable :: output (:) end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function elemental module function neurons_per_layer ( self ) result ( neuron_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer neuron_count end function elemental module function num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer hidden_layer_count end function end interface end module inference_engine_m","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"concurrent_dot_products_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_m.f90~~EfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~concurrent_dot_products_m.f90~~AfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules concurrent_dot_products_m Source Code concurrent_dot_products_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module concurrent_dot_products_m !! Perform inference using the dot_product intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t implicit none private public :: concurrent_dot_products_t type , extends ( inference_strategy_t ) :: concurrent_dot_products_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) implicit none real , intent ( in ) :: input (:) real , intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real , intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real , intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer real , intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real , intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy real , allocatable :: output (:) end function end interface end module concurrent_dot_products_m","tags":"","loc":"sourcefile/concurrent_dot_products_m.f90.html"},{"title":"matmul_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_m.f90~~EfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~matmul_m.f90~~AfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules matmul_m Source Code matmul_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matmul_m !! Perform inference using the matrix multiplication intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t implicit none private public :: matmul_t type , extends ( inference_strategy_t ) :: matmul_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) implicit none real , intent ( in ) :: input (:) real , intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real , intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real , intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer real , intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real , intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy real , allocatable :: output (:) end function end interface end module matmul_m","tags":"","loc":"sourcefile/matmul_m.f90.html"},{"title":"inference_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_strategy_m.f90~~EfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_strategy_m.f90~~AfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~read-and-query.f90 read-and-query.f90 sourcefile~read-and-query.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_strategy_m Source Code inference_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_strategy_m use activation_strategy_m , only : activation_strategy_t implicit none private public :: inference_strategy_t type , abstract :: inference_strategy_t contains procedure ( infer_interface ), nopass , deferred :: infer end type abstract interface pure function infer_interface ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) import activation_strategy_t implicit none real , intent ( in ) :: input (:) real , intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real , intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real , intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs real , intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real , intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer class ( activation_strategy_t ), intent ( in ) :: activation_strategy real , allocatable :: output (:) end function end interface end module inference_strategy_m","tags":"","loc":"sourcefile/inference_strategy_m.f90.html"},{"title":"matmul_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_s.f90~~EfferentGraph sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules matmul_s Source Code matmul_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matmul_m ) matmul_s implicit none contains module procedure infer real , allocatable :: neuron (:,:) associate ( num_layers => size ( biases , 2 )) associate ( neurons_per_layer => size ( input_weights , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) end associate block integer , parameter :: input_layer = 1 neuron (:, input_layer ) = & activation_strategy % activation ( matmul ( transpose ( input_weights (:,:)), input (:)) + biases (:, input_layer )) end block block integer layer do layer = 2 , num_layers neuron (:, layer ) = & activation_strategy % activation ( matmul ( transpose ( hidden_weights (:,:, layer - 1 )), neuron (:, layer - 1 )) + biases (:, layer )) end do end block output = activation_strategy % activation ( matmul ( output_weights (:,:), neuron (:, num_layers )) + output_biases (:)) end associate end procedure end submodule matmul_s","tags":"","loc":"sourcefile/matmul_s.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation end type interface elemental module function activation ( x ) result ( y ) implicit none real , intent ( in ) :: x real y end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~read-and-query.f90 read-and-query.f90 sourcefile~read-and-query.f90->sourcefile~inference_engine_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m implicit none private public :: activation_strategy_t type , abstract :: activation_strategy_t contains procedure ( activation_interface ), nopass , deferred :: activation end type abstract interface elemental function activation_interface ( x ) result ( y ) implicit none real , intent ( in ) :: x real y end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"concurrent_dot_products_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_s.f90~~EfferentGraph sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules concurrent_dot_products_s Source Code concurrent_dot_products_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( concurrent_dot_products_m ) concurrent_dot_products_s use assert_m , only : assert use activation_strategy_m , only : activation_strategy_t use step_m , only : step_t implicit none contains module procedure infer integer n , layer , m integer , parameter :: input_layer = 1 real , allocatable :: neuron (:,:) associate ( neurons_per_layer => size ( input_weights , 2 ), num_layers => size ( biases , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) do concurrent ( n = 1 : neurons_per_layer ) neuron ( n , input_layer ) = activation_strategy % activation ( dot_product ( input_weights (:, n ), input (:)) + biases ( n , input_layer )) end do do layer = 2 , num_layers do concurrent ( n = 1 : neurons_per_layer ) neuron ( n , layer ) = & activation_strategy % activation ( dot_product ( hidden_weights (:, n , layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer )) end do end do associate ( num_outputs => size ( output_weights , 1 )) allocate ( output ( num_outputs )) do concurrent ( m = 1 : num_outputs ) output ( m ) = activation_strategy % activation ( dot_product ( output_weights ( m ,:), neuron (:, num_layers )) + output_biases ( m )) end do end associate end associate end procedure end submodule concurrent_dot_products_s","tags":"","loc":"sourcefile/concurrent_dot_products_s.f90.html"},{"title":"read-and-query.f90 – Inference-Engine","text":"This file depends on sourcefile~~read-and-query.f90~~EfferentGraph sourcefile~read-and-query.f90 read-and-query.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read-and-query.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs read_and_query Source Code read-and-query.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_and_query !! This program demonstrates how to read a neural network from a file into an !! inference_engine_t object and then query the resulting object for its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t implicit none type ( inference_engine_t ) inference_engine type ( command_line_t ) command_line character ( len = :), allocatable :: input_file_name input_file_name = command_line % flag_value ( \"--input-file\" ) if ( len ( input_file_name ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example read-and-query -- --input-file \"<file-name>\"' end if print * , \"Defining an inference_engine_t object by reading the file '\" // input_file_name // \"'\" call inference_engine % read_network ( string_t ( input_file_name )) print * , \"num_inputs = \" , inference_engine % num_inputs () print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () end program","tags":"","loc":"sourcefile/read-and-query.f90.html"},{"title":"concurrent-inference.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent-inference.f90~~EfferentGraph sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs concurrent_inferences Source Code concurrent-inference.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program concurrent_inferences !! This program demonstrates how to read multiple neural networks, each from a !! separate file, into an array of inference_engine_t objects and then perform !! inference concurrently using the resulting inference_engine_t array. use string_m , only : string_t , array_of_strings use inference_engine_m , only : inference_engine_t use command_line_m , only : command_line_t implicit none logical , allocatable :: test_passes (:) type ( inference_engine_t ), allocatable :: inference_engine (:) type ( command_line_t ) command_line type ( string_t ), allocatable :: file_names (:) character ( len = :), allocatable :: input_files real , allocatable :: truth_table (:) real , parameter :: tolerance = 1.E-08 , false = 0. , true = 1. real , parameter :: input_array ( * , * ) = reshape ([ true , true , false , true , true , false , false , false ], shape = [ 2 , 4 ]) real , parameter :: expected_result ( * ) = [ false , true , true , false ] integer i input_files = command_line % flag_value ( \"--input-files\" ) if ( len ( input_files ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example concurrent-inference -- --input-files \"<space-delimited-list-of-files>\"' end if print * , \"Defining an array of inference_engine_t objects by reading the following files: \" , input_files file_names = array_of_strings ( input_files , delimiter = \" \" ) associate ( num_engines => size ( file_names )) allocate ( inference_engine ( num_engines )) do i = 1 , num_engines call inference_engine ( i )% read_network ( file_names ( i )) end do allocate ( truth_table ( num_engines )) do concurrent ( i = 1 : num_engines ) associate ( inference => inference_engine ( i )% infer ( input_array (:, i ))) truth_table ( i ) = inference ( 1 ) end associate end do associate ( test_passed => abs ( truth_table - expected_result ) < tolerance ) print * , test_passed end associate end associate end program","tags":"","loc":"sourcefile/concurrent-inference.f90.html"},{"title":"netCDF_IO.f90 – Inference-Engine","text":"Contents Programs netCDF_IO Source Code netCDF_IO.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"sourcefile/netcdf_io.f90.html"},{"title":"construct-and-write.f90 – Inference-Engine","text":"This file depends on sourcefile~~construct-and-write.f90~~EfferentGraph sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs construct_and_write Source Code construct-and-write.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program construct_and_write !! This program demonstrates how to construct a neural network from arrays of weights and biases !! and how to write the resulting object to a file in the format that is readable by the !! inference_engine_t read_network type-bound procedure. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t implicit none type ( inference_engine_t ) xor type ( command_line_t ) command_line character ( len = :), allocatable :: output_file_name integer i , j integer , parameter :: identity ( * , * , * ) = reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , 3 ), j = 1 , 3 )], shape = [ 3 , 3 , 1 ]) output_file_name = command_line % flag_value ( \"--output-file\" ) if ( len ( output_file_name ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example construct-and-write -- --output-file \"<file-name>\"' end if xor = inference_engine_t ( & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ 2 , 3 ])), & hidden_weights = real ( identity ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ 1 , 3 ])), & biases = reshape ([ 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ 3 , 2 ]), & output_biases = [ 0. ] & ) print * , \"Writing an inference_engine_t object to the file '\" // output_file_name // \"'\" call xor % write_network ( string_t ( output_file_name )) end program","tags":"","loc":"sourcefile/construct-and-write.f90.html"}]}