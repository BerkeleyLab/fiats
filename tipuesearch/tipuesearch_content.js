var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine supports research in concurrent, large-batch inference and training of deep, feed-forward neural networks. Inference-Engine targets high-performance computing (HPC) applications with performance-critical inference and training needs.  The initial target application is in situ training of a cloud microphysics model proxy for the Intermediate Complexity Atmospheric Research ( ICAR ) model.  Such a proxy must support concurrent inference at every grid point at every time step of an ICAR run.  For validation purposes, Inference-Engine also supports the export and import of neural networks to and from Python by the companion package nexport . The features of Inference-Engine that make it suitable for use in HPC applications include Implementation in Fortran 2018. Exposing concurrency via Elemental , implicitly pure inference procedures, An elemental and implicitly pure activation strategy, and A pure training subroutine, Gathering network weights and biases into contiguous arrays for efficient memory access patterns, and User-controlled mini-batch size facilitating in situ training at application runtime. Making Inference-Engine's infer functions and train subroutines pure facilitates invoking those procedures inside Fortran do concurrent constructs, which some compilers can offload automatically to graphics processing units (GPUs).  The use of contiguous arrays facilitates spatial locality in memory access patterns.  User control of mini-batch size facilitates in-situ training at application runtime. The available optimizers for training neural networks are\n1. Stochastic gradient descent\n2. Adam (recommended) Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the codes in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Configuring a Training Run To see the format for a JSON configuration file that defines the hyperparameters and a new network configuration for a training run, execute the provided training-configuration output example program: % ./build/run-fpm.sh run --example print-training-configuration Project is up to date { \"hyperparameters\" : { \"mini-batches\" : 10 , \"learning rate\" : 1.50000000 , \"optimizer\" : \"adam\" } , \"network configuration\" : { \"skip connections\" : false , \"nodes per layer\" : [ 2 , 72 , 2 ], \"activation function\" : \"sigmoid\" } } As of this writing, the JSON file format is fragile.  Because an Intel ifx compiler bug prevents using our preferred JSON interface, rojff , Inference-Engine currently use a very restricted but valid JSON subset that can be read and written by type-bound procedures on the string_t type in the sourcery utility.  For this to work, it is important to keep input files as close as possible to the exact form shown above.  In particular, do not split, combine or otherwise significantly rearrange lines in the above format other than adding or removing whitespace if so desired. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"input_output_pair_t – Inference-Engine ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables expected_outputs_ inputs_ Constructor input_output_pair_t Type-Bound Procedures expected_outputs inputs Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) Type-Bound Procedures procedure, public :: expected_outputs interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, public :: inputs interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"type/input_output_pair_t.html"},{"title":"mini_batch_t – Inference-Engine ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_output_pairs_ Constructor mini_batch_t Type-Bound Procedures input_output_pairs Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) Type-Bound Procedures procedure, public :: input_output_pairs interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"type/mini_batch_t.html"},{"title":"hyperparameters_t – Inference-Engine ","text":"type, public :: hyperparameters_t Inherited by type~~hyperparameters_t~~InheritedByGraph type~hyperparameters_t hyperparameters_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables learning_rate_ mini_batches_ optimizer_ Constructor hyperparameters_t Type-Bound Procedures equals learning_rate mini_batches operator(==) optimizer_name to_json Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor public interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Type-Bound Procedures procedure, public :: equals interface private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer generic, public :: operator(==) => equals private interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) procedure, public :: to_json interface private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"type/hyperparameters_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~exchange_t exchange_t type~exchange_t->type~activation_strategy_t activation_strategy_ type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~step_t step_t type~step_t->type~activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"difference_t – Inference-Engine ","text":"type, public :: difference_t Contents Variables biases_difference_ nodes_difference_ weights_difference_ Type-Bound Procedures norm Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"type/difference_t.html"},{"title":"exchange_t – Inference-Engine ","text":"type, public :: exchange_t Inherits type~~exchange_t~~InheritsGraph type~exchange_t exchange_t string_t string_t type~exchange_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~exchange_t->type~activation_strategy_t activation_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ metadata_ nodes_ weights_ Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:)","tags":"","loc":"type/exchange_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ metadata_ nodes_ weights_ Constructor inference_engine_t Type-Bound Procedures activation_function_name assert_conformable_with infer nodes_per_layer num_inputs num_outputs operator(-) skip to_exchange to_json subtract Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor public interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine procedure, public :: infer interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: nodes_per_layer interface private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: skip interface private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_exchange interface private pure module module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) procedure, public :: to_json interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"network_configuration_t – Inference-Engine ","text":"type, public :: network_configuration_t Inherited by type~~network_configuration_t~~InheritedByGraph type~network_configuration_t network_configuration_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name_ nodes_per_layer_ skip_connections_ Constructor network_configuration_t Type-Bound Procedures activation_name equals nodes_per_layer operator(==) skip_connections to_json Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor public interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Type-Bound Procedures procedure, public :: activation_name interface private elemental module module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: equals interface private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: nodes_per_layer interface private pure module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) generic, public :: operator(==) => equals private interface equals () Arguments None procedure, public :: skip_connections interface private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"type/network_configuration_t.html"},{"title":"NetCDF_file_t – Inference-Engine ","text":"type, public :: NetCDF_file_t Contents Variables file_name_ Constructor NetCDF_file_t Type-Bound Procedures input input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_name_ Constructor public interface NetCDF_file_t private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t ) Type-Bound Procedures generic, public :: input => input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar private interface input_2D_integer () Arguments None private interface input_1D_double () Arguments None private interface input_4D_real () Arguments None private interface input_3D_real () Arguments None private interface input_real_scalar () Arguments None procedure, public :: input_1D_double interface private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) procedure, public :: input_2D_integer interface private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) procedure, public :: input_3D_real interface private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) procedure, public :: input_4D_real interface private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) procedure, public :: input_real_scalar interface private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"type/netcdf_file_t.html"},{"title":"trainable_engine_t – Inference-Engine ","text":"type, public :: trainable_engine_t Encapsulate the information needed to perform training Inherits type~~trainable_engine_t~~InheritsGraph type~trainable_engine_t trainable_engine_t string_t string_t type~trainable_engine_t->string_t metadata_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables b differentiable_activation_strategy_ metadata_ n w Constructor trainable_engine_t Type-Bound Procedures assert_consistent infer num_inputs num_layers num_outputs to_inference_engine train Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor public interface trainable_engine_t private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) Type-Bound Procedures procedure, public :: assert_consistent interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self procedure, public :: infer interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_layers interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: to_inference_engine interface private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) procedure, public :: train interface private pure module module subroutine train(self, mini_batches, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"type/trainable_engine_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/step_t.html"},{"title":"relu_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: relu_t Inherits type~~relu_t~~InheritsGraph type~relu_t relu_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~relu_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/relu_t.html"},{"title":"training_configuration_t – Inference-Engine ","text":"type, public, extends(file_t) :: training_configuration_t Inherits type~~training_configuration_t~~InheritsGraph type~training_configuration_t training_configuration_t type~hyperparameters_t hyperparameters_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ file_t file_t type~training_configuration_t->file_t type~network_configuration_t network_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables hyperparameters_ network_configuration_ Constructor training_configuration_t Type-Bound Procedures differentiable_activation_strategy equals learning_rate mini_batches nodes_per_layer operator(==) optimizer_name skip_connections to_json Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor public interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Type-Bound Procedures procedure, public :: differentiable_activation_strategy interface private module module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable procedure, public :: equals interface private elemental module module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer procedure, public :: nodes_per_layer interface private module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) generic, public :: operator(==) => equals private interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: skip_connections interface private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"type/training_configuration_t.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/sigmoid_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables neuron next Constructor layer_t Type-Bound Procedures count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target Type-Bound Procedures procedure, public :: count_inputs interface private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer procedure, public :: count_layers interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) procedure, public :: inference_engine interface private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) procedure, public :: neurons_per_layer interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"type/layer_t.html"},{"title":"tensor_t – Inference-Engine ","text":"type, public :: tensor_t Inherited by type~~tensor_t~~InheritedByGraph type~tensor_t tensor_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables num_components values values_ Constructor tensor_t Components Type Visibility Attributes Name Initial procedure, public :: num_components procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor public interface tensor_t private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"type/tensor_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/swish_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bias_ next weights_ Constructor neuron_t Type-Bound Procedures bias next_allocated next_pointer num_inputs weights Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer procedure, public :: num_inputs interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"activation_i – Inference-Engine","text":"abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"function_name_i – Inference-Engine","text":"abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name_i.html"},{"title":"input_output_pair_t – Inference-Engine","text":"public interface input_output_pair_t Contents Functions construct Functions private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"shuffle – Inference-Engine","text":"interface Calls interface~~shuffle~~CallsGraph interface~shuffle shuffle proc~shuffle shuffle interface~shuffle->proc~shuffle assert assert proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~shuffle~~CalledByGraph interface~shuffle shuffle program~train_polynomials train_polynomials program~train_polynomials->interface~shuffle program~train_and_write train_and_write program~train_and_write->interface~shuffle program~train_polynomials~4 train_polynomials program~train_polynomials~4->interface~shuffle program~train_polynomials~3 train_polynomials program~train_polynomials~3->interface~shuffle program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->interface~shuffle program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->interface~shuffle program~train_polynomials~2 train_polynomials program~train_polynomials~2->interface~shuffle program~train_polynomials~5 train_polynomials program~train_polynomials~5->interface~shuffle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public pure module module subroutine shuffle(pairs, random_numbers) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) real, intent(in) :: random_numbers (2:)","tags":"","loc":"interface/shuffle.html"},{"title":"expected_outputs – Inference-Engine","text":"interface Calls interface~~expected_outputs~~CallsGraph interface~expected_outputs expected_outputs proc~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"interface Calls interface~~inputs~~CallsGraph interface~inputs inputs proc~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/inputs.html"},{"title":"mini_batch_t – Inference-Engine","text":"public interface mini_batch_t Contents Functions construct Functions private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"interface/mini_batch_t.html"},{"title":"input_output_pairs – Inference-Engine","text":"interface Calls interface~~input_output_pairs~~CallsGraph interface~input_output_pairs input_output_pairs proc~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/input_output_pairs.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"hyperparameters_t – Inference-Engine","text":"public interface hyperparameters_t Contents Functions from_components from_json Functions private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t )","tags":"","loc":"interface/hyperparameters_t.html"},{"title":"equals – Inference-Engine","text":"interface Calls interface~~equals~~CallsGraph interface~equals equals proc~equals equals interface~equals->proc~equals assert assert proc~equals->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals.html"},{"title":"learning_rate – Inference-Engine","text":"interface Calls interface~~learning_rate~~CallsGraph interface~learning_rate learning_rate proc~learning_rate learning_rate interface~learning_rate->proc~learning_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"interface Calls interface~~mini_batches~~CallsGraph interface~mini_batches mini_batches proc~mini_batches mini_batches interface~mini_batches->proc~mini_batches Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches.html"},{"title":"optimizer_name – Inference-Engine","text":"interface Calls interface~~optimizer_name~~CallsGraph interface~optimizer_name optimizer_name proc~optimizer_name optimizer_name interface~optimizer_name->proc~optimizer_name string_t string_t proc~optimizer_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~~CallsGraph interface~to_json to_json proc~to_json to_json interface~to_json->proc~to_json string_t string_t proc~to_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct_from_json construct_from_padded_arrays Functions private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Calls interface~~activation_function_name~~CallsGraph interface~activation_function_name activation_function_name proc~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface Calls interface~~assert_conformable_with~~CallsGraph interface~assert_conformable_with assert_conformable_with proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~assert_consistency assert_consistency proc~assert_conformable_with->interface~assert_consistency assert assert proc~assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer interface~assert_consistency assert_consistency proc~infer->interface~assert_consistency n n proc~infer->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Calls interface~~nodes_per_layer~~CallsGraph interface~nodes_per_layer nodes_per_layer proc~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~assert_consistency assert_consistency proc~nodes_per_layer->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~assert_consistency assert_consistency proc~num_inputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~assert_consistency assert_consistency proc~num_outputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"skip – Inference-Engine","text":"interface Calls interface~~skip~~CallsGraph interface~skip skip proc~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract interface~assert_consistency assert_consistency proc~subtract->interface~assert_consistency n n proc~subtract->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_exchange – Inference-Engine","text":"interface Calls interface~~to_exchange~~CallsGraph interface~to_exchange to_exchange proc~to_exchange to_exchange interface~to_exchange->proc~to_exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t )","tags":"","loc":"interface/to_exchange.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~2~~CallsGraph interface~to_json~2 to_json proc~to_json~2 to_json interface~to_json~2->proc~to_json~2 separated_values separated_values proc~to_json~2->separated_values file_t file_t proc~to_json~2->file_t assert assert proc~to_json~2->assert n n proc~to_json~2->n interface~assert_consistency assert_consistency proc~to_json~2->interface~assert_consistency string_t string_t proc~to_json~2->string_t hidden_layer_weights hidden_layer_weights proc~to_json~2->hidden_layer_weights intrinsic_array_t intrinsic_array_t proc~to_json~2->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json~2.html"},{"title":"network_configuration_t – Inference-Engine","text":"public interface network_configuration_t Contents Functions from_components from_json Functions private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t )","tags":"","loc":"interface/network_configuration_t.html"},{"title":"activation_name – Inference-Engine","text":"interface Calls interface~~activation_name~~CallsGraph interface~activation_name activation_name proc~activation_name activation_name interface~activation_name->proc~activation_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_name.html"},{"title":"equals – Inference-Engine","text":"interface Calls interface~~equals~2~~CallsGraph interface~equals~2 equals proc~equals~2 equals interface~equals~2->proc~equals~2 assert assert proc~equals~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Calls interface~~nodes_per_layer~2~~CallsGraph interface~nodes_per_layer~2 nodes_per_layer proc~nodes_per_layer~2 nodes_per_layer interface~nodes_per_layer~2->proc~nodes_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~2.html"},{"title":"skip_connections – Inference-Engine","text":"interface Calls interface~~skip_connections~~CallsGraph interface~skip_connections skip_connections proc~skip_connections skip_connections interface~skip_connections->proc~skip_connections Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~3~~CallsGraph interface~to_json~3 to_json proc~to_json~3 to_json interface~to_json~3->proc~to_json~3 string_t string_t proc~to_json~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~3.html"},{"title":"NetCDF_file_t – Inference-Engine","text":"public interface NetCDF_file_t Contents Functions construct Functions private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t )","tags":"","loc":"interface/netcdf_file_t.html"},{"title":"input_1D_double – Inference-Engine","text":"interface Calls interface~~input_1d_double~~CallsGraph interface~input_1d_double input_1D_double proc~input_1d_double input_1D_double interface~input_1d_double->proc~input_1d_double nf90_strerror nf90_strerror proc~input_1d_double->nf90_strerror assert assert proc~input_1d_double->assert intrinsic_array_t intrinsic_array_t proc~input_1d_double->intrinsic_array_t array_shape array_shape proc~input_1d_double->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:)","tags":"","loc":"interface/input_1d_double.html"},{"title":"input_2D_integer – Inference-Engine","text":"interface Calls interface~~input_2d_integer~~CallsGraph interface~input_2d_integer input_2D_integer proc~input_2d_integer input_2D_integer interface~input_2d_integer->proc~input_2d_integer nf90_strerror nf90_strerror proc~input_2d_integer->nf90_strerror assert assert proc~input_2d_integer->assert array_shape array_shape proc~input_2d_integer->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:)","tags":"","loc":"interface/input_2d_integer.html"},{"title":"input_3D_real – Inference-Engine","text":"interface Calls interface~~input_3d_real~~CallsGraph interface~input_3d_real input_3D_real proc~input_3d_real input_3D_real interface~input_3d_real->proc~input_3d_real nf90_strerror nf90_strerror proc~input_3d_real->nf90_strerror assert assert proc~input_3d_real->assert intrinsic_array_t intrinsic_array_t proc~input_3d_real->intrinsic_array_t array_shape array_shape proc~input_3d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:)","tags":"","loc":"interface/input_3d_real.html"},{"title":"input_4D_real – Inference-Engine","text":"interface Calls interface~~input_4d_real~~CallsGraph interface~input_4d_real input_4D_real proc~input_4d_real input_4D_real interface~input_4d_real->proc~input_4d_real nf90_strerror nf90_strerror proc~input_4d_real->nf90_strerror assert assert proc~input_4d_real->assert intrinsic_array_t intrinsic_array_t proc~input_4d_real->intrinsic_array_t array_shape array_shape proc~input_4d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:)","tags":"","loc":"interface/input_4d_real.html"},{"title":"input_real_scalar – Inference-Engine","text":"interface Calls interface~~input_real_scalar~~CallsGraph interface~input_real_scalar input_real_scalar proc~input_real_scalar input_real_scalar interface~input_real_scalar->proc~input_real_scalar nf90_strerror nf90_strerror proc~input_real_scalar->nf90_strerror assert assert proc~input_real_scalar->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"interface/input_real_scalar.html"},{"title":"trainable_engine_t – Inference-Engine","text":"public interface trainable_engine_t Contents Functions construct_from_inference_engine construct_from_padded_arrays Functions private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t )","tags":"","loc":"interface/trainable_engine_t.html"},{"title":"assert_consistent – Inference-Engine","text":"interface Calls interface~~assert_consistent~~CallsGraph interface~assert_consistent assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t assert assert proc~assert_consistent->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 n n proc~infer~2->n b b proc~infer~2->b w w proc~infer~2->w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer~2.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~2~~CallsGraph interface~num_inputs~2 num_inputs proc~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"interface Calls interface~~num_layers~~CallsGraph interface~num_layers num_layers proc~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_layers.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~2~~CallsGraph interface~num_outputs~2 num_outputs proc~num_outputs~2 num_outputs interface~num_outputs~2->proc~num_outputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs~2.html"},{"title":"to_inference_engine – Inference-Engine","text":"interface Calls interface~~to_inference_engine~~CallsGraph interface~to_inference_engine to_inference_engine proc~to_inference_engine to_inference_engine interface~to_inference_engine->proc~to_inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t )","tags":"","loc":"interface/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"interface Calls interface~~train~~CallsGraph interface~train train proc~train train interface~train->proc~train b b proc~train->b beta beta proc~train->beta y y proc~train->y n n proc~train->n w w proc~train->w obeta obeta proc~train->obeta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine train(self, mini_batches, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"interface/train.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~~CallsGraph interface~function_name function_name proc~function_name function_name interface~function_name->proc~function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~2~~CallsGraph interface~activation~2 activation proc~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~~CallsGraph interface~activation_derivative activation_derivative proc~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~2~~CallsGraph interface~function_name~2 function_name proc~function_name~2 function_name interface~function_name~2->proc~function_name~2 string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~2.html"},{"title":"training_configuration_t – Inference-Engine","text":"public interface training_configuration_t Contents Functions from_components from_file Functions private module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t )","tags":"","loc":"interface/training_configuration_t.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"interface Calls interface~~differentiable_activation_strategy~~CallsGraph interface~differentiable_activation_strategy differentiable_activation_strategy proc~differentiable_activation_strategy differentiable_activation_strategy interface~differentiable_activation_strategy->proc~differentiable_activation_strategy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable","tags":"","loc":"interface/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"interface Calls interface~~equals~3~~CallsGraph interface~equals~3 equals proc~equals~3 equals interface~equals~3->proc~equals~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~3.html"},{"title":"learning_rate – Inference-Engine","text":"interface Calls interface~~learning_rate~2~~CallsGraph interface~learning_rate~2 learning_rate proc~learning_rate~2 learning_rate interface~learning_rate~2->proc~learning_rate~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"interface Calls interface~~mini_batches~2~~CallsGraph interface~mini_batches~2 mini_batches proc~mini_batches~2 mini_batches interface~mini_batches~2->proc~mini_batches~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Calls interface~~nodes_per_layer~3~~CallsGraph interface~nodes_per_layer~3 nodes_per_layer proc~nodes_per_layer~3 nodes_per_layer interface~nodes_per_layer~3->proc~nodes_per_layer~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~3.html"},{"title":"optimizer_name – Inference-Engine","text":"interface Calls interface~~optimizer_name~2~~CallsGraph interface~optimizer_name~2 optimizer_name proc~optimizer_name~2 optimizer_name interface~optimizer_name~2->proc~optimizer_name~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name~2.html"},{"title":"skip_connections – Inference-Engine","text":"interface Calls interface~~skip_connections~2~~CallsGraph interface~skip_connections~2 skip_connections proc~skip_connections~2 skip_connections interface~skip_connections~2->proc~skip_connections~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~4~~CallsGraph interface~to_json~4 to_json proc~to_json~4 to_json interface~to_json~4->proc~to_json~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~4.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~3~~CallsGraph interface~activation~3 activation proc~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~2~~CallsGraph interface~activation_derivative~2 activation_derivative proc~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~3~~CallsGraph interface~function_name~3 function_name proc~function_name~3 function_name interface~function_name~3->proc~function_name~3 string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~3.html"},{"title":"set_activation_strategy – Inference-Engine","text":"pure subroutine set_activation_strategy(inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Called by proc~~set_activation_strategy~~CalledByGraph proc~set_activation_strategy set_activation_strategy proc~construct_from_json construct_from_json proc~construct_from_json->proc~set_activation_strategy proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->proc~set_activation_strategy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_activation_strategy.html"},{"title":"assert_consistency – Inference-Engine","text":"private interface assert_consistency Calls interface~~assert_consistency~~CallsGraph interface~assert_consistency assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~assert_consistency~~CalledByGraph interface~assert_consistency assert_consistency proc~infer infer proc~infer->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~to_json~2 to_json proc~to_json~2->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency interface~infer infer interface~infer->proc~infer interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json~2 to_json interface~to_json~2->proc~to_json~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures inference_engine_consistency difference_consistency Module Procedures pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistency.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Contents Functions construct Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target","tags":"","loc":"interface/layer_t.html"},{"title":"count_inputs – Inference-Engine","text":"interface Calls interface~~count_inputs~~CallsGraph interface~count_inputs count_inputs proc~count_inputs count_inputs interface~count_inputs->proc~count_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer","tags":"","loc":"interface/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"interface Calls interface~~count_layers~~CallsGraph interface~count_layers count_layers proc~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Calls interface~~count_neurons~~CallsGraph interface~count_neurons count_neurons proc~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"interface Calls interface~~inference_engine~~CallsGraph interface~inference_engine inference_engine proc~inference_engine inference_engine interface~inference_engine->proc~inference_engine assert assert proc~inference_engine->assert biases biases proc~inference_engine->biases weights weights proc~inference_engine->weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~~CallsGraph interface~next_allocated next_allocated proc~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~~CallsGraph interface~next_pointer next_pointer proc~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"tensor_t – Inference-Engine","text":"public interface tensor_t Contents Functions construct_from_components Functions private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"interface/tensor_t.html"},{"title":"num_components – Inference-Engine","text":"interface Calls interface~~num_components~~CallsGraph interface~num_components num_components proc~num_components num_components interface~num_components->proc~num_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_components.html"},{"title":"values – Inference-Engine","text":"interface Calls interface~~values~~CallsGraph interface~values values proc~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/values.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~4~~CallsGraph interface~activation~4 activation proc~activation~4 activation interface~activation~4->proc~activation~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~4.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~3~~CallsGraph interface~activation_derivative~3 activation_derivative proc~activation_derivative~3 activation_derivative interface~activation_derivative~3->proc~activation_derivative~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~4~~CallsGraph interface~function_name~4 function_name proc~function_name~4 function_name interface~function_name~4->proc~function_name~4 string_t string_t proc~function_name~4->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~4.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Contents Functions construct Functions private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface Calls interface~~bias~~CallsGraph interface~bias bias proc~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~2~~CallsGraph interface~next_allocated~2 next_allocated proc~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~2~~CallsGraph interface~next_pointer~2 next_pointer proc~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~3~~CallsGraph interface~num_inputs~3 num_inputs proc~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~3.html"},{"title":"weights – Inference-Engine","text":"interface Calls interface~~weights~~CallsGraph interface~weights weights proc~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~~CallsGraph proc~y y assert assert proc~y->assert x x proc~y->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~~CalledByGraph proc~y y program~train_polynomials train_polynomials program~train_polynomials->proc~y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~~CalledByGraph proc~e e proc~perturbed_identity_network perturbed_identity_network proc~perturbed_identity_network->proc~e program~train_polynomials train_polynomials program~train_polynomials->proc~perturbed_identity_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~~CallsGraph proc~perturbed_identity_network perturbed_identity_network proc~e e proc~perturbed_identity_network->proc~e string_t string_t proc~perturbed_identity_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~~CalledByGraph proc~perturbed_identity_network perturbed_identity_network program~train_polynomials train_polynomials program~train_polynomials->proc~perturbed_identity_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~~CalledByGraph proc~output output program~train_polynomials train_polynomials program~train_polynomials->proc~output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~2~~CalledByGraph proc~e~2 e proc~perturbed_identity_network~2 perturbed_identity_network proc~perturbed_identity_network~2->proc~e~2 program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~2.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~2~~CallsGraph proc~perturbed_identity_network~2 perturbed_identity_network proc~e~2 e proc~perturbed_identity_network~2->proc~e~2 string_t string_t proc~perturbed_identity_network~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~2~~CalledByGraph proc~perturbed_identity_network~2 perturbed_identity_network program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~2.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~~CallsGraph proc~open_plot_file_for_appending open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending->file_t string_t string_t proc~open_plot_file_for_appending->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_plot_file_for_appending~~CalledByGraph proc~open_plot_file_for_appending open_plot_file_for_appending program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~open_plot_file_for_appending Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/open_plot_file_for_appending.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~2~~CalledByGraph proc~output~2 output program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~output~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~2.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~~CalledByGraph proc~print_diagnostics print_diagnostics program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~print_diagnostics Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/print_diagnostics.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~3~~CalledByGraph proc~e~3 e proc~perturbed_identity_network~3 perturbed_identity_network proc~perturbed_identity_network~3->proc~e~3 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~3.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~3~~CallsGraph proc~perturbed_identity_network~3 perturbed_identity_network proc~e~3 e proc~perturbed_identity_network~3->proc~e~3 string_t string_t proc~perturbed_identity_network~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~3~~CalledByGraph proc~perturbed_identity_network~3 perturbed_identity_network program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~3.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~2~~CallsGraph proc~open_plot_file_for_appending~2 open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending~2->file_t string_t string_t proc~open_plot_file_for_appending~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_plot_file_for_appending~2~~CalledByGraph proc~open_plot_file_for_appending~2 open_plot_file_for_appending program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/open_plot_file_for_appending~2.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~3~~CalledByGraph proc~output~3 output program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~3.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~2~~CalledByGraph proc~print_diagnostics~2 print_diagnostics program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~print_diagnostics~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/print_diagnostics~2.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~2~~CallsGraph proc~y~2 y assert assert proc~y~2->assert x x proc~y~2->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~2~~CalledByGraph proc~y~2 y program~train_polynomials~2 train_polynomials program~train_polynomials~2->proc~y~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~2.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~4~~CalledByGraph proc~e~4 e proc~perturbed_identity_network~4 perturbed_identity_network proc~perturbed_identity_network~4->proc~e~4 program~train_polynomials~2 train_polynomials program~train_polynomials~2->proc~perturbed_identity_network~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~4.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~4~~CallsGraph proc~perturbed_identity_network~4 perturbed_identity_network proc~e~4 e proc~perturbed_identity_network~4->proc~e~4 string_t string_t proc~perturbed_identity_network~4->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~4~~CalledByGraph proc~perturbed_identity_network~4 perturbed_identity_network program~train_polynomials~2 train_polynomials program~train_polynomials~2->proc~perturbed_identity_network~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~4.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~4~~CalledByGraph proc~output~4 output program~train_polynomials~2 train_polynomials program~train_polynomials~2->proc~output~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~4.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~5~~CallsGraph proc~perturbed_identity_network~5 perturbed_identity_network string_t string_t proc~perturbed_identity_network~5->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~5~~CalledByGraph proc~perturbed_identity_network~5 perturbed_identity_network program~train_and_write train_and_write program~train_and_write->proc~perturbed_identity_network~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~5.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~5~~CalledByGraph proc~output~5 output program~train_and_write train_and_write program~train_and_write->proc~output~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~5.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~5~~CalledByGraph proc~e~5 e proc~perturbed_identity_network~6 perturbed_identity_network proc~perturbed_identity_network~6->proc~e~5 program~train_polynomials~3 train_polynomials program~train_polynomials~3->proc~perturbed_identity_network~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~5.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~6~~CallsGraph proc~perturbed_identity_network~6 perturbed_identity_network proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 string_t string_t proc~perturbed_identity_network~6->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~6~~CalledByGraph proc~perturbed_identity_network~6 perturbed_identity_network program~train_polynomials~3 train_polynomials program~train_polynomials~3->proc~perturbed_identity_network~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~6.html"},{"title":"y – Inference-Engine","text":"elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~3~~CallsGraph proc~y~3 y assert assert proc~y~3->assert x x proc~y~3->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~3~~CalledByGraph proc~y~3 y program~train_polynomials~3 train_polynomials program~train_polynomials~3->proc~y~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~3.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~6~~CalledByGraph proc~output~6 output program~train_polynomials~3 train_polynomials program~train_polynomials~3->proc~output~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~6.html"},{"title":"identity_network – Inference-Engine","text":"function identity_network() result(inference_engine) Arguments None Return Value type( inference_engine_t ) Calls proc~~identity_network~~CallsGraph proc~identity_network identity_network string_t string_t proc~identity_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~identity_network~~CalledByGraph proc~identity_network identity_network proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->proc~identity_network program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/identity_network.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network file_t file_t proc~write_read_query_infer->file_t string_t string_t proc~identity_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_query_infer Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~4~~CallsGraph proc~y~4 y assert assert proc~y~4->assert x x proc~y~4->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~4~~CalledByGraph proc~y~4 y program~train_polynomials~4 train_polynomials program~train_polynomials~4->proc~y~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~4.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~6~~CalledByGraph proc~e~6 e proc~perturbed_identity_network~7 perturbed_identity_network proc~perturbed_identity_network~7->proc~e~6 program~train_polynomials~4 train_polynomials program~train_polynomials~4->proc~perturbed_identity_network~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~6.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~7~~CallsGraph proc~perturbed_identity_network~7 perturbed_identity_network proc~e~6 e proc~perturbed_identity_network~7->proc~e~6 string_t string_t proc~perturbed_identity_network~7->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~7~~CalledByGraph proc~perturbed_identity_network~7 perturbed_identity_network program~train_polynomials~4 train_polynomials program~train_polynomials~4->proc~perturbed_identity_network~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~7.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~7~~CalledByGraph proc~output~7 output program~train_polynomials~4 train_polynomials program~train_polynomials~4->proc~output~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~7.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~5~~CallsGraph proc~y~5 y assert assert proc~y~5->assert x x proc~y~5->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~5~~CalledByGraph proc~y~5 y program~train_polynomials~5 train_polynomials program~train_polynomials~5->proc~y~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~5.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable,(:) Called by proc~~e~7~~CalledByGraph proc~e~7 e proc~perturbed_identity_network~8 perturbed_identity_network proc~perturbed_identity_network~8->proc~e~7 program~train_polynomials~5 train_polynomials program~train_polynomials~5->proc~perturbed_identity_network~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/e~7.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~8~~CallsGraph proc~perturbed_identity_network~8 perturbed_identity_network proc~e~7 e proc~perturbed_identity_network~8->proc~e~7 string_t string_t proc~perturbed_identity_network~8->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~perturbed_identity_network~8~~CalledByGraph proc~perturbed_identity_network~8 perturbed_identity_network program~train_polynomials~5 train_polynomials program~train_polynomials~5->proc~perturbed_identity_network~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/perturbed_identity_network~8.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Called by proc~~output~8~~CalledByGraph proc~output~8 output program~train_polynomials~5 train_polynomials program~train_polynomials~5->proc~output~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output~8.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~6~~CallsGraph proc~y~6 y assert assert proc~y~6->assert proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~6->proc~saturated_mixing_ratio x x proc~y~6->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~6~~CalledByGraph proc~y~6 y program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~6.html"},{"title":"saturated_mixing_ratio – Inference-Engine","text":"private pure function saturated_mixing_ratio(T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real Called by proc~~saturated_mixing_ratio~~CalledByGraph proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~6 y proc~y~6->proc~saturated_mixing_ratio program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/saturated_mixing_ratio.html"},{"title":"y – Inference-Engine","text":"public impure elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~7~~CallsGraph proc~y~7 y assert assert proc~y~7->assert proc~rsif RSIF proc~y~7->proc~rsif proc~rslf RSLF proc~y~7->proc~rslf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~y~7~~CalledByGraph proc~y~7 y program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/y~7.html"},{"title":"GAMMLN – Inference-Engine","text":"public function GAMMLN(XX) Arguments Type Intent Optional Attributes Name real, intent(in) :: XX Return Value real Called by proc~~gammln~~CalledByGraph proc~gammln GAMMLN proc~gser GSER proc~gser->proc~gammln proc~wgamma WGAMMA proc~wgamma->proc~gammln proc~gcf GCF proc~gcf->proc~gammln proc~gammp GAMMP proc~gammp->proc~gser proc~gammp->proc~gcf proc~qi_aut_qs qi_aut_qs proc~qi_aut_qs->proc~gammp proc~table_dropevap table_dropEvap proc~table_dropevap->proc~gammp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GAMMLN Source Code REAL FUNCTION GAMMLN ( XX ) !     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0. IMPLICIT NONE REAL , INTENT ( IN ) :: XX DOUBLE PRECISION , PARAMETER :: STP = 2.5066282746310005D0 DOUBLE PRECISION , DIMENSION ( 6 ), PARAMETER :: & COF = ( / 7 6.18009172947146D0 , - 8 6.50532032941677D0 , & 2 4.01409824083091D0 , - 1.231739572450155D0 , & . 1208650973866179 D - 2 , - . 5395239384953 D - 5 / ) DOUBLE PRECISION :: SER , TMP , X , Y INTEGER :: J X = XX Y = X TMP = X + 5.5D0 TMP = ( X + 0.5D0 ) * LOG ( TMP ) - TMP SER = 1.000000000190015D0 DO 11 J = 1 , 6 Y = Y + 1.D0 SER = SER + COF ( J ) / Y 11 CONTINUE GAMMLN = TMP + LOG ( STP * SER / X ) END FUNCTION GAMMLN","tags":"","loc":"proc/gammln.html"},{"title":"GAMMP – Inference-Engine","text":"public function GAMMP(A, X) Arguments Type Intent Optional Attributes Name real, intent(in) :: A real, intent(in) :: X Return Value real Calls proc~~gammp~~CallsGraph proc~gammp GAMMP proc~gser GSER proc~gammp->proc~gser proc~gcf GCF proc~gammp->proc~gcf proc~gammln GAMMLN proc~gser->proc~gammln proc~gcf->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gammp~~CalledByGraph proc~gammp GAMMP proc~qi_aut_qs qi_aut_qs proc~qi_aut_qs->proc~gammp proc~table_dropevap table_dropEvap proc~table_dropevap->proc~gammp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GAMMP Source Code REAL FUNCTION GAMMP ( A , X ) !     --- COMPUTES THE INCOMPLETE GAMMA FUNCTION P(A,X) !     --- SEE ABRAMOWITZ AND STEGUN 6.5.1 !     --- USES GCF,GSER IMPLICIT NONE REAL , INTENT ( IN ) :: A , X REAL :: GAMMCF , GAMSER , GLN GAMMP = 0. IF (( X . LT . 0. ) . OR . ( A . LE . 0. )) THEN PRINT * , 'BAD ARGUMENTS IN GAMMP' RETURN ELSEIF ( X . LT . A + 1. ) THEN CALL GSER ( GAMSER , A , X , GLN ) GAMMP = GAMSER ELSE CALL GCF ( GAMMCF , A , X , GLN ) GAMMP = 1. - GAMMCF ENDIF END FUNCTION GAMMP","tags":"","loc":"proc/gammp.html"},{"title":"RSIF – Inference-Engine","text":"public function RSIF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rsif~~CalledByGraph proc~rsif RSIF proc~y~7 y proc~y~7->proc~rsif proc~mp_thompson mp_thompson proc~mp_thompson->proc~rsif program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~7 proc~mp_gt_driver mp_gt_driver proc~mp_gt_driver->proc~mp_thompson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code RSIF Source Code REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF","tags":"","loc":"proc/rsif.html"},{"title":"RSLF – Inference-Engine","text":"public function RSLF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rslf~~CalledByGraph proc~rslf RSLF proc~y~7 y proc~y~7->proc~rslf proc~mp_thompson mp_thompson proc~mp_thompson->proc~rslf program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~7 proc~mp_gt_driver mp_gt_driver proc~mp_gt_driver->proc~mp_thompson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code RSLF Source Code REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF","tags":"","loc":"proc/rslf.html"},{"title":"WGAMMA – Inference-Engine","text":"public function WGAMMA(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: y Return Value real Calls proc~~wgamma~~CallsGraph proc~wgamma WGAMMA proc~gammln GAMMLN proc~wgamma->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WGAMMA Source Code REAL FUNCTION WGAMMA ( y ) IMPLICIT NONE REAL , INTENT ( IN ) :: y WGAMMA = EXP ( GAMMLN ( y )) END FUNCTION WGAMMA","tags":"","loc":"proc/wgamma.html"},{"title":"GCF – Inference-Engine","text":"public subroutine GCF(GAMMCF, A, X, GLN) Arguments Type Intent Optional Attributes Name real :: GAMMCF real, intent(in) :: A real, intent(in) :: X real :: GLN Calls proc~~gcf~~CallsGraph proc~gcf GCF proc~gammln GAMMLN proc~gcf->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gcf~~CalledByGraph proc~gcf GCF proc~gammp GAMMP proc~gammp->proc~gcf proc~qi_aut_qs qi_aut_qs proc~qi_aut_qs->proc~gammp proc~table_dropevap table_dropEvap proc~table_dropevap->proc~gammp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GCF Source Code SUBROUTINE GCF ( GAMMCF , A , X , GLN ) !     --- RETURNS THE INCOMPLETE GAMMA FUNCTION Q(A,X) EVALUATED BY ITS !     --- CONTINUED FRACTION REPRESENTATION AS GAMMCF.  ALSO RETURNS !     --- LN(GAMMA(A)) AS GLN.  THE CONTINUED FRACTION IS EVALUATED BY !     --- A MODIFIED LENTZ METHOD. !     --- USES GAMMLN IMPLICIT NONE INTEGER , PARAMETER :: ITMAX = 100 REAL , PARAMETER :: gEPS = 3.E-7 REAL , PARAMETER :: FPMIN = 1.E-30 REAL , INTENT ( IN ) :: A , X REAL :: GAMMCF , GLN INTEGER :: I REAL :: AN , B , C , D , DEL , H GLN = GAMMLN ( A ) B = X + 1. - A C = 1. / FPMIN D = 1. / B H = D DO 11 I = 1 , ITMAX AN =- I * ( I - A ) B = B + 2. D = AN * D + B IF ( ABS ( D ). LT . FPMIN ) D = FPMIN C = B + AN / C IF ( ABS ( C ). LT . FPMIN ) C = FPMIN D = 1. / D DEL = D * C H = H * DEL IF ( ABS ( DEL - 1. ). LT . gEPS ) GOTO 1 11 CONTINUE PRINT * , 'A TOO LARGE, ITMAX TOO SMALL IN GCF' 1 GAMMCF = EXP ( - X + A * LOG ( X ) - GLN ) * H END SUBROUTINE GCF","tags":"","loc":"proc/gcf.html"},{"title":"GSER – Inference-Engine","text":"public subroutine GSER(GAMSER, A, X, GLN) Arguments Type Intent Optional Attributes Name real :: GAMSER real, intent(in) :: A real, intent(in) :: X real :: GLN Calls proc~~gser~~CallsGraph proc~gser GSER proc~gammln GAMMLN proc~gser->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gser~~CalledByGraph proc~gser GSER proc~gammp GAMMP proc~gammp->proc~gser proc~qi_aut_qs qi_aut_qs proc~qi_aut_qs->proc~gammp proc~table_dropevap table_dropEvap proc~table_dropevap->proc~gammp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GSER Source Code SUBROUTINE GSER ( GAMSER , A , X , GLN ) !     --- RETURNS THE INCOMPLETE GAMMA FUNCTION P(A,X) EVALUATED BY ITS !     --- ITS SERIES REPRESENTATION AS GAMSER.  ALSO RETURNS LN(GAMMA(A)) !     --- AS GLN. !     --- USES GAMMLN IMPLICIT NONE INTEGER , PARAMETER :: ITMAX = 100 REAL , PARAMETER :: gEPS = 3.E-7 REAL , INTENT ( IN ) :: A , X REAL :: GAMSER , GLN INTEGER :: N REAL :: AP , DEL , SUM GLN = GAMMLN ( A ) IF ( X . LE . 0. ) THEN IF ( X . LT . 0. ) PRINT * , 'X < 0 IN GSER' GAMSER = 0. RETURN ENDIF AP = A SUM = 1. / A DEL = SUM DO 11 N = 1 , ITMAX AP = AP + 1. DEL = DEL * X / AP SUM = SUM + DEL IF ( ABS ( DEL ). LT . ABS ( SUM ) * gEPS ) GOTO 1 11 CONTINUE PRINT * , 'A TOO LARGE, ITMAX TOO SMALL IN GSER' 1 GAMSER = SUM * EXP ( - X + A * LOG ( X ) - GLN ) END SUBROUTINE GSER","tags":"","loc":"proc/gser.html"},{"title":"freezeH2O – Inference-Engine","text":"public subroutine freezeH2O() Arguments None Calls proc~~freezeh2o~~CallsGraph proc~freezeh2o freezeH2O dexp dexp proc~freezeh2o->dexp dfloat dfloat proc~freezeh2o->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code freezeH2O Source Code subroutine freezeH2O implicit none !..Local variables INTEGER :: i , j , k , n , n2 DOUBLE PRECISION , DIMENSION ( nbr ) :: N_r , massr DOUBLE PRECISION , DIMENSION ( nbc ) :: N_c , massc DOUBLE PRECISION :: sum1 , sum2 , sumn1 , sumn2 , & prob , vol , Texp , orho_w , & lam_exp , lamr , N0_r , lamc , N0_c , y LOGICAL lexist , lopen INTEGER :: good !   LOGICAL, EXTERNAL :: wrf_dm_on_monitor !+---+ good = 0 ! IF ( this_image() == 1 ) THEN INQUIRE ( FILE = \"freezeH2O_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN IF ( this_image () == 1 ) print * , \"ThompMP: read freezeH2O_mpt.dat instead of computing\" OPEN ( 63 , file = \"freezeH2O_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tpi_qrfz READ ( 63 , err = 1234 ) tni_qrfz READ ( 63 , err = 1234 ) tpg_qrfz READ ( 63 , err = 1234 ) tnr_qrfz READ ( 63 , err = 1234 ) tpi_qcfz READ ( 63 , err = 1234 ) tni_qcfz good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) endif ENDIF IF ( good . NE . 1 ) THEN if ( this_image () == 1 ) print * , \"ThompMP: computing freezeH2O\" !+---+ orho_w = 1. / rho_w do n2 = 1 , nbr massr ( n2 ) = am_r * Dr ( n2 ) ** bm_r enddo do n = 1 , nbc massc ( n ) = am_r * Dc ( n ) ** bm_r enddo !..Freeze water (smallest drops become cloud ice, otherwise graupel). do k = 1 , 45 !         print*, ' Freezing water for temp = ', -k ! ++ trude, add tadjust, so to chane temperature for where Bigg freezing starts. Follow approach in WRFV3.6 with IN Texp = DEXP ( DFLOAT ( k ) - t_adjust * 1.0D0 ) - 1.0D0 ! NB Trude. Check for when texp is negative..... !         Texp = DEXP( DFLOAT(k) ) - 1.0D0 ! -- trude do j = 1 , ntb_r1 do i = 1 , ntb_r lam_exp = ( N0r_exp ( j ) * am_r * crg ( 1 ) / r_r ( i )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( j ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) sum1 = 0.0d0 sum2 = 0.0d0 sumn1 = 0.0d0 sumn2 = 0.0d0 do n2 = nbr , 1 , - 1 N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) vol = massr ( n2 ) * orho_w prob = 1.0D0 - DEXP ( - 12 0.0D0 * vol * 5.2D-4 * Texp ) !++ trude prob = MAX ( prob , 0.0d0 ) ! -- trude if ( massr ( n2 ) . lt . xm0g ) then sumn1 = sumn1 + prob * N_r ( n2 ) sum1 = sum1 + prob * N_r ( n2 ) * massr ( n2 ) else sumn2 = sumn2 + prob * N_r ( n2 ) sum2 = sum2 + prob * N_r ( n2 ) * massr ( n2 ) endif if (( sum1 + sum2 ) . ge . r_r ( i )) EXIT enddo tpi_qrfz ( i , j , k ) = sum1 tni_qrfz ( i , j , k ) = sumn1 tpg_qrfz ( i , j , k ) = sum2 tnr_qrfz ( i , j , k ) = sumn2 enddo enddo do i = 1 , ntb_c lamc = 1.0D-6 * ( Nt_c * am_r * ccg ( 2 ) * ocg1 / r_c ( i )) ** obmr N0_c = 1.0D-18 * Nt_c * ocg1 * lamc ** cce ( 1 ) sum1 = 0.0d0 sumn2 = 0.0d0 do n = nbc , 1 , - 1 y = Dc ( n ) * 1.0D6 vol = massc ( n ) * orho_w prob = 1.0D0 - DEXP ( - 12 0.0D0 * vol * 5.2D-4 * Texp ) !++ trude prob = MAX ( prob , 0.0d0 ) ! -- trude N_c ( n ) = N0_c * y ** mu_c * EXP ( - lamc * y ) * dtc ( n ) N_c ( n ) = 1.0D24 * N_c ( n ) sumn2 = sumn2 + prob * N_c ( n ) sum1 = sum1 + prob * N_c ( n ) * massc ( n ) if ( sum1 . ge . r_c ( i )) EXIT enddo tpi_qcfz ( i , k ) = sum1 tni_qcfz ( i , k ) = sumn2 enddo enddo IF ( this_image () == 1 ) THEN print * , \"Writing freezeH2O_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"freezeH2O_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tpi_qrfz WRITE ( 63 , err = 9234 ) tni_qrfz WRITE ( 63 , err = 9234 ) tpg_qrfz WRITE ( 63 , err = 9234 ) tnr_qrfz WRITE ( 63 , err = 9234 ) tpi_qcfz WRITE ( 63 , err = 9234 ) tni_qcfz CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , \"Error writing freezeH2O_mpt.dat\" ENDIF endif end subroutine freezeH2O","tags":"","loc":"proc/freezeh2o.html"},{"title":"mp_gt_driver – Inference-Engine","text":"public subroutine mp_gt_driver(qv, qc, qr, qi, qs, qg, ni, nr, th, pii, p, dz, dt_in, itimestep, RAINNC, RAINNCV, SNOWNC, SNOWNCV, GRAUPELNC, GRAUPELNCV, SR, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte) Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qv real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qc real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qr real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qi real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qs real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qg real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: ni real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: nr real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: th real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: pii real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: p real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: dz real, intent(in) :: dt_in integer, intent(in) :: itimestep real, intent(inout), DIMENSION(ims:ime, jms:jme) :: RAINNC real, intent(inout), DIMENSION(ims:ime, jms:jme) :: RAINNCV real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: SNOWNC real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: SNOWNCV real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: GRAUPELNC real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: GRAUPELNCV real, intent(inout), DIMENSION(ims:ime, jms:jme) :: SR integer, intent(in) :: ids integer, intent(in) :: ide integer, intent(in) :: jds integer, intent(in) :: jde integer, intent(in) :: kds integer, intent(in) :: kde integer, intent(in) :: ims integer, intent(in) :: ime integer, intent(in) :: jms integer, intent(in) :: jme integer, intent(in) :: kms integer, intent(in) :: kme integer, intent(in) :: its integer, intent(in) :: ite integer, intent(in) :: jts integer, intent(in) :: jte integer, intent(in) :: kts integer, intent(in) :: kte Calls proc~~mp_gt_driver~~CallsGraph proc~mp_gt_driver mp_gt_driver proc~mp_thompson mp_thompson proc~mp_gt_driver->proc~mp_thompson proc~rslf RSLF proc~mp_thompson->proc~rslf proc~rsif RSIF proc~mp_thompson->proc~rsif alog10 alog10 proc~mp_thompson->alog10 sngl sngl proc~mp_thompson->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code mp_gt_driver Source Code SUBROUTINE mp_gt_driver ( qv , qc , qr , qi , qs , qg , ni , nr , & th , pii , p , dz , dt_in , itimestep , & RAINNC , RAINNCV , & SNOWNC , SNOWNCV , & GRAUPELNC , GRAUPELNCV , SR , & ids , ide , jds , jde , kds , kde , & ! domain dims ims , ime , jms , jme , kms , kme , & ! memory dims its , ite , jts , jte , kts , kte ) ! tile dims implicit none !..Subroutine arguments INTEGER , INTENT ( IN ) :: ids , ide , jds , jde , kds , kde , & ims , ime , jms , jme , kms , kme , & its , ite , jts , jte , kts , kte REAL , DIMENSION ( ims : ime , kms : kme , jms : jme ), INTENT ( INOUT ) :: & qv , qc , qr , qi , qs , qg , ni , nr , th REAL , DIMENSION ( ims : ime , kms : kme , jms : jme ), INTENT ( IN ) :: & pii , p , dz REAL , DIMENSION ( ims : ime , jms : jme ), INTENT ( INOUT ) :: & RAINNC , RAINNCV , SR REAL , DIMENSION ( ims : ime , jms : jme ), OPTIONAL , INTENT ( INOUT ) :: & SNOWNC , SNOWNCV , GRAUPELNC , GRAUPELNCV !     REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       & !                         refl_10cm REAL , INTENT ( IN ) :: dt_in !..Local variables INTEGER , INTENT ( IN ) :: itimestep REAL , DIMENSION ( kts : kte ) :: & qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dz1d , dBZ !       REAL, DIMENSION(its:ite, jts:jte):: pcp_ra, pcp_sn, pcp_gr, pcp_ic REAL :: dt , pptrain , pptsnow , pptgraul , pptice REAL :: qc_max , qr_max , qs_max , qi_max , qg_max , ni_max , nr_max INTEGER :: i , j , k INTEGER :: imax_qc , imax_qr , imax_qi , imax_qs , imax_qg , imax_ni , imax_nr INTEGER :: jmax_qc , jmax_qr , jmax_qi , jmax_qs , jmax_qg , jmax_ni , jmax_nr INTEGER :: kmax_qc , kmax_qr , kmax_qi , kmax_qs , kmax_qg , kmax_ni , kmax_nr INTEGER :: i_start , j_start , i_end , j_end !$OMP PARALLEL DEFAULT(PRIVATE) FIRSTPRIVATE(ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,& !$OMP kms,kme,its,ite,jts,jte,kts,kte,itimestep) & !$OMP SHARED(RAINNCV,RAINNC,SNOWNCV,SNOWNC,GRAUPELNCV,GRAUPELNC,SR,th,pii,p,dz,qv,qc,& !$OMP qi,qr,qs,qg,ni,nr,dt_in,Nt_c,TNO,rho_g,av_s,bv_s,fv_s,av_g,bv_g,EF_si,Ef_ri) ! old w/pcp_xx vars !!$OMP qi,qr,qs,qg,ni,nr,pcp_ra,pcp_sn,pcp_gr,pcp_ic,dt_in) i_start = its j_start = jts i_end = MIN ( ite , ide - 1 ) j_end = MIN ( jte , jde - 1 ) !..For idealized testing by developer. !     if ( (ide-ids+1).gt.4 .and. (jde-jds+1).lt.4 .and.                & !          ids.eq.its.and.ide.eq.ite.and.jds.eq.jts.and.jde.eq.jte) then !        i_start = its + 2 !        i_end   = ite !        j_start = jts !        j_end   = jte !     endif dt = dt_in qc_max = 0. qr_max = 0. qs_max = 0. qi_max = 0. qg_max = 0 ni_max = 0. nr_max = 0. imax_qc = 0 imax_qr = 0 imax_qi = 0 imax_qs = 0 imax_qg = 0 imax_ni = 0 imax_nr = 0 jmax_qc = 0 jmax_qr = 0 jmax_qi = 0 jmax_qs = 0 jmax_qg = 0 jmax_ni = 0 jmax_nr = 0 kmax_qc = 0 kmax_qr = 0 kmax_qi = 0 kmax_qs = 0 kmax_qg = 0 kmax_ni = 0 kmax_nr = 0 !       do i = 1, 256 !          mp_debug(i:i) = char(0) !       enddo !$omp do schedule(guided) j_loop : do j = j_start , j_end i_loop : do i = i_start , i_end pptrain = 0. pptsnow = 0. pptgraul = 0. pptice = 0. !          RAINNCV(i,j) = 0. !          IF ( PRESENT (snowncv) ) THEN !             SNOWNCV(i,j) = 0. !          ENDIF !          IF ( PRESENT (graupelncv) ) THEN !             GRAUPELNCV(i,j) = 0. !          ENDIF !          SR(i,j) = 0. do k = kts , kte t1d ( k ) = th ( i , k , j ) * pii ( i , k , j ) p1d ( k ) = p ( i , k , j ) dz1d ( k ) = dz ( i , k , j ) qv1d ( k ) = qv ( i , k , j ) qc1d ( k ) = qc ( i , k , j ) qi1d ( k ) = qi ( i , k , j ) qr1d ( k ) = qr ( i , k , j ) qs1d ( k ) = qs ( i , k , j ) qg1d ( k ) = qg ( i , k , j ) ni1d ( k ) = ni ( i , k , j ) nr1d ( k ) = nr ( i , k , j ) enddo call mp_thompson ( qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dz1d , & pptrain , pptsnow , pptgraul , pptice , & kts , kte , dt , i , j ) !          pcp_ra(i,j) = pptrain !          pcp_sn(i,j) = pptsnow !          pcp_gr(i,j) = pptgraul !          pcp_ic(i,j) = pptice !          RAINNCV(i,j) = pptrain + pptsnow + pptgraul + pptice RAINNC ( i , j ) = RAINNC ( i , j ) + pptrain + pptsnow + pptgraul + pptice IF ( PRESENT ( SNOWNC ) ) SNOWNC ( i , j ) = SNOWNC ( i , j ) + pptsnow + pptice IF ( PRESENT ( SNOWNCV ) ) SNOWNCV ( i , j ) = pptsnow + pptice IF ( PRESENT ( GRAUPELNC ) ) GRAUPELNC ( i , j ) = GRAUPELNC ( i , j ) + pptgraul IF ( PRESENT ( GRAUPELNCV ) ) GRAUPELNCV ( i , j ) = pptgraul SR ( i , j ) = ( pptsnow + pptgraul + pptice ) / ( RAINNCV ( i , j ) + 1.e-12 ) do k = kts , kte qv ( i , k , j ) = qv1d ( k ) qc ( i , k , j ) = qc1d ( k ) qi ( i , k , j ) = qi1d ( k ) qr ( i , k , j ) = qr1d ( k ) qs ( i , k , j ) = qs1d ( k ) qg ( i , k , j ) = qg1d ( k ) ni ( i , k , j ) = ni1d ( k ) nr ( i , k , j ) = nr1d ( k ) th ( i , k , j ) = t1d ( k ) / pii ( i , k , j ) !             if (qc1d(k) .gt. qc_max) then !              imax_qc = i !              jmax_qc = j !              kmax_qc = k !              qc_max = qc1d(k) !             elseif (qc1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qc ', qc1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qr1d(k) .gt. qr_max) then !              imax_qr = i !              jmax_qr = j !              kmax_qr = k !              qr_max = qr1d(k) !             elseif (qr1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qr ', qr1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (nr1d(k) .gt. nr_max) then !              imax_nr = i !              jmax_nr = j !              kmax_nr = k !              nr_max = nr1d(k) !             elseif (nr1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative nr ', nr1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qs1d(k) .gt. qs_max) then !              imax_qs = i !              jmax_qs = j !              kmax_qs = k !              qs_max = qs1d(k) !             elseif (qs1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qs ', qs1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qi1d(k) .gt. qi_max) then !              imax_qi = i !              jmax_qi = j !              kmax_qi = k !              qi_max = qi1d(k) !             elseif (qi1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qi ', qi1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qg1d(k) .gt. qg_max) then !              imax_qg = i !              jmax_qg = j !              kmax_qg = k !              qg_max = qg1d(k) !             elseif (qg1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qg ', qg1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (ni1d(k) .gt. ni_max) then !              imax_ni = i !              jmax_ni = j !              kmax_ni = k !              ni_max = ni1d(k) !             elseif (ni1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative ni ', ni1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif if ( qv1d ( k ) . lt . 1.E-7 ) then if ( k . lt . kte - 2 . and . k . gt . kts + 1 ) then qv ( i , k , j ) = 0.5 * ( qv ( i , k - 1 , j ) + qv ( i , k + 1 , j )) ! note, if qv(i,k+1,j) < 0 then qv(i,k,j) could still be < 0 if ( qv1d ( k ) . lt . 1.E-7 ) then qv ( i , k , j ) = 1.E-7 endif else qv ( i , k , j ) = 1.E-7 endif !              write(mp_debug,*) 'WARNING, negative qv ', qv1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) endif enddo !          IF ( PRESENT (diagflag) ) THEN !          if (diagflag .and. do_radar_ref == 1) then !           call calc_refl10cm (qv1d, qc1d, qr1d, nr1d, qs1d, qg1d,       & !                       t1d, p1d, dBZ, kts, kte, i, j) !           do k = kts, kte !              refl_10cm(i,k,j) = MAX(-35., dBZ(k)) !           enddo !          endif !          ENDIF enddo i_loop enddo j_loop !$omp end do !$omp end parallel ! DEBUG - GT !       write(mp_debug,'(a,7(a,e13.6,1x,a,i3,a,i3,a,i3,a,1x))') 'MP-GT:', & !          'qc: ', qc_max, '(', imax_qc, ',', jmax_qc, ',', kmax_qc, ')', & !          'qr: ', qr_max, '(', imax_qr, ',', jmax_qr, ',', kmax_qr, ')', & !          'qi: ', qi_max, '(', imax_qi, ',', jmax_qi, ',', kmax_qi, ')', & !          'qs: ', qs_max, '(', imax_qs, ',', jmax_qs, ',', kmax_qs, ')', & !          'qg: ', qg_max, '(', imax_qg, ',', jmax_qg, ',', kmax_qg, ')', & !          'ni: ', ni_max, '(', imax_ni, ',', jmax_ni, ',', kmax_ni, ')', & !          'nr: ', nr_max, '(', imax_nr, ',', jmax_nr, ',', kmax_nr, ')' ! CALL wrf_debug(150, mp_debug) ! END DEBUG - GT !       do i = 1, 256 !          mp_debug(i:i) = char(0) !       enddo END SUBROUTINE mp_gt_driver","tags":"","loc":"proc/mp_gt_driver.html"},{"title":"mp_thompson – Inference-Engine","text":"public subroutine mp_thompson(qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, nr1d, t1d, p1d, dzq, pptrain, pptsnow, pptgraul, pptice, kts, kte, dt, ii, jj) -- trude Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(kts:kte) :: qv1d real, intent(inout), DIMENSION(kts:kte) :: qc1d real, intent(inout), DIMENSION(kts:kte) :: qi1d real, intent(inout), DIMENSION(kts:kte) :: qr1d real, intent(inout), DIMENSION(kts:kte) :: qs1d real, intent(inout), DIMENSION(kts:kte) :: qg1d real, intent(inout), DIMENSION(kts:kte) :: ni1d real, intent(inout), DIMENSION(kts:kte) :: nr1d real, intent(inout), DIMENSION(kts:kte) :: t1d real, intent(inout), DIMENSION(kts:kte) :: p1d real, intent(in), DIMENSION(kts:kte) :: dzq real, intent(inout) :: pptrain real, intent(inout) :: pptsnow real, intent(inout) :: pptgraul real, intent(inout) :: pptice integer, intent(in) :: kts integer, intent(in) :: kte real, intent(in) :: dt integer, intent(in) :: ii integer, intent(in) :: jj Calls proc~~mp_thompson~~CallsGraph proc~mp_thompson mp_thompson proc~rslf RSLF proc~mp_thompson->proc~rslf proc~rsif RSIF proc~mp_thompson->proc~rsif alog10 alog10 proc~mp_thompson->alog10 sngl sngl proc~mp_thompson->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mp_thompson~~CalledByGraph proc~mp_thompson mp_thompson proc~mp_gt_driver mp_gt_driver proc~mp_gt_driver->proc~mp_thompson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code mp_thompson Source Code subroutine mp_thompson ( qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dzq , & pptrain , pptsnow , pptgraul , pptice , & kts , kte , dt , ii , jj ) implicit none !..Sub arguments INTEGER , INTENT ( IN ) :: kts , kte , ii , jj REAL , DIMENSION ( kts : kte ), INTENT ( INOUT ) :: & qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d REAL , DIMENSION ( kts : kte ), INTENT ( IN ) :: dzq REAL , INTENT ( INOUT ) :: pptrain , pptsnow , pptgraul , pptice REAL , INTENT ( IN ) :: dt !..Local variables REAL , DIMENSION ( kts : kte ) :: tten , qvten , qcten , qiten , & qrten , qsten , qgten , niten , nrten DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prw_vcd DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prr_wau , prr_rcw , prr_rcs , & prr_rcg , prr_sml , prr_gml , & prr_rci , prv_rev , & pnr_wau , pnr_rcs , pnr_rcg , & pnr_rci , pnr_sml , pnr_gml , & pnr_rev , pnr_rcr , pnr_rfz DOUBLE PRECISION , DIMENSION ( kts : kte ) :: pri_inu , pni_inu , pri_ihm , & pni_ihm , pri_wfz , pni_wfz , & pri_rfz , pni_rfz , pri_ide , & pni_ide , pri_rci , pni_rci , & pni_sci , pni_iau DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prs_iau , prs_sci , prs_rcs , & prs_scw , prs_sde , prs_ihm , & prs_ide DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prg_scw , prg_rfz , prg_gde , & prg_gcw , prg_rci , prg_rcs , & prg_rcg , prg_ihm DOUBLE PRECISION , PARAMETER :: zeroD0 = 0.0d0 REAL , DIMENSION ( kts : kte ) :: temp , pres , qv REAL , DIMENSION ( kts : kte ) :: rc , ri , rr , rs , rg , ni , nr REAL , DIMENSION ( kts : kte ) :: rho , rhof , rhof2 REAL , DIMENSION ( kts : kte ) :: qvs , qvsi , delQvs REAL , DIMENSION ( kts : kte ) :: satw , sati , ssatw , ssati REAL , DIMENSION ( kts : kte ) :: diffu , visco , vsc2 , & tcond , lvap , ocp , lvt2 DOUBLE PRECISION , DIMENSION ( kts : kte ) :: ilamr , ilamg , N0_r , N0_g REAL , DIMENSION ( kts : kte ) :: mvd_r , mvd_c REAL , DIMENSION ( kts : kte ) :: smob , smo2 , smo1 , smo0 , & smoc , smod , smoe , smof REAL , DIMENSION ( kts : kte ) :: sed_r , sed_s , sed_g , sed_i , sed_n REAL :: rgvm , delta_tp , orho , lfus2 REAL , DIMENSION ( 4 ) :: onstep DOUBLE PRECISION :: N0_exp , N0_min , lam_exp , lamc , lamr , lamg DOUBLE PRECISION :: lami , ilami REAL :: xDc , Dc_b , Dc_g , xDi , xDr , xDs , xDg , Ds_m , Dg_m DOUBLE PRECISION :: Dr_star REAL :: zeta1 , zeta , taud , tau REAL :: stoke_r , stoke_s , stoke_g , stoke_i REAL :: vti , vtr , vts , vtg REAL , DIMENSION ( kts : kte + 1 ) :: vtik , vtnik , vtrk , vtnrk , vtsk , vtgk REAL , DIMENSION ( kts : kte ) :: vts_boost REAL :: Mrat , ils1 , ils2 , t1_vts , t2_vts , t3_vts , t4_vts , C_snow REAL :: a_ , b_ , loga_ , A1 , A2 , tf REAL :: tempc , tc0 , r_mvd1 , r_mvd2 , xkrat REAL :: xnc , xri , xni , xmi , oxmi , xrc , xrr , xnr REAL :: xsat , rate_max , sump , ratio REAL :: clap , fcd , dfcd REAL :: otemp , rvs , rvs_p , rvs_pp , gamsc , alphsc , t1_evap , t1_subl REAL :: r_frac , g_frac REAL :: Ef_rw , Ef_sw , Ef_gw , Ef_rr REAL :: dtsave , odts , odt , odzq REAL :: xslw1 , ygra1 , zans1 INTEGER :: i , k , k2 , n , nn , nstep , k_0 , kbot , IT , iexfrq INTEGER , DIMENSION ( 4 ) :: ksed1 INTEGER :: nir , nis , nig , nii , nic INTEGER :: idx_tc , idx_t , idx_s , idx_g1 , idx_g , idx_r1 , idx_r , & idx_i1 , idx_i , idx_c , idx , idx_d LOGICAL :: melti , no_micro LOGICAL , DIMENSION ( kts : kte ) :: L_qc , L_qi , L_qr , L_qs , L_qg LOGICAL :: debug_flag !+---+ debug_flag = . false . !     if (ii.eq.315 .and. jj.eq.2) debug_flag = .true. no_micro = . true . dtsave = dt odt = 1. / dt odts = 1. / dtsave iexfrq = 1 !+---+-----------------------------------------------------------------+ !.. Source/sink terms.  First 2 chars: \"pr\" represents source/sink of !.. mass while \"pn\" represents source/sink of number.  Next char is one !.. of \"v\" for water vapor, \"r\" for rain, \"i\" for cloud ice, \"w\" for !.. cloud water, \"s\" for snow, and \"g\" for graupel.  Next chars !.. represent processes: \"de\" for sublimation/deposition, \"ev\" for !.. evaporation, \"fz\" for freezing, \"ml\" for melting, \"au\" for !.. autoconversion, \"nu\" for ice nucleation, \"hm\" for Hallet/Mossop !.. secondary ice production, and \"c\" for collection followed by the !.. character for the species being collected.  ALL of these terms are !.. positive (except for deposition/sublimation terms which can switch !.. signs based on super/subsaturation) and are treated as negatives !.. where necessary in the tendency equations. !+---+-----------------------------------------------------------------+ do k = kts , kte tten ( k ) = 0. qvten ( k ) = 0. qcten ( k ) = 0. qiten ( k ) = 0. qrten ( k ) = 0. qsten ( k ) = 0. qgten ( k ) = 0. niten ( k ) = 0. nrten ( k ) = 0. prw_vcd ( k ) = 0. prv_rev ( k ) = 0. prr_wau ( k ) = 0. prr_rcw ( k ) = 0. prr_rcs ( k ) = 0. prr_rcg ( k ) = 0. prr_sml ( k ) = 0. prr_gml ( k ) = 0. prr_rci ( k ) = 0. pnr_wau ( k ) = 0. pnr_rcs ( k ) = 0. pnr_rcg ( k ) = 0. pnr_rci ( k ) = 0. pnr_sml ( k ) = 0. pnr_gml ( k ) = 0. pnr_rev ( k ) = 0. pnr_rcr ( k ) = 0. pnr_rfz ( k ) = 0. pri_inu ( k ) = 0. pni_inu ( k ) = 0. pri_ihm ( k ) = 0. pni_ihm ( k ) = 0. pri_wfz ( k ) = 0. pni_wfz ( k ) = 0. pri_rfz ( k ) = 0. pni_rfz ( k ) = 0. pri_ide ( k ) = 0. pni_ide ( k ) = 0. pri_rci ( k ) = 0. pni_rci ( k ) = 0. pni_sci ( k ) = 0. pni_iau ( k ) = 0. prs_iau ( k ) = 0. prs_sci ( k ) = 0. prs_rcs ( k ) = 0. prs_scw ( k ) = 0. prs_sde ( k ) = 0. prs_ihm ( k ) = 0. prs_ide ( k ) = 0. prg_scw ( k ) = 0. prg_rfz ( k ) = 0. prg_gde ( k ) = 0. prg_gcw ( k ) = 0. prg_rci ( k ) = 0. prg_rcs ( k ) = 0. prg_rcg ( k ) = 0. prg_ihm ( k ) = 0. enddo !+---+-----------------------------------------------------------------+ !..Put column of data into local arrays. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) qv ( k ) = MAX ( 1.E-10 , qv1d ( k )) pres ( k ) = p1d ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) if ( qc1d ( k ) . gt . R1 ) then no_micro = . false . rc ( k ) = qc1d ( k ) * rho ( k ) L_qc ( k ) = . true . else qc1d ( k ) = 0.0 rc ( k ) = R1 L_qc ( k ) = . false . endif if ( qi1d ( k ) . gt . R1 ) then no_micro = . false . ri ( k ) = qi1d ( k ) * rho ( k ) ni ( k ) = MAX ( R2 , ni1d ( k ) * rho ( k )) L_qi ( k ) = . true . lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 ni ( k ) = MIN ( 25 0.D3 , cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i ) elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 ni ( k ) = cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i endif else qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif mvd_r ( k ) = 0.0 ! must be initialized or a later test can crash where qr1d(k)<=R1 if ( qr1d ( k ) . gt . R1 ) then no_micro = . false . rr ( k ) = qr1d ( k ) * rho ( k ) nr ( k ) = MAX ( R2 , nr1d ( k ) * rho ( k )) L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if ( qs1d ( k ) . gt . R1 ) then no_micro = . false . rs ( k ) = qs1d ( k ) * rho ( k ) L_qs ( k ) = . true . else qs1d ( k ) = 0.0 rs ( k ) = R1 L_qs ( k ) = . false . endif if ( qg1d ( k ) . gt . R1 ) then no_micro = . false . rg ( k ) = qg1d ( k ) * rho ( k ) L_qg ( k ) = . true . else qg1d ( k ) = 0.0 rg ( k ) = R1 L_qg ( k ) = . false . endif enddo !+---+-----------------------------------------------------------------+ !..Derive various thermodynamic variables frequently used. !.. Saturation vapor pressure (mixing ratio) over liquid/ice comes from !.. Flatau et al. 1992; enthalpy (latent heat) of vaporization from !.. Bohren & Albrecht 1998; others from Pruppacher & Klett 1978. !+---+-----------------------------------------------------------------+ do k = kts , kte tempc = temp ( k ) - 27 3.15 rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) delQvs ( k ) = MAX ( 0.0 , rslf ( pres ( k ), 27 3.15 ) - qv ( k )) if ( tempc . le . 0.0 ) then qvsi ( k ) = rsif ( pres ( k ), temp ( k )) else qvsi ( k ) = qvs ( k ) endif satw ( k ) = qv ( k ) / qvs ( k ) sati ( k ) = qv ( k ) / qvsi ( k ) ssatw ( k ) = satw ( k ) - 1. ssati ( k ) = sati ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 if ( abs ( ssati ( k )). lt . eps ) ssati ( k ) = 0.0 if ( no_micro . and . ssati ( k ). gt . 0.0 ) no_micro = . false . diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 enddo !+---+-----------------------------------------------------------------+ !..If no existing hydrometeor species and no chance to initiate ice or !.. condense cloud water, just exit quickly! !+---+-----------------------------------------------------------------+ if ( no_micro ) return !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope, and useful moments for snow. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = MIN ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate 0th moment.  Represents snow number concentration. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 5 ) * tc0 * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 5 ) * tc0 * tc0 + sb ( 9 ) * tc0 * tc0 * tc0 smo0 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1st moment.  Useful for depositional growth and melting. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) & + sa ( 4 ) * tc0 + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) + sa ( 7 ) * tc0 * tc0 & + sa ( 8 ) * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) + sb ( 4 ) * tc0 & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) & + sb ( 7 ) * tc0 * tc0 + sb ( 8 ) * tc0 & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) smo1 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bv_s+2 (th) moment.  Useful for riming. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 13 ) & + sa ( 4 ) * tc0 * cse ( 13 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 13 ) * cse ( 13 ) + sa ( 7 ) * tc0 * tc0 * cse ( 13 ) & + sa ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 13 ) + sb ( 4 ) * tc0 * cse ( 13 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 13 ) * cse ( 13 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 13 ) + sb ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) smoe ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 16 ) & + sa ( 4 ) * tc0 * cse ( 16 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 16 ) * cse ( 16 ) + sa ( 7 ) * tc0 * tc0 * cse ( 16 ) & + sa ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 16 ) + sb ( 4 ) * tc0 * cse ( 16 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 16 ) * cse ( 16 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 16 ) + sb ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) smof ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ N0_min = gonv_max do k = kte , kts , - 1 if ( temp ( k ). lt . 27 0.65 . and . L_qr ( k ) . and . mvd_r ( k ). gt . 10 0.E-6 ) then xslw1 = 4.01 + alog10 ( mvd_r ( k )) else xslw1 = 0.01 endif ygra1 = 4.31 + alog10 ( max ( 5.E-5 , rg ( k ))) zans1 = 3.1 + ( 10 0. / ( 30 0. * xslw1 * ygra1 / ( 1 0. / xslw1 + 1. + 0.25 * ygra1 ) + 3 0. + 1 0. * ygra1 )) N0_exp = 1 0. ** ( zans1 ) N0_exp = MAX ( DBLE ( gonv_min ), MIN ( N0_exp , DBLE ( gonv_max ))) N0_min = MIN ( N0_exp , N0_min ) N0_exp = N0_min lam_exp = ( N0_exp * am_g * cgg ( 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = N0_exp / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) !+---+-----------------------------------------------------------------+ !     if( debug_flag .and. k.lt.42) then !        if (k.eq.41) write(mp_debug,*) 'DEBUG-GT:   K,   zans1,      rc,        rr,         rg,        N0_g' !        if (k.eq.41) CALL wrf_debug(0, mp_debug) !        write(mp_debug, 'a, i2, 1x, f6.3, 1x, 4(1x,e13.6,1x)')         & !                   '  GT ', k, zans1, rc(k), rr(k), rg(k), N0_g(k) !        CALL wrf_debug(0, mp_debug) !     endif !+---+-----------------------------------------------------------------+ enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !+---+-----------------------------------------------------------------+ !..Compute warm-rain process terms (except evap done later). !+---+-----------------------------------------------------------------+ do k = kts , kte !..Rain self-collection follows Seifert, 1994 and drop break-up !.. follows Verlinde and Cotton, 1993.                                        RAIN2M if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r ) then !-GT      Ef_rr = 1.0 !-GT      if (mvd_r(k) .gt. 1500.0E-6) then Ef_rr = 2.0 - EXP ( 230 0.0 * ( mvd_r ( k ) - 160 0.0E-6 )) !-GT      endif pnr_rcr ( k ) = Ef_rr * 4. * nr ( k ) * rr ( k ) endif mvd_c ( k ) = D0c if (. not . L_qc ( k )) CYCLE xDc = MAX ( D0c * 1.E6 , (( rc ( k ) / ( am_r * Nt_c )) ** obmr ) * 1.E6 ) lamc = ( Nt_c * am_r * ccg ( 2 ) * ocg1 / rc ( k )) ** obmr mvd_c ( k ) = ( 3.0 + mu_c + 0.672 ) / lamc !..Autoconversion follows Berry & Reinhardt (1974) with characteristic !.. diameters correctly computed from gamma distrib of cloud droplets. if ( rc ( k ). gt . 0.01e-3 ) then Dc_g = (( ccg ( 3 ) * ocg2 ) ** obmr / lamc ) * 1.E6 Dc_b = ( xDc * xDc * xDc * Dc_g * Dc_g * Dc_g - xDc * xDc * xDc * xDc * xDc * xDc ) & ** ( 1. / 6. ) zeta1 = 0.5 * (( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 ) & + abs ( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 )) zeta = 0.027 * rc ( k ) * zeta1 taud = 0.5 * (( 0.5 * Dc_b - 7.5 ) + abs ( 0.5 * Dc_b - 7.5 )) + R1 tau = 3.72 / ( rc ( k ) * taud ) prr_wau ( k ) = zeta / tau prr_wau ( k ) = MIN ( DBLE ( rc ( k ) * odts ), prr_wau ( k )) pnr_wau ( k ) = prr_wau ( k ) / ( am_r * mu_c * D0r * D0r * D0r ) ! RAIN2M endif !..Rain collecting cloud water.  In CE, assume Dc<<Dr and vtc=~0. if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r . and . mvd_c ( k ). gt . D0c ) then lamr = 1. / ilamr ( k ) idx = 1 + INT ( nbr * DLOG ( mvd_r ( k ) / Dr ( 1 )) / DLOG ( Dr ( nbr ) / Dr ( 1 ))) idx = MIN ( idx , nbr ) Ef_rw = t_Efrw ( idx , INT ( mvd_c ( k ) * 1.E6 )) prr_rcw ( k ) = rhof ( k ) * t1_qr_qc * Ef_rw * rc ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) prr_rcw ( k ) = MIN ( DBLE ( rc ( k ) * odts ), prr_rcw ( k )) endif enddo !+---+-----------------------------------------------------------------+ !..Compute all frozen hydrometeor species' process terms. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte vts_boost ( k ) = 1.5 !..Temperature lookup table indexes. tempc = temp ( k ) - 27 3.15 idx_tc = MAX ( 1 , MIN ( NINT ( - tempc ), 45 ) ) idx_t = INT ( ( tempc - 2.5 ) / 5. ) - 1 idx_t = MAX ( 1 , - idx_t ) idx_t = MIN ( idx_t , ntb_t ) IT = MAX ( 1 , MIN ( NINT ( - tempc ), 31 ) ) !..Cloud water lookup table index. if ( rc ( k ). gt . r_c ( 1 )) then nic = NINT ( ALOG10 ( rc ( k ))) do nn = nic - 1 , nic + 1 n = nn if ( ( rc ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rc ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 141 enddo 141 continue idx_c = INT ( rc ( k ) / 1 0. ** n ) + 10 * ( n - nic2 ) - ( n - nic2 ) idx_c = MAX ( 1 , MIN ( idx_c , ntb_c )) else idx_c = 1 endif !..Cloud ice lookup table indexes. if ( ri ( k ). gt . r_i ( 1 )) then nii = NINT ( ALOG10 ( ri ( k ))) do nn = nii - 1 , nii + 1 n = nn if ( ( ri ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( ri ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 142 enddo 142 continue idx_i = INT ( ri ( k ) / 1 0. ** n ) + 10 * ( n - nii2 ) - ( n - nii2 ) idx_i = MAX ( 1 , MIN ( idx_i , ntb_i )) else idx_i = 1 endif if ( ni ( k ). gt . Nt_i ( 1 )) then nii = NINT ( ALOG10 ( ni ( k ))) do nn = nii - 1 , nii + 1 n = nn if ( ( ni ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( ni ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 143 enddo 143 continue idx_i1 = INT ( ni ( k ) / 1 0. ** n ) + 10 * ( n - nii3 ) - ( n - nii3 ) idx_i1 = MAX ( 1 , MIN ( idx_i1 , ntb_i1 )) else idx_i1 = 1 endif !..Rain lookup table indexes. if ( rr ( k ). gt . r_r ( 1 )) then nir = NINT ( ALOG10 ( rr ( k ))) do nn = nir - 1 , nir + 1 n = nn if ( ( rr ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rr ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 144 enddo 144 continue idx_r = INT ( rr ( k ) / 1 0. ** n ) + 10 * ( n - nir2 ) - ( n - nir2 ) idx_r = MAX ( 1 , MIN ( idx_r , ntb_r )) lamr = 1. / ilamr ( k ) lam_exp = lamr * ( crg ( 3 ) * org2 * org1 ) ** bm_r N0_exp = org1 * rr ( k ) / am_r * lam_exp ** cre ( 1 ) nir = NINT ( DLOG10 ( N0_exp )) do nn = nir - 1 , nir + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . & ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) goto 145 enddo 145 continue idx_r1 = INT ( N0_exp / 1 0. ** n ) + 10 * ( n - nir3 ) - ( n - nir3 ) idx_r1 = MAX ( 1 , MIN ( idx_r1 , ntb_r1 )) else idx_r = 1 idx_r1 = ntb_r1 endif !..Snow lookup table index. if ( rs ( k ). gt . r_s ( 1 )) then nis = NINT ( ALOG10 ( rs ( k ))) do nn = nis - 1 , nis + 1 n = nn if ( ( rs ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rs ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 146 enddo 146 continue idx_s = INT ( rs ( k ) / 1 0. ** n ) + 10 * ( n - nis2 ) - ( n - nis2 ) idx_s = MAX ( 1 , MIN ( idx_s , ntb_s )) else idx_s = 1 endif !..Graupel lookup table index. if ( rg ( k ). gt . r_g ( 1 )) then nig = NINT ( ALOG10 ( rg ( k ))) do nn = nig - 1 , nig + 1 n = nn if ( ( rg ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rg ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 147 enddo 147 continue idx_g = INT ( rg ( k ) / 1 0. ** n ) + 10 * ( n - nig2 ) - ( n - nig2 ) idx_g = MAX ( 1 , MIN ( idx_g , ntb_g )) lamg = 1. / ilamg ( k ) lam_exp = lamg * ( cgg ( 3 ) * ogg2 * ogg1 ) ** bm_g N0_exp = ogg1 * rg ( k ) / am_g * lam_exp ** cge ( 1 ) nig = NINT ( DLOG10 ( N0_exp )) do nn = nig - 1 , nig + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . & ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) goto 148 enddo 148 continue idx_g1 = INT ( N0_exp / 1 0. ** n ) + 10 * ( n - nig3 ) - ( n - nig3 ) idx_g1 = MAX ( 1 , MIN ( idx_g1 , ntb_g1 )) else idx_g = 1 idx_g1 = ntb_g1 endif !..Deposition/sublimation prefactor (from Srivastava & Coen 1992). otemp = 1. / temp ( k ) rvs = rho ( k ) * qvsi ( k ) rvs_p = rvs * otemp * ( lsub * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lsub * otemp * oRv - 1. ) & * otemp * ( lsub * otemp * oRv - 1. ) & + ( - 2. * lsub * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lsub * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = MAX ( 1.E-9 , alphsc ) xsat = ssati ( k ) if ( abs ( xsat ). lt . 1.E-9 ) xsat = 0. t1_subl = 4. * PI2 * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) !..Snow collecting cloud water.  In CE, assume Dc<<Ds and vtc=~0. if ( L_qc ( k ) . and . mvd_c ( k ). gt . D0c ) then xDs = 0.0 if ( L_qs ( k )) xDs = smoc ( k ) / smob ( k ) if ( xDs . gt . D0s ) then idx = 1 + INT ( nbs * DLOG ( xDs / Ds ( 1 )) / DLOG ( Ds ( nbs ) / Ds ( 1 ))) idx = MIN ( idx , nbs ) Ef_sw = t_Efsw ( idx , INT ( mvd_c ( k ) * 1.E6 )) prs_scw ( k ) = rhof ( k ) * t1_qs_qc * Ef_sw * rc ( k ) * smoe ( k ) endif !..Graupel collecting cloud water.  In CE, assume Dc<<Dg and vtc=~0. if ( rg ( k ). ge . r_g ( 1 ) . and . mvd_c ( k ). gt . D0c ) then xDg = ( bm_g + mu_g + 1. ) * ilamg ( k ) vtg = rhof ( k ) * av_g * cgg ( 6 ) * ogg3 * ilamg ( k ) ** bv_g stoke_g = mvd_c ( k ) * mvd_c ( k ) * vtg * rho_w / ( 9. * visco ( k ) * xDg ) if ( xDg . gt . D0g ) then if ( stoke_g . ge . 0.4 . and . stoke_g . le . 1 0. ) then Ef_gw = 0.55 * ALOG10 ( 2.51 * stoke_g ) elseif ( stoke_g . lt . 0.4 ) then Ef_gw = 0.0 elseif ( stoke_g . gt . 10 ) then Ef_gw = 0.77 endif prg_gcw ( k ) = rhof ( k ) * t1_qg_qc * Ef_gw * rc ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 ) endif endif endif !..Rain collecting snow.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rr ( k ). ge . r_r ( 1 )) then if ( rs ( k ). ge . r_s ( 1 )) then if ( temp ( k ). lt . T_0 ) then prr_rcs ( k ) = - ( tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r )) prs_rcs ( k ) = tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prg_rcs ( k ) = tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prr_rcs ( k ) = MAX ( DBLE ( - rr ( k ) * odts ), prr_rcs ( k )) prs_rcs ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_rcs ( k )) prg_rcs ( k ) = MIN ( DBLE (( rr ( k ) + rs ( k )) * odts ), prg_rcs ( k )) pnr_rcs ( k ) = tnr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & ! RAIN2M + tnr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) else prs_rcs ( k ) = - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) prs_rcs ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_rcs ( k )) prr_rcs ( k ) = - prs_rcs ( k ) pnr_rcs ( k ) = tnr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & ! RAIN2M + tnr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) endif pnr_rcs ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rcs ( k )) endif !..Rain collecting graupel.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rg ( k ). ge . r_g ( 1 )) then if ( temp ( k ). lt . T_0 ) then prg_rcg ( k ) = tmr_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) & + tcr_gacr ( idx_g1 , idx_g , idx_r1 , idx_r ) prg_rcg ( k ) = MIN ( DBLE ( rr ( k ) * odts ), prg_rcg ( k )) prr_rcg ( k ) = - prg_rcg ( k ) pnr_rcg ( k ) = tnr_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) & ! RAIN2M + tnr_gacr ( idx_g1 , idx_g , idx_r1 , idx_r ) pnr_rcg ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rcg ( k )) else prr_rcg ( k ) = tcg_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) prr_rcg ( k ) = MIN ( DBLE ( rg ( k ) * odts ), prr_rcg ( k )) prg_rcg ( k ) = - prr_rcg ( k ) endif endif endif !+---+-----------------------------------------------------------------+ !..Next IF block handles only those processes below 0C. !+---+-----------------------------------------------------------------+ if ( temp ( k ). lt . T_0 ) then vts_boost ( k ) = 1.0 rate_max = ( qv ( k ) - qvsi ( k )) * rho ( k ) * odts * 0.999 !..Freezing of water drops into graupel/cloud ice (Bigg 1953). if ( rr ( k ). gt . r_r ( 1 )) then prg_rfz ( k ) = tpg_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pri_rfz ( k ) = tpi_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pni_rfz ( k ) = tni_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pnr_rfz ( k ) = tnr_qrfz ( idx_r , idx_r1 , idx_tc ) * odts ! RAIN2M pnr_rfz ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rfz ( k )) elseif ( rr ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_rfz ( k ) = rr ( k ) * odts pnr_rfz ( k ) = nr ( k ) * odts ! RAIN2M pni_rfz ( k ) = pnr_rfz ( k ) endif if ( rc ( k ). gt . r_c ( 1 )) then pri_wfz ( k ) = tpi_qcfz ( idx_c , idx_tc ) * odts pri_wfz ( k ) = MIN ( DBLE ( rc ( k ) * odts ), pri_wfz ( k )) pni_wfz ( k ) = tni_qcfz ( idx_c , idx_tc ) * odts pni_wfz ( k ) = MIN ( DBLE ( Nt_c * odts ), pri_wfz ( k ) / ( 2. * xm0i ), & pni_wfz ( k )) elseif ( rc ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_wfz ( k ) = rc ( k ) * odts pni_wfz ( k ) = MIN ( DBLE ( Nt_c * odts ), pri_wfz ( k ) / ( 2. * xm0i ), & pni_wfz ( k )) endif !..Nucleate ice from deposition & condensation freezing (Cooper 1986) !.. but only if water sat and T<-12C or 25%+ ice supersaturated. if ( ( ssati ( k ). ge . 0.25 ) . or . ( ssatw ( k ). gt . eps & . and . temp ( k ). lt . 26 1.15 ) ) then xnc = MIN ( 25 0.E3 , TNO * EXP ( ATO * ( T_0 - temp ( k )))) xni = ni ( k ) + ( pni_rfz ( k ) + pni_wfz ( k )) * dtsave pni_inu ( k ) = 0.5 * ( xnc - xni + abs ( xnc - xni )) * odts pri_inu ( k ) = MIN ( DBLE ( rate_max ), xm0i * pni_inu ( k )) pni_inu ( k ) = pri_inu ( k ) / xm0i endif !..Deposition/sublimation of cloud ice (Srivastava & Coen 1992). if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = MAX ( DBLE ( D0i ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi pri_ide ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * oig1 * cig ( 5 ) * ni ( k ) * ilami if ( pri_ide ( k ) . lt . 0.0 ) then pri_ide ( k ) = MAX ( DBLE ( - ri ( k ) * odts ), pri_ide ( k ), DBLE ( rate_max )) pni_ide ( k ) = pri_ide ( k ) * oxmi pni_ide ( k ) = MAX ( DBLE ( - ni ( k ) * odts ), pni_ide ( k )) else pri_ide ( k ) = MIN ( pri_ide ( k ), DBLE ( rate_max )) prs_ide ( k ) = ( 1.0D0 - tpi_ide ( idx_i , idx_i1 )) * pri_ide ( k ) pri_ide ( k ) = tpi_ide ( idx_i , idx_i1 ) * pri_ide ( k ) endif !..Some cloud ice needs to move into the snow category.  Use lookup !.. table that resulted from explicit bin representation of distrib. if ( ( idx_i . eq . ntb_i ) . or . ( xDi . gt . 5.0 * D0s ) ) then prs_iau ( k ) = ri ( k ) * . 99 * odts pni_iau ( k ) = ni ( k ) * . 95 * odts elseif ( xDi . lt . 0.1 * D0s ) then prs_iau ( k ) = 0. pni_iau ( k ) = 0. else prs_iau ( k ) = tps_iaus ( idx_i , idx_i1 ) * odts prs_iau ( k ) = MIN ( DBLE ( ri ( k ) * . 99 * odts ), prs_iau ( k )) pni_iau ( k ) = tni_iaus ( idx_i , idx_i1 ) * odts pni_iau ( k ) = MIN ( DBLE ( ni ( k ) * . 95 * odts ), pni_iau ( k )) endif endif !..Deposition/sublimation of snow/graupel follows Srivastava & Coen !.. (1992). if ( L_qs ( k )) then !++ trude, use different c_cube for snow: c_cubes !           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.) !           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube)) C_snow = C_sqrd + ( tempc + 1 5. ) * ( C_cubes - C_sqrd ) / ( - 3 0. + 1 5. ) C_snow = MAX ( C_sqrd , MIN ( C_snow , C_cubes )) !! -- trude prs_sde ( k ) = C_snow * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) if ( prs_sde ( k ). lt . 0. ) then prs_sde ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_sde ( k ), DBLE ( rate_max )) else prs_sde ( k ) = MIN ( prs_sde ( k ), DBLE ( rate_max )) endif endif if ( L_qg ( k ) . and . ssati ( k ). lt . - eps ) then prg_gde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * N0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 )) if ( prg_gde ( k ). lt . 0. ) then prg_gde ( k ) = MAX ( DBLE ( - rg ( k ) * odts ), prg_gde ( k ), DBLE ( rate_max )) else prg_gde ( k ) = MIN ( prg_gde ( k ), DBLE ( rate_max )) endif endif !..Snow collecting cloud ice.  In CE, assume Di<<Ds and vti=~0. if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = MAX ( DBLE ( D0i ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi if ( rs ( k ). ge . r_s ( 1 )) then prs_sci ( k ) = t1_qs_qi * rhof ( k ) * Ef_si * ri ( k ) * smoe ( k ) pni_sci ( k ) = prs_sci ( k ) * oxmi endif !..Rain collecting cloud ice.  In CE, assume Di<<Dr and vti=~0. if ( rr ( k ). ge . r_r ( 1 ) . and . mvd_r ( k ). gt . 4. * xDi ) then lamr = 1. / ilamr ( k ) pri_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ri ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) pnr_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & ! RAIN2M * (( lamr + fv_r ) ** ( - cre ( 9 ))) pni_rci ( k ) = pri_rci ( k ) * oxmi prr_rci ( k ) = rhof ( k ) * t2_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 8 ))) prr_rci ( k ) = MIN ( DBLE ( rr ( k ) * odts ), prr_rci ( k )) prg_rci ( k ) = pri_rci ( k ) + prr_rci ( k ) endif endif !..Ice multiplication from rime-splinters (Hallet & Mossop 1974). if ( prg_gcw ( k ). gt . eps . and . tempc . gt . - 8.0 ) then tf = 0. if ( tempc . ge . - 5.0 . and . tempc . lt . - 3.0 ) then tf = 0.5 * ( - 3.0 - tempc ) elseif ( tempc . gt . - 8.0 . and . tempc . lt . - 5.0 ) then tf = 0.33333333 * ( 8.0 + tempc ) endif pni_ihm ( k ) = 3.5E8 * tf * prg_gcw ( k ) pri_ihm ( k ) = xm0i * pni_ihm ( k ) prs_ihm ( k ) = prs_scw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) prg_ihm ( k ) = prg_gcw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) endif !..A portion of rimed snow converts to graupel but some remains snow. !.. Interp from 5 to 75% as riming factor increases from 5.0 to 30.0 !.. 0.028 came from (.75-.05)/(30.-5.).  This remains ad-hoc and should !.. be revisited. if ( prs_scw ( k ). gt . 5.0 * prs_sde ( k ) . and . & prs_sde ( k ). gt . eps ) then r_frac = MIN ( 3 0.0D0 , prs_scw ( k ) / prs_sde ( k )) g_frac = MIN ( 0.75 , 0.05 + ( r_frac - 5. ) * . 028 ) vts_boost ( k ) = MIN ( 1.5 , 1.1 + ( r_frac - 5. ) * . 016 ) prg_scw ( k ) = g_frac * prs_scw ( k ) prs_scw ( k ) = ( 1. - g_frac ) * prs_scw ( k ) endif else !..Melt snow and graupel and enhance from collisions with liquid. !.. We also need to sublimate snow and graupel if subsaturated. if ( L_qs ( k )) then prr_sml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * ( t1_qs_me * smo1 ( k ) + t2_qs_me * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) prr_sml ( k ) = prr_sml ( k ) + 421 8. * olfus * tempc & * ( prr_rcs ( k ) + prs_scw ( k )) prr_sml ( k ) = MIN ( DBLE ( rs ( k ) * odts ), MAX ( 0.D0 , prr_sml ( k ))) pnr_sml ( k ) = smo0 ( k ) / rs ( k ) * prr_sml ( k ) * 1 0.0 ** ( - 0.75 * tempc ) ! RAIN2M pnr_sml ( k ) = MIN ( DBLE ( smo0 ( k ) * odts ), pnr_sml ( k )) if ( tempc . gt . 3.5 . or . rs ( k ). lt . 0.005E-3 ) pnr_sml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then !++ trude, use different c_cube for snow: c_cubes !           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.) !           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube)) !            prs_sde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs & prs_sde ( k ) = C_cubes * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) ! -- trude prs_sde ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_sde ( k )) endif endif if ( L_qg ( k )) then prr_gml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * N0_g ( k ) * ( t1_qg_me * ilamg ( k ) ** cge ( 10 ) & + t2_qg_me * rhof2 ( k ) * vsc2 ( k ) * ilamg ( k ) ** cge ( 11 )) !-GT       prr_gml(k) = prr_gml(k) + 4218.*olfus*tempc & !-GT                               * (prr_rcg(k)+prg_gcw(k)) prr_gml ( k ) = MIN ( DBLE ( rg ( k ) * odts ), MAX ( 0.D0 , prr_gml ( k ))) pnr_gml ( k ) = N0_g ( k ) * cgg ( 2 ) * ilamg ( k ) ** cge ( 2 ) / rg ( k ) & ! RAIN2M * prr_gml ( k ) * 1 0.0 ** ( - 1.5 * tempc ) if ( tempc . gt . 7.5 . or . rg ( k ). lt . 0.005E-3 ) pnr_gml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then prg_gde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * N0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 )) prg_gde ( k ) = MAX ( DBLE ( - rg ( k ) * odts ), prg_gde ( k )) endif endif !.. This change will be required if users run adaptive time step that !.. results in delta-t that is generally too long to allow cloud water !.. collection by snow/graupel above melting temperature. !.. Credit to Bjorn-Egil Nygaard for discovering. if ( dt . gt . 12 0. ) then prr_rcw ( k ) = prr_rcw ( k ) + prs_scw ( k ) + prg_gcw ( k ) prs_scw ( k ) = 0. prg_gcw ( k ) = 0. endif endif enddo endif !+---+-----------------------------------------------------------------+ !..Ensure we do not deplete more hydrometeor species than exists. !+---+-----------------------------------------------------------------+ do k = kts , kte !..If ice supersaturated, ensure sum of depos growth terms does not !.. deplete more vapor than possibly exists.  If subsaturated, limit !.. sum of sublimation terms such that vapor does not reproduce ice !.. supersat again. sump = pri_inu ( k ) + pri_ide ( k ) + prs_ide ( k ) & + prs_sde ( k ) + prg_gde ( k ) rate_max = ( qv ( k ) - qvsi ( k )) * odts * 0.999 if ( ( sump . gt . eps . and . sump . gt . rate_max ) . or . & ( sump . lt . - eps . and . sump . lt . rate_max ) ) then ratio = rate_max / sump pri_inu ( k ) = pri_inu ( k ) * ratio pri_ide ( k ) = pri_ide ( k ) * ratio pni_ide ( k ) = pni_ide ( k ) * ratio prs_ide ( k ) = prs_ide ( k ) * ratio prs_sde ( k ) = prs_sde ( k ) * ratio prg_gde ( k ) = prg_gde ( k ) * ratio endif !..Cloud water conservation. sump = - prr_wau ( k ) - pri_wfz ( k ) - prr_rcw ( k ) & - prs_scw ( k ) - prg_scw ( k ) - prg_gcw ( k ) rate_max = - rc ( k ) * odts if ( sump . lt . rate_max . and . L_qc ( k )) then ratio = rate_max / sump prr_wau ( k ) = prr_wau ( k ) * ratio pri_wfz ( k ) = pri_wfz ( k ) * ratio prr_rcw ( k ) = prr_rcw ( k ) * ratio prs_scw ( k ) = prs_scw ( k ) * ratio prg_scw ( k ) = prg_scw ( k ) * ratio prg_gcw ( k ) = prg_gcw ( k ) * ratio endif !..Cloud ice conservation. sump = pri_ide ( k ) - prs_iau ( k ) - prs_sci ( k ) & - pri_rci ( k ) rate_max = - ri ( k ) * odts if ( sump . lt . rate_max . and . L_qi ( k )) then ratio = rate_max / sump pri_ide ( k ) = pri_ide ( k ) * ratio prs_iau ( k ) = prs_iau ( k ) * ratio prs_sci ( k ) = prs_sci ( k ) * ratio pri_rci ( k ) = pri_rci ( k ) * ratio endif !..Rain conservation. sump = - prg_rfz ( k ) - pri_rfz ( k ) - prr_rci ( k ) & + prr_rcs ( k ) + prr_rcg ( k ) rate_max = - rr ( k ) * odts if ( sump . lt . rate_max . and . L_qr ( k )) then ratio = rate_max / sump prg_rfz ( k ) = prg_rfz ( k ) * ratio pri_rfz ( k ) = pri_rfz ( k ) * ratio prr_rci ( k ) = prr_rci ( k ) * ratio prr_rcs ( k ) = prr_rcs ( k ) * ratio prr_rcg ( k ) = prr_rcg ( k ) * ratio endif !..Snow conservation. sump = prs_sde ( k ) - prs_ihm ( k ) - prr_sml ( k ) & + prs_rcs ( k ) rate_max = - rs ( k ) * odts if ( sump . lt . rate_max . and . L_qs ( k )) then ratio = rate_max / sump prs_sde ( k ) = prs_sde ( k ) * ratio prs_ihm ( k ) = prs_ihm ( k ) * ratio prr_sml ( k ) = prr_sml ( k ) * ratio prs_rcs ( k ) = prs_rcs ( k ) * ratio endif !..Graupel conservation. sump = prg_gde ( k ) - prg_ihm ( k ) - prr_gml ( k ) & + prg_rcg ( k ) rate_max = - rg ( k ) * odts if ( sump . lt . rate_max . and . L_qg ( k )) then ratio = rate_max / sump prg_gde ( k ) = prg_gde ( k ) * ratio prg_ihm ( k ) = prg_ihm ( k ) * ratio prr_gml ( k ) = prr_gml ( k ) * ratio prg_rcg ( k ) = prg_rcg ( k ) * ratio endif !..Re-enforce proper mass conservation for subsequent elements in case !.. any of the above terms were altered.  Thanks P. Blossey. 2009Sep28 pri_ihm ( k ) = prs_ihm ( k ) + prg_ihm ( k ) ratio = MIN ( ABS ( prr_rcg ( k )), ABS ( prg_rcg ( k )) ) prr_rcg ( k ) = ratio * SIGN ( 1.0 , SNGL ( prr_rcg ( k ))) prg_rcg ( k ) = - prr_rcg ( k ) if ( temp ( k ). gt . T_0 ) then ratio = MIN ( ABS ( prr_rcs ( k )), ABS ( prs_rcs ( k )) ) prr_rcs ( k ) = ratio * SIGN ( 1.0 , SNGL ( prr_rcs ( k ))) prs_rcs ( k ) = - prr_rcs ( k ) endif enddo !+---+-----------------------------------------------------------------+ !..Calculate tendencies of all species but constrain the number of ice !.. to reasonable values. !+---+-----------------------------------------------------------------+ do k = kts , kte orho = 1. / rho ( k ) lfus2 = lsub - lvap ( k ) !..Water vapor tendency qvten ( k ) = qvten ( k ) + ( - pri_inu ( k ) - pri_ide ( k ) & - prs_ide ( k ) - prs_sde ( k ) - prg_gde ( k )) & * orho !..Cloud water tendency qcten ( k ) = qcten ( k ) + ( - prr_wau ( k ) - pri_wfz ( k ) & - prr_rcw ( k ) - prs_scw ( k ) - prg_scw ( k ) & - prg_gcw ( k )) & * orho !..Cloud ice mixing ratio tendency qiten ( k ) = qiten ( k ) + ( pri_inu ( k ) + pri_ihm ( k ) & + pri_wfz ( k ) + pri_rfz ( k ) + pri_ide ( k ) & - prs_iau ( k ) - prs_sci ( k ) - pri_rci ( k )) & * orho !..Cloud ice number tendency. niten ( k ) = niten ( k ) + ( pni_inu ( k ) + pni_ihm ( k ) & + pni_wfz ( k ) + pni_rfz ( k ) + pni_ide ( k ) & - pni_iau ( k ) - pni_sci ( k ) - pni_rci ( k )) & * orho !..Cloud ice mass/number balance; keep mass-wt mean size between !.. 20 and 300 microns.  Also no more than 250 xtals per liter. xri = MAX ( R1 ,( qi1d ( k ) + qiten ( k ) * dtsave ) * rho ( k )) xni = MAX ( R2 ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xri . gt . R1 ) then lami = ( am_i * cig ( 2 ) * oig1 * xni / xri ) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 xni = MIN ( 25 0.D3 , cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i ) niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 xni = cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho endif else niten ( k ) = - ni1d ( k ) * odts endif xni = MAX ( 0. ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xni . gt . 25 0.E3 ) & niten ( k ) = ( 25 0.E3 - ni1d ( k ) * rho ( k )) * odts * orho !..Rain tendency qrten ( k ) = qrten ( k ) + ( prr_wau ( k ) + prr_rcw ( k ) & + prr_sml ( k ) + prr_gml ( k ) + prr_rcs ( k ) & + prr_rcg ( k ) - prg_rfz ( k ) & - pri_rfz ( k ) - prr_rci ( k )) & * orho !..Rain number tendency nrten ( k ) = nrten ( k ) + ( pnr_wau ( k ) + pnr_sml ( k ) + pnr_gml ( k ) & - ( pnr_rfz ( k ) + pnr_rcr ( k ) + pnr_rcg ( k ) & + pnr_rcs ( k ) + pnr_rci ( k )) ) & * orho !..Rain mass/number balance; keep median volume diameter between !.. 37 microns (D0r*0.75) and 2.5 mm. xrr = MAX ( R1 ,( qr1d ( k ) + qrten ( k ) * dtsave ) * rho ( k )) xnr = MAX ( R2 ,( nr1d ( k ) + nrten ( k ) * dtsave ) * rho ( k )) if ( xrr . gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * xnr / xrr ) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho endif else qrten ( k ) = - qr1d ( k ) * odts nrten ( k ) = - nr1d ( k ) * odts endif !..Snow tendency qsten ( k ) = qsten ( k ) + ( prs_iau ( k ) + prs_sde ( k ) & + prs_sci ( k ) + prs_scw ( k ) + prs_rcs ( k ) & + prs_ide ( k ) - prs_ihm ( k ) - prr_sml ( k )) & * orho !..Graupel tendency qgten ( k ) = qgten ( k ) + ( prg_scw ( k ) + prg_rfz ( k ) & + prg_gde ( k ) + prg_rcg ( k ) + prg_gcw ( k ) & + prg_rci ( k ) + prg_rcs ( k ) - prg_ihm ( k ) & - prr_gml ( k )) & * orho !..Temperature tendency if ( temp ( k ). lt . T_0 ) then tten ( k ) = tten ( k ) & + ( lsub * ocp ( k ) * ( pri_inu ( k ) + pri_ide ( k ) & + prs_ide ( k ) + prs_sde ( k ) & + prg_gde ( k )) & + lfus2 * ocp ( k ) * ( pri_wfz ( k ) + pri_rfz ( k ) & + prg_rfz ( k ) + prs_scw ( k ) & + prg_scw ( k ) + prg_gcw ( k ) & + prg_rcs ( k ) + prs_rcs ( k ) & + prr_rci ( k ) + prg_rcg ( k )) & ) * orho * ( 1 - IFDRY ) else tten ( k ) = tten ( k ) & + ( lfus * ocp ( k ) * ( - prr_sml ( k ) - prr_gml ( k ) & - prr_rcg ( k ) - prr_rcs ( k )) & + lsub * ocp ( k ) * ( prs_sde ( k ) + prg_gde ( k )) & ) * orho * ( 1 - IFDRY ) endif enddo !+---+-----------------------------------------------------------------+ !..Update variables for TAU+1 before condensation & sedimention. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) + DT * tten ( k ) otemp = 1. / temp ( k ) tempc = temp ( k ) - 27 3.15 qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) lvt2 ( k ) = lvap ( k ) * lvap ( k ) * ocp ( k ) * oRv * otemp * otemp if (( qc1d ( k ) + qcten ( k ) * DT ) . gt . R1 ) then rc ( k ) = ( qc1d ( k ) + qcten ( k ) * DT ) * rho ( k ) L_qc ( k ) = . true . else rc ( k ) = R1 L_qc ( k ) = . false . endif if (( qi1d ( k ) + qiten ( k ) * DT ) . gt . R1 ) then ri ( k ) = ( qi1d ( k ) + qiten ( k ) * DT ) * rho ( k ) ni ( k ) = MAX ( R2 , ( ni1d ( k ) + niten ( k ) * DT ) * rho ( k )) L_qi ( k ) = . true . else ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif if (( qr1d ( k ) + qrten ( k ) * DT ) . gt . R1 ) then rr ( k ) = ( qr1d ( k ) + qrten ( k ) * DT ) * rho ( k ) nr ( k ) = MAX ( R2 , ( nr1d ( k ) + nrten ( k ) * DT ) * rho ( k )) L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if (( qs1d ( k ) + qsten ( k ) * DT ) . gt . R1 ) then rs ( k ) = ( qs1d ( k ) + qsten ( k ) * DT ) * rho ( k ) L_qs ( k ) = . true . else rs ( k ) = R1 L_qs ( k ) = . false . endif if (( qg1d ( k ) + qgten ( k ) * DT ) . gt . R1 ) then rg ( k ) = ( qg1d ( k ) + qgten ( k ) * DT ) * rho ( k ) L_qg ( k ) = . true . else rg ( k ) = R1 L_qg ( k ) = . false . endif enddo !+---+-----------------------------------------------------------------+ !..With tendency-updated mixing ratios, recalculate snow moments and !.. intercepts/slopes of graupel and rain. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = MIN ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+bv_s (th) moment.  Useful for sedimentation. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 14 ) & + sa ( 4 ) * tc0 * cse ( 14 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 14 ) * cse ( 14 ) + sa ( 7 ) * tc0 * tc0 * cse ( 14 ) & + sa ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 14 ) + sb ( 4 ) * tc0 * cse ( 14 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 14 ) * cse ( 14 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 14 ) + sb ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) smod ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ N0_min = gonv_max do k = kte , kts , - 1 if ( temp ( k ). lt . 27 0.65 . and . L_qr ( k ) . and . mvd_r ( k ). gt . 10 0.E-6 ) then xslw1 = 4.01 + alog10 ( mvd_r ( k )) else xslw1 = 0.01 endif ygra1 = 4.31 + alog10 ( max ( 5.E-5 , rg ( k ))) zans1 = 3.1 + ( 10 0. / ( 30 0. * xslw1 * ygra1 / ( 1 0. / xslw1 + 1. + 0.25 * ygra1 ) + 3 0. + 1 0. * ygra1 )) N0_exp = 1 0. ** ( zans1 ) N0_exp = MAX ( DBLE ( gonv_min ), MIN ( N0_exp , DBLE ( gonv_max ))) N0_min = MIN ( N0_exp , N0_min ) N0_exp = N0_min lam_exp = ( N0_exp * am_g * cgg ( 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = N0_exp / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !+---+-----------------------------------------------------------------+ !..Cloud water condensation and evaporation.  Newly formulated using !.. Newton-Raphson iterations (3 should suffice) as provided by B. Hall. !+---+-----------------------------------------------------------------+ do k = kts , kte if ( ( ssatw ( k ). gt . eps ) . or . ( ssatw ( k ). lt . - eps . and . & L_qc ( k )) ) then clap = ( qv ( k ) - qvs ( k )) / ( 1. + lvt2 ( k ) * qvs ( k )) do n = 1 , 3 fcd = qvs ( k ) * EXP ( lvt2 ( k ) * clap ) - qv ( k ) + clap dfcd = qvs ( k ) * lvt2 ( k ) * EXP ( lvt2 ( k ) * clap ) + 1. clap = clap - fcd / dfcd enddo xrc = rc ( k ) + clap if ( xrc . gt . 0.0 ) then prw_vcd ( k ) = clap * odt else prw_vcd ( k ) = - rc ( k ) / rho ( k ) * odts endif qcten ( k ) = qcten ( k ) + prw_vcd ( k ) qvten ( k ) = qvten ( k ) - prw_vcd ( k ) tten ( k ) = tten ( k ) + lvap ( k ) * ocp ( k ) * prw_vcd ( k ) * ( 1 - IFDRY ) rc ( k ) = MAX ( R1 , ( qc1d ( k ) + DT * qcten ( k )) * rho ( k )) qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. endif enddo !+---+-----------------------------------------------------------------+ !.. If still subsaturated, allow rain to evaporate, following !.. Srivastava & Coen (1992). !+---+-----------------------------------------------------------------+ do k = kts , kte if ( ( ssatw ( k ). lt . - eps ) . and . L_qr ( k ) & . and . (. not .( prw_vcd ( k ). gt . 0. )) ) then tempc = temp ( k ) - 27 3.15 otemp = 1. / temp ( k ) rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) rvs = rho ( k ) * qvs ( k ) rvs_p = rvs * otemp * ( lvap ( k ) * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lvap ( k ) * otemp * oRv - 1. ) & * otemp * ( lvap ( k ) * otemp * oRv - 1. ) & + ( - 2. * lvap ( k ) * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lvap ( k ) * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = MAX ( 1.E-9 , alphsc ) xsat = MIN ( - 1.E-9 , ssatw ( k )) t1_evap = 2. * PI2 * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) lamr = 1. / ilamr ( k ) !..Rapidly eliminate near zero values when low humidity (<95%) if ( qv ( k ) / qvs ( k ) . lt . 0.95 . AND . rr ( k ) / rho ( k ). le . 1.E-8 ) then prv_rev ( k ) = rr ( k ) / rho ( k ) * odts else prv_rev ( k ) = t1_evap * diffu ( k ) * ( - ssatw ( k )) * N0_r ( k ) * rvs & * ( t1_qr_ev * ilamr ( k ) ** cre ( 10 ) & + t2_qr_ev * vsc2 ( k ) * rhof2 ( k ) * (( lamr + 0.5 * fv_r ) ** ( - cre ( 11 )))) rate_max = MIN (( rr ( k ) / rho ( k ) * odts ), ( qvs ( k ) - qv ( k )) * odts ) prv_rev ( k ) = MIN ( DBLE ( rate_max ), prv_rev ( k ) / rho ( k )) endif pnr_rev ( k ) = MIN ( DBLE ( nr ( k ) * 0.99 / rho ( k ) * odts ), & ! RAIN2M prv_rev ( k ) * nr ( k ) / rr ( k )) qrten ( k ) = qrten ( k ) - prv_rev ( k ) qvten ( k ) = qvten ( k ) + prv_rev ( k ) nrten ( k ) = nrten ( k ) - pnr_rev ( k ) tten ( k ) = tten ( k ) - lvap ( k ) * ocp ( k ) * prv_rev ( k ) * ( 1 - IFDRY ) rr ( k ) = MAX ( R1 , ( qr1d ( k ) + DT * qrten ( k )) * rho ( k )) qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) nr ( k ) = MAX ( R2 , ( nr1d ( k ) + DT * nrten ( k )) * rho ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) endif enddo !+---+-----------------------------------------------------------------+ !..Find max terminal fallspeed (distribution mass-weighted mean !.. velocity) and use it to determine if we need to split the timestep !.. (var nstep>1).  Either way, only bother to do sedimentation below !.. 1st level that contains any sedimenting particles (k=ksed1 on down). !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !+---+-----------------------------------------------------------------+ nstep = 0 onstep (:) = 1.0 ksed1 (:) = 1 do k = kte + 1 , kts , - 1 vtrk ( k ) = 0. vtnrk ( k ) = 0. vtik ( k ) = 0. vtnik ( k ) = 0. vtsk ( k ) = 0. vtgk ( k ) = 0. enddo do k = kte , kts , - 1 vtr = 0. rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) if ( rr ( k ). gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr vtr = rhof ( k ) * av_r * crg ( 6 ) * org3 * lamr ** cre ( 3 ) & * (( lamr + fv_r ) ** ( - cre ( 6 ))) vtrk ( k ) = vtr ! First below is technically correct: !         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                 & !                     *((lamr+fv_r)**(-cre(5))) ! Test: make number fall faster (but still slower than mass) ! Goal: less prominent size sorting vtr = rhof ( k ) * av_r * crg ( 7 ) / crg ( 12 ) * lamr ** cre ( 12 ) & * (( lamr + fv_r ) ** ( - cre ( 7 ))) vtnrk ( k ) = vtr else vtrk ( k ) = vtrk ( k + 1 ) vtnrk ( k ) = vtnrk ( k + 1 ) endif if ( MAX ( vtrk ( k ), vtnrk ( k )) . gt . 1.E-3 ) then ksed1 ( 1 ) = MAX ( ksed1 ( 1 ), k ) delta_tp = dzq ( k ) / ( MAX ( vtrk ( k ), vtnrk ( k ))) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 1 ) . eq . kte ) ksed1 ( 1 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 1 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then nstep = 0 do k = kte , kts , - 1 vti = 0. if ( ri ( k ). gt . R1 ) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami vti = rhof ( k ) * av_i * cig ( 3 ) * oig2 * ilami ** bv_i vtik ( k ) = vti ! First below is technically correct: !          vti = rhof(k)*av_i*cig(4)*oig1 * ilami**bv_i ! Goal: less prominent size sorting vti = rhof ( k ) * av_i * cig ( 6 ) / cig ( 7 ) * ilami ** bv_i vtnik ( k ) = vti else vtik ( k ) = vtik ( k + 1 ) vtnik ( k ) = vtnik ( k + 1 ) endif if ( vtik ( k ) . gt . 1.E-3 ) then ksed1 ( 2 ) = MAX ( ksed1 ( 2 ), k ) delta_tp = dzq ( k ) / vtik ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 2 ) . eq . kte ) ksed1 ( 2 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 2 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ nstep = 0 do k = kte , kts , - 1 vts = 0. if ( rs ( k ). gt . R1 ) then xDs = smoc ( k ) / smob ( k ) Mrat = 1. / xDs ils1 = 1. / ( Mrat * Lam0 + fv_s ) ils2 = 1. / ( Mrat * Lam1 + fv_s ) t1_vts = Kap0 * csg ( 4 ) * ils1 ** cse ( 4 ) t2_vts = Kap1 * Mrat ** mu_s * csg ( 10 ) * ils2 ** cse ( 10 ) ils1 = 1. / ( Mrat * Lam0 ) ils2 = 1. / ( Mrat * Lam1 ) t3_vts = Kap0 * csg ( 1 ) * ils1 ** cse ( 1 ) t4_vts = Kap1 * Mrat ** mu_s * csg ( 7 ) * ils2 ** cse ( 7 ) vts = rhof ( k ) * av_s * ( t1_vts + t2_vts ) / ( t3_vts + t4_vts ) if ( temp ( k ). gt . T_0 ) then vtsk ( k ) = MAX ( vts * vts_boost ( k ), vtrk ( k )) else vtsk ( k ) = vts * vts_boost ( k ) endif else vtsk ( k ) = vtsk ( k + 1 ) endif if ( vtsk ( k ) . gt . 1.E-3 ) then ksed1 ( 3 ) = MAX ( ksed1 ( 3 ), k ) delta_tp = dzq ( k ) / vtsk ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 3 ) . eq . kte ) ksed1 ( 3 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 3 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ nstep = 0 do k = kte , kts , - 1 vtg = 0. if ( rg ( k ). gt . R1 ) then vtg = rhof ( k ) * av_g * cgg ( 6 ) * ogg3 * ilamg ( k ) ** bv_g if ( temp ( k ). gt . T_0 ) then vtgk ( k ) = MAX ( vtg , vtrk ( k )) else vtgk ( k ) = vtg endif else vtgk ( k ) = vtgk ( k + 1 ) endif if ( vtgk ( k ) . gt . 1.E-3 ) then ksed1 ( 4 ) = MAX ( ksed1 ( 4 ), k ) delta_tp = dzq ( k ) / vtgk ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 4 ) . eq . kte ) ksed1 ( 4 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 4 ) = 1. / REAL ( nstep ) endif !+---+-----------------------------------------------------------------+ !..Sedimentation of mixing ratio is the integral of v(D)*m(D)*N(D)*dD, !.. whereas neglect m(D) term for number concentration.  Therefore, !.. cloud ice has proper differential sedimentation. !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 1 )) do n = 1 , nstep do k = kte , kts , - 1 sed_r ( k ) = vtrk ( k ) * rr ( k ) sed_n ( k ) = vtnrk ( k ) * nr ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) - sed_r ( k ) * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) - sed_n ( k ) * odzq * onstep ( 1 ) * orho rr ( k ) = MAX ( R1 , rr ( k ) - sed_r ( k ) * odzq * DT * onstep ( 1 )) nr ( k ) = MAX ( R2 , nr ( k ) - sed_n ( k ) * odzq * DT * onstep ( 1 )) do k = ksed1 ( 1 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 1 ) * orho rr ( k ) = MAX ( R1 , rr ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * DT * onstep ( 1 )) nr ( k ) = MAX ( R2 , nr ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 1 )) enddo if ( rr ( kts ). gt . R1 * 1 0. ) & pptrain = pptrain + sed_r ( kts ) * DT * onstep ( 1 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 2 )) do n = 1 , nstep do k = kte , kts , - 1 sed_i ( k ) = vtik ( k ) * ri ( k ) sed_n ( k ) = vtnik ( k ) * ni ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) - sed_i ( k ) * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) - sed_n ( k ) * odzq * onstep ( 2 ) * orho ri ( k ) = MAX ( R1 , ri ( k ) - sed_i ( k ) * odzq * DT * onstep ( 2 )) ni ( k ) = MAX ( R2 , ni ( k ) - sed_n ( k ) * odzq * DT * onstep ( 2 )) do k = ksed1 ( 2 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 2 ) * orho ri ( k ) = MAX ( R1 , ri ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * DT * onstep ( 2 )) ni ( k ) = MAX ( R2 , ni ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 2 )) enddo if ( ri ( kts ). gt . R1 * 1 0. ) & pptice = pptice + sed_i ( kts ) * DT * onstep ( 2 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 3 )) do n = 1 , nstep do k = kte , kts , - 1 sed_s ( k ) = vtsk ( k ) * rs ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) - sed_s ( k ) * odzq * onstep ( 3 ) * orho rs ( k ) = MAX ( R1 , rs ( k ) - sed_s ( k ) * odzq * DT * onstep ( 3 )) do k = ksed1 ( 3 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * onstep ( 3 ) * orho rs ( k ) = MAX ( R1 , rs ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * DT * onstep ( 3 )) enddo if ( rs ( kts ). gt . R1 * 1 0. ) & pptsnow = pptsnow + sed_s ( kts ) * DT * onstep ( 3 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 4 )) do n = 1 , nstep do k = kte , kts , - 1 sed_g ( k ) = vtgk ( k ) * rg ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) - sed_g ( k ) * odzq * onstep ( 4 ) * orho rg ( k ) = MAX ( R1 , rg ( k ) - sed_g ( k ) * odzq * DT * onstep ( 4 )) do k = ksed1 ( 4 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * onstep ( 4 ) * orho rg ( k ) = MAX ( R1 , rg ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * DT * onstep ( 4 )) enddo if ( rg ( kts ). gt . R1 * 1 0. ) & pptgraul = pptgraul + sed_g ( kts ) * DT * onstep ( 4 ) enddo !+---+-----------------------------------------------------------------+ !.. Instantly melt any cloud ice into cloud water if above 0C and !.. instantly freeze any cloud water found below HGFR. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte xri = MAX ( 0.0 , qi1d ( k ) + qiten ( k ) * DT ) if ( ( temp ( k ). gt . T_0 ) . and . ( xri . gt . 0.0 ) ) then qcten ( k ) = qcten ( k ) + xri * odt qiten ( k ) = qiten ( k ) - xri * odt niten ( k ) = - ni1d ( k ) * odt tten ( k ) = tten ( k ) - lfus * ocp ( k ) * xri * odt * ( 1 - IFDRY ) endif xrc = MAX ( 0.0 , qc1d ( k ) + qcten ( k ) * DT ) if ( ( temp ( k ). lt . HGFR ) . and . ( xrc . gt . 0.0 ) ) then lfus2 = lsub - lvap ( k ) qiten ( k ) = qiten ( k ) + xrc * odt niten ( k ) = niten ( k ) + xrc / xm0i * odt qcten ( k ) = qcten ( k ) - xrc * odt tten ( k ) = tten ( k ) + lfus2 * ocp ( k ) * xrc * odt * ( 1 - IFDRY ) endif enddo endif !+---+-----------------------------------------------------------------+ !.. All tendencies computed, apply and pass back final values to parent. !+---+-----------------------------------------------------------------+ do k = kts , kte t1d ( k ) = t1d ( k ) + tten ( k ) * DT qv1d ( k ) = MAX ( 1.E-10 , qv1d ( k ) + qvten ( k ) * DT ) qc1d ( k ) = qc1d ( k ) + qcten ( k ) * DT if ( qc1d ( k ) . le . R1 ) qc1d ( k ) = 0.0 qi1d ( k ) = qi1d ( k ) + qiten ( k ) * DT ni1d ( k ) = MAX ( R2 / rho ( k ), ni1d ( k ) + niten ( k ) * DT ) if ( qi1d ( k ) . le . R1 ) then qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 else lami = ( am_i * cig ( 2 ) * oig1 * ni1d ( k ) / qi1d ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 endif ni1d ( k ) = MIN ( cig ( 1 ) * oig2 * qi1d ( k ) / am_i * lami ** bm_i , & 25 0.D3 / rho ( k )) endif qr1d ( k ) = qr1d ( k ) + qrten ( k ) * DT nr1d ( k ) = MAX ( R2 / rho ( k ), nr1d ( k ) + nrten ( k ) * DT ) if ( qr1d ( k ) . le . R1 ) then qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 else lamr = ( am_r * crg ( 3 ) * org2 * nr1d ( k ) / qr1d ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 endif lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr1d ( k ) = crg ( 2 ) * org3 * qr1d ( k ) * lamr ** bm_r / am_r endif qs1d ( k ) = qs1d ( k ) + qsten ( k ) * DT if ( qs1d ( k ) . le . R1 ) qs1d ( k ) = 0.0 qg1d ( k ) = qg1d ( k ) + qgten ( k ) * DT if ( qg1d ( k ) . le . R1 ) qg1d ( k ) = 0.0 enddo end subroutine mp_thompson","tags":"","loc":"proc/mp_thompson.html"},{"title":"qi_aut_qs – Inference-Engine","text":"public subroutine qi_aut_qs() Arguments None Calls proc~~qi_aut_qs~~CallsGraph proc~qi_aut_qs qi_aut_qs sngl sngl proc~qi_aut_qs->sngl proc~gammp GAMMP proc~qi_aut_qs->proc~gammp dexp dexp proc~qi_aut_qs->dexp proc~gser GSER proc~gammp->proc~gser proc~gcf GCF proc~gammp->proc~gcf proc~gammln GAMMLN proc~gser->proc~gammln proc~gcf->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code qi_aut_qs Source Code subroutine qi_aut_qs implicit none !..Local variables INTEGER :: i , j , n2 DOUBLE PRECISION , DIMENSION ( nbi ) :: N_i DOUBLE PRECISION :: N0_i , lami , Di_mean , t1 , t2 REAL :: xlimit_intg !+---+ do j = 1 , ntb_i1 do i = 1 , ntb_i lami = ( am_i * cig ( 2 ) * oig1 * Nt_i ( j ) / r_i ( i )) ** obmi Di_mean = ( bm_i + mu_i + 1. ) / lami N0_i = Nt_i ( j ) * oig1 * lami ** cie ( 1 ) t1 = 0.0d0 t2 = 0.0d0 if ( SNGL ( Di_mean ) . gt . 5. * D0s ) then t1 = r_i ( i ) t2 = Nt_i ( j ) tpi_ide ( i , j ) = 0.0D0 elseif ( SNGL ( Di_mean ) . lt . D0i ) then t1 = 0.0D0 t2 = 0.0D0 tpi_ide ( i , j ) = 1.0D0 else xlimit_intg = lami * D0s tpi_ide ( i , j ) = GAMMP ( mu_i + 2.0 , xlimit_intg ) * 1.0D0 do n2 = 1 , nbi N_i ( n2 ) = N0_i * Di ( n2 ) ** mu_i * DEXP ( - lami * Di ( n2 )) * dti ( n2 ) if ( Di ( n2 ). ge . D0s ) then t1 = t1 + N_i ( n2 ) * am_i * Di ( n2 ) ** bm_i t2 = t2 + N_i ( n2 ) endif enddo endif tps_iaus ( i , j ) = t1 tni_iaus ( i , j ) = t2 enddo enddo end subroutine qi_aut_qs","tags":"","loc":"proc/qi_aut_qs.html"},{"title":"qr_acr_qg – Inference-Engine","text":"public subroutine qr_acr_qg() Arguments None Calls proc~~qr_acr_qg~~CallsGraph proc~qr_acr_qg qr_acr_qg dexp dexp proc~qr_acr_qg->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code qr_acr_qg Source Code subroutine qr_acr_qg implicit none !..Local variables INTEGER :: i , j , k , m , n , n2 INTEGER :: km , km_s , km_e DOUBLE PRECISION , DIMENSION ( nbg ) :: vg , N_g DOUBLE PRECISION , DIMENSION ( nbr ) :: vr , N_r DOUBLE PRECISION :: N0_r , N0_g , lam_exp , lamg , lamr DOUBLE PRECISION :: massg , massr , dvg , dvr , t1 , t2 , z1 , z2 , y1 , y2 logical :: lexist , lopen integer :: good good = 0 INQUIRE ( FILE = \"qr_acr_qg_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN if ( this_image () == 1 ) print * , \"ThompMP: read qr_acr_qg_mpt.dat instead of computing\" OPEN ( 63 , file = \"qr_acr_qg_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tcg_racg READ ( 63 , err = 1234 ) tmr_racg READ ( 63 , err = 1234 ) tcr_gacr READ ( 63 , err = 1234 ) tmg_gacr READ ( 63 , err = 1234 ) tnr_racg READ ( 63 , err = 1234 ) tnr_gacr good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) ENDIF ENDIF if ( good . NE . 1 ) then do n2 = 1 , nbr !        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2)) vr ( n2 ) = - 0.1021 + 4.932E3 * Dr ( n2 ) - 0.9551E6 * Dr ( n2 ) * Dr ( n2 ) & + 0.07934E9 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) & - 0.002362E12 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) enddo do n = 1 , nbg vg ( n ) = av_g * Dg ( n ) ** bv_g enddo !..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for !.. fortran indices.  J. Michalakes, 2009Oct30. ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e ) ! #else km_s = 0 km_e = ntb_r * ntb_r1 - 1 ! #endif !$omp parallel  default(shared) & !$omp private(km,i,j,k,m,n,n2,lam_exp,lamr,N0_r,N_r,lamg,N_g,N0_g,t1,t2,z1,z2,y1,y2,massr,massg,dvg,dvr) & !$omp shared(tcg_racg,tmr_racg,tcr_gacr,tmg_gacr,tnr_racg,tnr_gacr,mu_r,ef_rs,am_s) & !$omp firstprivate(crg,cre,cge,cgg,ore1,oge1,org1,org2,ogg2,ogg1,obmg,obmr) & !$omp firstprivate(km_s,km_e,Dr,Dg,dtg,dtr,vr,vg) !$omp do do km = km_s , km_e m = km / ntb_r1 + 1 k = mod ( km , ntb_r1 ) + 1 lam_exp = ( N0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) enddo do j = 1 , ntb_g do i = 1 , ntb_g1 lam_exp = ( N0g_exp ( i ) * am_g * cgg ( 1 ) / r_g ( j )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg N0_g = N0g_exp ( i ) / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) do n = 1 , nbg N_g ( n ) = N0_g * Dg ( n ) ** mu_g * DEXP ( - lamg * Dg ( n )) * dtg ( n ) enddo t1 = 0.0d0 t2 = 0.0d0 z1 = 0.0d0 z2 = 0.0d0 y1 = 0.0d0 y2 = 0.0d0 do n2 = 1 , nbr massr = am_r * Dr ( n2 ) ** bm_r do n = 1 , nbg massg = am_g * Dg ( n ) ** bm_g dvg = 0.5d0 * (( vr ( n2 ) - vg ( n )) + DABS ( vr ( n2 ) - vg ( n ))) dvr = 0.5d0 * (( vg ( n ) - vr ( n2 )) + DABS ( vg ( n ) - vr ( n2 ))) t1 = t1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * massg * N_g ( n ) * N_r ( n2 ) z1 = z1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * massr * N_g ( n ) * N_r ( n2 ) y1 = y1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * N_g ( n ) * N_r ( n2 ) t2 = t2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * massr * N_g ( n ) * N_r ( n2 ) y2 = y2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * N_g ( n ) * N_r ( n2 ) z2 = z2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * massg * N_g ( n ) * N_r ( n2 ) enddo 97 continue enddo tcg_racg ( i , j , k , m ) = t1 tmr_racg ( i , j , k , m ) = DMIN1 ( z1 , r_r ( m ) * 1.0d0 ) tcr_gacr ( i , j , k , m ) = t2 tmg_gacr ( i , j , k , m ) = z2 tnr_racg ( i , j , k , m ) = y1 tnr_gacr ( i , j , k , m ) = y2 enddo enddo enddo !$omp end do !$omp end parallel IF ( this_image () == 1 ) THEN print * , \"Writing qr_acr_qg_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"qr_acr_qg_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tcg_racg WRITE ( 63 , err = 9234 ) tmr_racg WRITE ( 63 , err = 9234 ) tcr_gacr WRITE ( 63 , err = 9234 ) tmg_gacr WRITE ( 63 , err = 9234 ) tnr_racg WRITE ( 63 , err = 9234 ) tnr_gacr CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , ( \"Error writing qr_acr_qg_mpt.dat\" ) ENDIF endif !..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30). ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_gatherv(tcg_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmg_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! #endif end subroutine qr_acr_qg","tags":"","loc":"proc/qr_acr_qg.html"},{"title":"qr_acr_qs – Inference-Engine","text":"public subroutine qr_acr_qs() Arguments None Calls proc~~qr_acr_qs~~CallsGraph proc~qr_acr_qs qr_acr_qs dexp dexp proc~qr_acr_qs->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code qr_acr_qs Source Code subroutine qr_acr_qs implicit none !..Local variables INTEGER :: i , j , k , m , n , n2 INTEGER :: km , km_s , km_e DOUBLE PRECISION , DIMENSION ( nbr ) :: vr , D1 , N_r DOUBLE PRECISION , DIMENSION ( nbs ) :: vs , N_s DOUBLE PRECISION :: loga_ , a_ , b_ , second , M0 , M2 , M3 , Mrat , oM3 DOUBLE PRECISION :: N0_r , lam_exp , lamr , slam1 , slam2 DOUBLE PRECISION :: dvs , dvr , masss , massr DOUBLE PRECISION :: t1 , t2 , t3 , t4 , z1 , z2 , z3 , z4 DOUBLE PRECISION :: y1 , y2 , y3 , y4 LOGICAL lexist , lopen INTEGER :: good !   LOGICAL, EXTERNAL :: wrf_dm_on_monitor !+---+ !   CALL nl_get_force_read_thompson(1,force_read_thompson) !   CALL nl_get_write_thompson_tables(1,write_thompson_tables) good = 0 INQUIRE ( FILE = \"qr_acr_qs_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN IF ( this_image () == 1 ) print * , \"ThompMP: read qr_acr_qs_mpt.dat instead of computing\" OPEN ( 63 , file = \"qr_acr_qs_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tcs_racs1 READ ( 63 , err = 1234 ) tmr_racs1 READ ( 63 , err = 1234 ) tcs_racs2 READ ( 63 , err = 1234 ) tmr_racs2 READ ( 63 , err = 1234 ) tcr_sacr1 READ ( 63 , err = 1234 ) tms_sacr1 READ ( 63 , err = 1234 ) tcr_sacr2 READ ( 63 , err = 1234 ) tms_sacr2 READ ( 63 , err = 1234 ) tnr_racs1 READ ( 63 , err = 1234 ) tnr_racs2 READ ( 63 , err = 1234 ) tnr_sacr1 READ ( 63 , err = 1234 ) tnr_sacr2 good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) ENDIF ENDIF if ( good . NE . 1 ) then if ( this_image () == 1 ) print * , \"ThompMP: computing qr_acr_qs\" !+---+ do n2 = 1 , nbr !        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2)) vr ( n2 ) = - 0.1021 + 4.932E3 * Dr ( n2 ) - 0.9551E6 * Dr ( n2 ) * Dr ( n2 ) & + 0.07934E9 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) & - 0.002362E12 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) D1 ( n2 ) = ( vr ( n2 ) / av_s ) ** ( 1. / bv_s ) enddo do n = 1 , nbs vs ( n ) = 1.5 * av_s * Ds ( n ) ** bv_s * DEXP ( - fv_s * Ds ( n )) enddo !..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for !.. fortran indices.  J. Michalakes, 2009Oct30. ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e ) ! #else km_s = 0 km_e = ntb_r * ntb_r1 - 1 ! #endif !$omp parallel default(private) & !$omp shared(tcs_racs1,tmr_racs1,tcs_racs2,tmr_racs2,tcr_sacr1,tms_sacr1)& !$omp shared(tcr_sacr2,tms_sacr2,tnr_racs1,tnr_racs2,tnr_sacr1,tnr_sacr2,mu_r,ef_rs,am_s) & !$omp private(second,a_,b_,n2,km,M2,M3,oM3,Mrat,M0,slam1,slam2,i,j,k,m,n,lam_exp,lamr,N0_r,N_r,loga_) & !$omp private(t1,t2,t3,t4,z1,z2,z3,z4,y1,y2,y3,y4,N_s,massr,masss,dvs,dvr) & !$omp firstprivate(km_s,km_e,vr,vs) & !$omp firstprivate(Dr,dtr,dts,Ds,crg,cre,cse,ore1,org2,org1,obmr,oams) !$omp do do km = km_s , km_e m = km / ntb_r1 + 1 k = mod ( km , ntb_r1 ) + 1 lam_exp = ( N0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) enddo do j = 1 , ntb_t do i = 1 , ntb_s !..From the bm_s moment, compute plus one moment.  If we are not !.. using bm_s=2, then we must transform to the pure 2nd moment !.. (variable called \"second\") and then to the bm_s+1 moment. M2 = r_s ( i ) * oams * 1.0d0 if ( bm_s . gt . 2.0 - 1.E-3 . and . bm_s . lt . 2.0 + 1.E-3 ) then loga_ = sa ( 1 ) + sa ( 2 ) * Tc ( j ) + sa ( 3 ) * bm_s & + sa ( 4 ) * Tc ( j ) * bm_s + sa ( 5 ) * Tc ( j ) * Tc ( j ) & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * Tc ( j ) * Tc ( j ) * bm_s & + sa ( 8 ) * Tc ( j ) * bm_s * bm_s + sa ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * Tc ( j ) + sb ( 3 ) * bm_s & + sb ( 4 ) * Tc ( j ) * bm_s + sb ( 5 ) * Tc ( j ) * Tc ( j ) & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * Tc ( j ) * Tc ( j ) * bm_s & + sb ( 8 ) * Tc ( j ) * bm_s * bm_s + sb ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sb ( 10 ) * bm_s * bm_s * bm_s second = ( M2 / a_ ) ** ( 1. / b_ ) else second = M2 endif loga_ = sa ( 1 ) + sa ( 2 ) * Tc ( j ) + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * Tc ( j ) * cse ( 1 ) + sa ( 5 ) * Tc ( j ) * Tc ( j ) & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * Tc ( j ) * Tc ( j ) * cse ( 1 ) & + sa ( 8 ) * Tc ( j ) * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * Tc ( j ) + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * Tc ( j ) * cse ( 1 ) & + sb ( 5 ) * Tc ( j ) * Tc ( j ) + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * Tc ( j ) * Tc ( j ) * cse ( 1 ) + sb ( 8 ) * Tc ( j ) * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) M3 = a_ * second ** b_ oM3 = 1. / M3 Mrat = M2 * ( M2 * oM3 ) * ( M2 * oM3 ) * ( M2 * oM3 ) M0 = ( M2 * oM3 ) ** mu_s slam1 = M2 * oM3 * Lam0 slam2 = M2 * oM3 * Lam1 do n = 1 , nbs N_s ( n ) = Mrat * ( Kap0 * DEXP ( - slam1 * Ds ( n )) & + Kap1 * M0 * Ds ( n ) ** mu_s * DEXP ( - slam2 * Ds ( n ))) * dts ( n ) enddo t1 = 0.0d0 t2 = 0.0d0 t3 = 0.0d0 t4 = 0.0d0 z1 = 0.0d0 z2 = 0.0d0 z3 = 0.0d0 z4 = 0.0d0 y1 = 0.0d0 y2 = 0.0d0 y3 = 0.0d0 y4 = 0.0d0 do n2 = 1 , nbr massr = am_r * Dr ( n2 ) ** bm_r do n = 1 , nbs masss = am_s * Ds ( n ) ** bm_s dvs = 0.5d0 * (( vr ( n2 ) - vs ( n )) + DABS ( vr ( n2 ) - vs ( n ))) dvr = 0.5d0 * (( vs ( n ) - vr ( n2 )) + DABS ( vs ( n ) - vr ( n2 ))) if ( massr . gt . 1.5 * masss ) then t1 = t1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * masss * N_s ( n ) * N_r ( n2 ) z1 = z1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * massr * N_s ( n ) * N_r ( n2 ) y1 = y1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * N_s ( n ) * N_r ( n2 ) else t3 = t3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * masss * N_s ( n ) * N_r ( n2 ) z3 = z3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * massr * N_s ( n ) * N_r ( n2 ) y3 = y3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * N_s ( n ) * N_r ( n2 ) endif if ( massr . gt . 1.5 * masss ) then t2 = t2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * massr * N_s ( n ) * N_r ( n2 ) y2 = y2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * N_s ( n ) * N_r ( n2 ) z2 = z2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * masss * N_s ( n ) * N_r ( n2 ) else t4 = t4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * massr * N_s ( n ) * N_r ( n2 ) y4 = y4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * N_s ( n ) * N_r ( n2 ) z4 = z4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * masss * N_s ( n ) * N_r ( n2 ) endif enddo enddo tcs_racs1 ( i , j , k , m ) = t1 tmr_racs1 ( i , j , k , m ) = DMIN1 ( z1 , r_r ( m ) * 1.0d0 ) tcs_racs2 ( i , j , k , m ) = t3 tmr_racs2 ( i , j , k , m ) = z3 tcr_sacr1 ( i , j , k , m ) = t2 tms_sacr1 ( i , j , k , m ) = z2 tcr_sacr2 ( i , j , k , m ) = t4 tms_sacr2 ( i , j , k , m ) = z4 tnr_racs1 ( i , j , k , m ) = y1 tnr_racs2 ( i , j , k , m ) = y3 tnr_sacr1 ( i , j , k , m ) = y2 tnr_sacr2 ( i , j , k , m ) = y4 enddo enddo enddo !$omp end do !$omp end parallel IF ( this_image () == 1 ) THEN print * , \"Writing qr_acr_qs_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"qr_acr_qs_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tcs_racs1 WRITE ( 63 , err = 9234 ) tmr_racs1 WRITE ( 63 , err = 9234 ) tcs_racs2 WRITE ( 63 , err = 9234 ) tmr_racs2 WRITE ( 63 , err = 9234 ) tcr_sacr1 WRITE ( 63 , err = 9234 ) tms_sacr1 WRITE ( 63 , err = 9234 ) tcr_sacr2 WRITE ( 63 , err = 9234 ) tms_sacr2 WRITE ( 63 , err = 9234 ) tnr_racs1 WRITE ( 63 , err = 9234 ) tnr_racs2 WRITE ( 63 , err = 9234 ) tnr_sacr1 WRITE ( 63 , err = 9234 ) tnr_sacr2 CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , \"Error writing qr_acr_qs_mpt.dat\" ENDIF ENDIF !..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30). ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_gatherv(tcs_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcs_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tms_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tms_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! #endif end subroutine qr_acr_qs","tags":"","loc":"proc/qr_acr_qs.html"},{"title":"table_Efrw – Inference-Engine","text":"public subroutine table_Efrw() Arguments None Calls proc~~table_efrw~~CallsGraph proc~table_efrw table_Efrw dexp dexp proc~table_efrw->dexp sngl sngl proc~table_efrw->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code table_Efrw Source Code subroutine table_Efrw implicit none !..Local variables DOUBLE PRECISION :: vtr , stokes , reynolds , Ef_rw DOUBLE PRECISION :: p , yc0 , F , G , H , z , K0 , X INTEGER :: i , j do j = 1 , nbc do i = 1 , nbr Ef_rw = 0.0 p = Dc ( j ) / Dr ( i ) if ( Dr ( i ). lt . 5 0.E-6 . or . Dc ( j ). lt . 3.E-6 ) then t_Efrw ( i , j ) = 0.0 elseif ( p . gt . 0.25 ) then X = Dc ( j ) * 1.D6 if ( Dr ( i ) . lt . 7 5.e-6 ) then Ef_rw = 0.026794 * X - 0.20604 elseif ( Dr ( i ) . lt . 12 5.e-6 ) then Ef_rw = - 0.00066842 * X * X + 0.061542 * X - 0.37089 elseif ( Dr ( i ) . lt . 17 5.e-6 ) then Ef_rw = 4.091e-06 * X * X * X * X - 0.00030908 * X * X * X & + 0.0066237 * X * X - 0.0013687 * X - 0.073022 elseif ( Dr ( i ) . lt . 25 0.e-6 ) then Ef_rw = 9.6719e-5 * X * X * X - 0.0068901 * X * X + 0.17305 * X & - 0.65988 elseif ( Dr ( i ) . lt . 35 0.e-6 ) then Ef_rw = 9.0488e-5 * X * X * X - 0.006585 * X * X + 0.16606 * X & - 0.56125 else Ef_rw = 0.00010721 * X * X * X - 0.0072962 * X * X + 0.1704 * X & - 0.46929 endif else vtr = - 0.1021 + 4.932E3 * Dr ( i ) - 0.9551E6 * Dr ( i ) * Dr ( i ) & + 0.07934E9 * Dr ( i ) * Dr ( i ) * Dr ( i ) & - 0.002362E12 * Dr ( i ) * Dr ( i ) * Dr ( i ) * Dr ( i ) stokes = Dc ( j ) * Dc ( j ) * vtr * rho_w / ( 9. * 1.718E-5 * Dr ( i )) reynolds = 9. * stokes / ( p * p * rho_w ) F = DLOG ( reynolds ) G = - 0.1007D0 - 0.358D0 * F + 0.0261D0 * F * F K0 = DEXP ( G ) z = DLOG ( stokes / ( K0 + 1.D-15 )) H = 0.1465D0 + 1.302D0 * z - 0.607D0 * z * z + 0.293D0 * z * z * z yc0 = 2.0D0 / PI2 * ATAN ( H ) Ef_rw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) endif t_Efrw ( i , j ) = MAX ( 0.0 , MIN ( SNGL ( Ef_rw ), 0.95 )) ! ++ trude if ( Ef_rw_l ) then if ( Ef_rw . ne . 0.0 ) then t_Efrw ( i , j ) = 1.0 endif endif ! -- trude enddo enddo end subroutine table_Efrw","tags":"","loc":"proc/table_efrw.html"},{"title":"table_Efsw – Inference-Engine","text":"public subroutine table_Efsw() Arguments None Calls proc~~table_efsw~~CallsGraph proc~table_efsw table_Efsw dexp dexp proc~table_efsw->dexp sngl sngl proc~table_efsw->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code table_Efsw Source Code subroutine table_Efsw implicit none !..Local variables DOUBLE PRECISION :: Ds_m , vts , vtc , stokes , reynolds , Ef_sw DOUBLE PRECISION :: p , yc0 , F , G , H , z , K0 INTEGER :: i , j do j = 1 , nbc vtc = 1.19D4 * ( 1.0D4 * Dc ( j ) * Dc ( j ) * 0.25D0 ) do i = 1 , nbs vts = av_s * Ds ( i ) ** bv_s * DEXP ( - fv_s * Ds ( i )) - vtc Ds_m = ( am_s * Ds ( i ) ** bm_s / am_r ) ** obmr p = Dc ( j ) / Ds_m if ( p . gt . 0.25 . or . Ds ( i ). lt . D0s . or . Dc ( j ). lt . 6.E-6 & . or . vts . lt . 1.E-3 ) then t_Efsw ( i , j ) = 0.0 else stokes = Dc ( j ) * Dc ( j ) * vts * rho_w / ( 9. * 1.718E-5 * Ds_m ) reynolds = 9. * stokes / ( p * p * rho_w ) F = DLOG ( reynolds ) G = - 0.1007D0 - 0.358D0 * F + 0.0261D0 * F * F K0 = DEXP ( G ) z = DLOG ( stokes / ( K0 + 1.D-15 )) H = 0.1465D0 + 1.302D0 * z - 0.607D0 * z * z + 0.293D0 * z * z * z yc0 = 2.0D0 / PI2 * ATAN ( H ) Ef_sw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) t_Efsw ( i , j ) = MAX ( 0.0 , MIN ( SNGL ( Ef_sw ), 0.95 )) ! ++ trude if ( Ef_sw_l ) then if ( Ef_sw . ne . 0.0 ) then t_Efsw ( i , j ) = 1.0 endif endif ! -- trude endif enddo enddo end subroutine table_Efsw","tags":"","loc":"proc/table_efsw.html"},{"title":"table_dropEvap – Inference-Engine","text":"public subroutine table_dropEvap() Arguments None Calls proc~~table_dropevap~~CallsGraph proc~table_dropevap table_dropEvap proc~gammp GAMMP proc~table_dropevap->proc~gammp proc~gser GSER proc~gammp->proc~gser proc~gcf GCF proc~gammp->proc~gcf proc~gammln GAMMLN proc~gser->proc~gammln proc~gcf->proc~gammln Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code table_dropEvap Source Code subroutine table_dropEvap implicit none !..Local variables DOUBLE PRECISION :: Nt_r , N0 , lam_exp , lam REAL :: xlimit_intg INTEGER :: i , j , k do k = 1 , ntb_r do j = 1 , ntb_r1 lam_exp = ( N0r_exp ( j ) * am_r * crg ( 1 ) / r_r ( k )) ** ore1 lam = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0 = N0r_exp ( j ) / ( crg ( 2 ) * lam_exp ) * lam ** cre ( 2 ) Nt_r = N0 * crg ( 2 ) / lam ** cre ( 2 ) do i = 1 , nbr xlimit_intg = lam * Dr ( i ) tnr_rev ( i , j , k ) = GAMMP ( mu_r + 1.0 , xlimit_intg ) * Nt_r enddo enddo enddo end subroutine table_dropEvap","tags":"","loc":"proc/table_dropevap.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"module procedure differentiable_activation_strategy module module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable Called by proc~~differentiable_activation_strategy~~CalledByGraph proc~differentiable_activation_strategy differentiable_activation_strategy interface~differentiable_activation_strategy differentiable_activation_strategy interface~differentiable_activation_strategy->proc~differentiable_activation_strategy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical Called by proc~~equals~3~~CalledByGraph proc~equals~3 equals interface~equals~3 equals interface~equals~3->proc~equals~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/equals~3.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components module procedure from_components() Arguments None Calls proc~~from_components~~CallsGraph proc~from_components from_components file_t file_t proc~from_components->file_t string_t string_t proc~from_components->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_components.html"},{"title":"from_file – Inference-Engine","text":"module procedure from_file module procedure from_file() Arguments None Calls proc~~from_file~~CallsGraph proc~from_file from_file lines lines proc~from_file->lines assert assert proc~from_file->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_file.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~learning_rate~2~~CalledByGraph proc~learning_rate~2 learning_rate interface~learning_rate~2 learning_rate interface~learning_rate~2->proc~learning_rate~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer Called by proc~~mini_batches~2~~CalledByGraph proc~mini_batches~2 mini_batches interface~mini_batches~2 mini_batches interface~mini_batches~2->proc~mini_batches~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mini_batches~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer module module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:) Called by proc~~nodes_per_layer~3~~CalledByGraph proc~nodes_per_layer~3 nodes_per_layer interface~nodes_per_layer~3 nodes_per_layer interface~nodes_per_layer~3->proc~nodes_per_layer~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/nodes_per_layer~3.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) Called by proc~~optimizer_name~2~~CalledByGraph proc~optimizer_name~2 optimizer_name interface~optimizer_name~2 optimizer_name interface~optimizer_name~2->proc~optimizer_name~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/optimizer_name~2.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical Called by proc~~skip_connections~2~~CalledByGraph proc~skip_connections~2 skip_connections interface~skip_connections~2 skip_connections interface~skip_connections~2->proc~skip_connections~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:) Called by proc~~to_json~4~~CalledByGraph proc~to_json~4 to_json interface~to_json~4 to_json interface~to_json~4->proc~to_json~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json~4.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~2~~CalledByGraph proc~activation~2 activation interface~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~~CalledByGraph proc~activation_derivative activation_derivative interface~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~2~~CallsGraph proc~function_name~2 function_name string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~2~~CalledByGraph proc~function_name~2 function_name interface~function_name~2 function_name interface~function_name~2->proc~function_name~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~2.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct.html"},{"title":"input_1D_double – Inference-Engine","text":"module procedure input_1D_double module module subroutine input_1D_double(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) Calls proc~~input_1d_double~~CallsGraph proc~input_1d_double input_1D_double nf90_strerror nf90_strerror proc~input_1d_double->nf90_strerror assert assert proc~input_1d_double->assert intrinsic_array_t intrinsic_array_t proc~input_1d_double->intrinsic_array_t array_shape array_shape proc~input_1d_double->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_1d_double~~CalledByGraph proc~input_1d_double input_1D_double interface~input_1d_double input_1D_double interface~input_1d_double->proc~input_1d_double Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_1d_double.html"},{"title":"input_2D_integer – Inference-Engine","text":"module procedure input_2D_integer module module subroutine input_2D_integer(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) Calls proc~~input_2d_integer~~CallsGraph proc~input_2d_integer input_2D_integer nf90_strerror nf90_strerror proc~input_2d_integer->nf90_strerror assert assert proc~input_2d_integer->assert array_shape array_shape proc~input_2d_integer->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_2d_integer~~CalledByGraph proc~input_2d_integer input_2D_integer interface~input_2d_integer input_2D_integer interface~input_2d_integer->proc~input_2d_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_2d_integer.html"},{"title":"input_3D_real – Inference-Engine","text":"module procedure input_3D_real module module subroutine input_3D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) Calls proc~~input_3d_real~~CallsGraph proc~input_3d_real input_3D_real nf90_strerror nf90_strerror proc~input_3d_real->nf90_strerror assert assert proc~input_3d_real->assert intrinsic_array_t intrinsic_array_t proc~input_3d_real->intrinsic_array_t array_shape array_shape proc~input_3d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_3d_real~~CalledByGraph proc~input_3d_real input_3D_real interface~input_3d_real input_3D_real interface~input_3d_real->proc~input_3d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_3d_real.html"},{"title":"input_4D_real – Inference-Engine","text":"module procedure input_4D_real module module subroutine input_4D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) Calls proc~~input_4d_real~~CallsGraph proc~input_4d_real input_4D_real nf90_strerror nf90_strerror proc~input_4d_real->nf90_strerror assert assert proc~input_4d_real->assert intrinsic_array_t intrinsic_array_t proc~input_4d_real->intrinsic_array_t array_shape array_shape proc~input_4d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_4d_real~~CalledByGraph proc~input_4d_real input_4D_real interface~input_4d_real input_4D_real interface~input_4d_real->proc~input_4d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_4d_real.html"},{"title":"input_real_scalar – Inference-Engine","text":"module procedure input_real_scalar module module subroutine input_real_scalar(self, varname, scalar) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar Calls proc~~input_real_scalar~~CallsGraph proc~input_real_scalar input_real_scalar nf90_strerror nf90_strerror proc~input_real_scalar->nf90_strerror assert assert proc~input_real_scalar->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_real_scalar~~CalledByGraph proc~input_real_scalar input_real_scalar interface~input_real_scalar input_real_scalar interface~input_real_scalar->proc~input_real_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_real_scalar.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components module procedure construct_from_components() Arguments None Contents None","tags":"","loc":"proc/construct_from_components.html"},{"title":"num_components – Inference-Engine","text":"module procedure num_components pure module module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer Called by proc~~num_components~~CalledByGraph proc~num_components num_components interface~num_components num_components interface~num_components->proc~num_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_components.html"},{"title":"values – Inference-Engine","text":"module procedure values pure module module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~values~~CalledByGraph proc~values values interface~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/values.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~2~~CallsGraph proc~construct~2 construct layer_lines layer_lines proc~construct~2->layer_lines assert assert proc~construct~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"count_inputs – Inference-Engine","text":"module procedure count_inputs module module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer Called by proc~~count_inputs~~CalledByGraph proc~count_inputs count_inputs interface~count_inputs count_inputs interface~count_inputs->proc~count_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer Called by proc~~count_layers~~CalledByGraph proc~count_layers count_layers interface~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:) Called by proc~~count_neurons~~CalledByGraph proc~count_neurons count_neurons interface~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"module procedure inference_engine module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) Calls proc~~inference_engine~~CallsGraph proc~inference_engine inference_engine assert assert proc~inference_engine->assert biases biases proc~inference_engine->biases weights weights proc~inference_engine->weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inference_engine~~CalledByGraph proc~inference_engine inference_engine interface~inference_engine inference_engine interface~inference_engine->proc~inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~~CalledByGraph proc~next_allocated next_allocated interface~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Called by proc~~next_pointer~~CalledByGraph proc~next_pointer next_pointer interface~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~~CallsGraph proc~equals equals assert assert proc~equals->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~equals~~CalledByGraph proc~equals equals interface~equals equals interface~equals->proc~equals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/equals.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components module procedure from_components() Arguments None Contents None","tags":"","loc":"proc/from_components~2.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json module procedure from_json() Arguments None Calls proc~~from_json~~CallsGraph proc~from_json from_json lines lines proc~from_json->lines assert assert proc~from_json->assert string_t string_t proc~from_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_json.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~learning_rate~~CalledByGraph proc~learning_rate learning_rate interface~learning_rate learning_rate interface~learning_rate->proc~learning_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer Called by proc~~mini_batches~~CalledByGraph proc~mini_batches mini_batches interface~mini_batches mini_batches interface~mini_batches->proc~mini_batches Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mini_batches.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) Calls proc~~optimizer_name~~CallsGraph proc~optimizer_name optimizer_name string_t string_t proc~optimizer_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~optimizer_name~~CalledByGraph proc~optimizer_name optimizer_name interface~optimizer_name optimizer_name interface~optimizer_name->proc~optimizer_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/optimizer_name.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable,(:) Calls proc~~to_json~~CallsGraph proc~to_json to_json string_t string_t proc~to_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~~CalledByGraph proc~to_json to_json interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~3.html"},{"title":"input_output_pairs – Inference-Engine","text":"module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:) Called by proc~~input_output_pairs~~CalledByGraph proc~input_output_pairs input_output_pairs interface~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_output_pairs.html"},{"title":"difference_consistency – Inference-Engine","text":"pure module subroutine difference_consistency(self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Calls proc~~difference_consistency~~CallsGraph proc~difference_consistency difference_consistency intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t assert assert proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~difference_consistency~~CalledByGraph proc~difference_consistency difference_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~difference_consistency proc~infer infer proc~infer->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~to_json~2 to_json proc~to_json~2->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency interface~infer infer interface~infer->proc~infer interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json~2 to_json interface~to_json~2->proc~to_json~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/difference_consistency.html"},{"title":"inference_engine_consistency – Inference-Engine","text":"pure module subroutine inference_engine_consistency(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~inference_engine_consistency~~CallsGraph proc~inference_engine_consistency inference_engine_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inference_engine_consistency~~CalledByGraph proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~inference_engine_consistency proc~infer infer proc~infer->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~to_json~2 to_json proc~to_json~2->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency interface~infer infer interface~infer->proc~infer interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json~2 to_json interface~to_json~2->proc~to_json~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inference_engine_consistency.html"},{"title":"activation_function_name – Inference-Engine","text":"module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) Called by proc~~activation_function_name~~CalledByGraph proc~activation_function_name activation_function_name interface~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Calls proc~~assert_conformable_with~~CallsGraph proc~assert_conformable_with assert_conformable_with interface~assert_consistency assert_consistency proc~assert_conformable_with->interface~assert_consistency assert assert proc~assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_conformable_with~~CalledByGraph proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_conformable_with.html"},{"title":"construct_from_json – Inference-Engine","text":"module procedure construct_from_json module procedure construct_from_json() Arguments None Calls proc~~construct_from_json~~CallsGraph proc~construct_from_json construct_from_json assert assert proc~construct_from_json->assert string_t string_t proc~construct_from_json->string_t proc~set_activation_strategy set_activation_strategy proc~construct_from_json->proc~set_activation_strategy interface~assert_consistency assert_consistency proc~construct_from_json->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_json.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None Calls proc~~construct_from_padded_arrays~~CallsGraph proc~construct_from_padded_arrays construct_from_padded_arrays proc~set_activation_strategy set_activation_strategy proc~construct_from_padded_arrays->proc~set_activation_strategy interface~assert_consistency assert_consistency proc~construct_from_padded_arrays->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_padded_arrays.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~~CallsGraph proc~infer infer interface~assert_consistency assert_consistency proc~infer->interface~assert_consistency n n proc~infer->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:) Calls proc~~nodes_per_layer~~CallsGraph proc~nodes_per_layer nodes_per_layer interface~assert_consistency assert_consistency proc~nodes_per_layer->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nodes_per_layer~~CalledByGraph proc~nodes_per_layer nodes_per_layer interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~~CallsGraph proc~num_inputs num_inputs interface~assert_consistency assert_consistency proc~num_inputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs interface~assert_consistency assert_consistency proc~num_outputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"skip – Inference-Engine","text":"module procedure skip pure module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical Called by proc~~skip~~CalledByGraph proc~skip skip interface~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract interface~assert_consistency assert_consistency proc~subtract->interface~assert_consistency n n proc~subtract->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"to_exchange – Inference-Engine","text":"module procedure to_exchange pure module module function to_exchange(self) result(exchange) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) Called by proc~~to_exchange~~CalledByGraph proc~to_exchange to_exchange interface~to_exchange to_exchange interface~to_exchange->proc~to_exchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_exchange.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Calls proc~~to_json~2~~CallsGraph proc~to_json~2 to_json separated_values separated_values proc~to_json~2->separated_values file_t file_t proc~to_json~2->file_t assert assert proc~to_json~2->assert n n proc~to_json~2->n interface~assert_consistency assert_consistency proc~to_json~2->interface~assert_consistency string_t string_t proc~to_json~2->string_t hidden_layer_weights hidden_layer_weights proc~to_json~2->hidden_layer_weights intrinsic_array_t intrinsic_array_t proc~to_json~2->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~2~~CalledByGraph proc~to_json~2 to_json interface~to_json~2 to_json interface~to_json~2->proc~to_json~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json~2.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~bias~~CalledByGraph proc~bias bias interface~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~4~~CallsGraph proc~construct~4 construct neuron_lines neuron_lines proc~construct~4->neuron_lines assert assert proc~construct~4->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~4.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~2~~CalledByGraph proc~next_allocated~2 next_allocated interface~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer Called by proc~~next_pointer~2~~CalledByGraph proc~next_pointer~2 next_pointer interface~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~3~~CalledByGraph proc~num_inputs~3 num_inputs interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~3.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~weights~~CalledByGraph proc~weights weights interface~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/weights.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~~CalledByGraph proc~function_name function_name interface~function_name function_name interface~function_name->proc~function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name.html"},{"title":"activation_name – Inference-Engine","text":"module procedure activation_name elemental module module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) Called by proc~~activation_name~~CalledByGraph proc~activation_name activation_name interface~activation_name activation_name interface~activation_name->proc~activation_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_name.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~2~~CallsGraph proc~equals~2 equals assert assert proc~equals~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~equals~2~~CalledByGraph proc~equals~2 equals interface~equals~2 equals interface~equals~2->proc~equals~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/equals~2.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components module procedure from_components() Arguments None Contents None","tags":"","loc":"proc/from_components~3.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json module procedure from_json() Arguments None Calls proc~~from_json~2~~CallsGraph proc~from_json~2 from_json lines lines proc~from_json~2->lines assert assert proc~from_json~2->assert string_t string_t proc~from_json~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_json~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:) Called by proc~~nodes_per_layer~2~~CalledByGraph proc~nodes_per_layer~2 nodes_per_layer interface~nodes_per_layer~2 nodes_per_layer interface~nodes_per_layer~2->proc~nodes_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/nodes_per_layer~2.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical Called by proc~~skip_connections~~CalledByGraph proc~skip_connections skip_connections interface~skip_connections skip_connections interface~skip_connections->proc~skip_connections Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:) Calls proc~~to_json~3~~CallsGraph proc~to_json~3 to_json string_t string_t proc~to_json~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~3~~CalledByGraph proc~to_json~3 to_json interface~to_json~3 to_json interface~to_json~3->proc~to_json~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json~3.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~3~~CalledByGraph proc~activation~3 activation interface~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~2~~CalledByGraph proc~activation_derivative~2 activation_derivative interface~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~3~~CallsGraph proc~function_name~3 function_name string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~3~~CalledByGraph proc~function_name~3 function_name interface~function_name~3 function_name interface~function_name~3->proc~function_name~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~3.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~4~~CalledByGraph proc~activation~4 activation interface~activation~4 activation interface~activation~4->proc~activation~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~4.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~3~~CalledByGraph proc~activation_derivative~3 activation_derivative interface~activation_derivative~3 activation_derivative interface~activation_derivative~3->proc~activation_derivative~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~4~~CallsGraph proc~function_name~4 function_name string_t string_t proc~function_name~4->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~4~~CalledByGraph proc~function_name~4 function_name interface~function_name~4 function_name interface~function_name~4->proc~function_name~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~4.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~5.html"},{"title":"expected_outputs – Inference-Engine","text":"module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Called by proc~~expected_outputs~~CalledByGraph proc~expected_outputs expected_outputs interface~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Called by proc~~inputs~~CalledByGraph proc~inputs inputs interface~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inputs.html"},{"title":"shuffle – Inference-Engine","text":"module procedure shuffle pure module module subroutine shuffle(pairs, random_numbers) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) real, intent(in) :: random_numbers (2:) Calls proc~~shuffle~~CallsGraph proc~shuffle shuffle assert assert proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~shuffle~~CalledByGraph proc~shuffle shuffle interface~shuffle shuffle interface~shuffle->proc~shuffle program~train_polynomials train_polynomials program~train_polynomials->interface~shuffle program~train_and_write train_and_write program~train_and_write->interface~shuffle program~train_polynomials~4 train_polynomials program~train_polynomials~4->interface~shuffle program~train_polynomials~3 train_polynomials program~train_polynomials~3->interface~shuffle program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->interface~shuffle program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->interface~shuffle program~train_polynomials~2 train_polynomials program~train_polynomials~2->interface~shuffle program~train_polynomials~5 train_polynomials program~train_polynomials~5->interface~shuffle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/shuffle.html"},{"title":"assert_consistent – Inference-Engine","text":"module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t assert assert proc~assert_consistent->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent interface~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"construct_from_inference_engine – Inference-Engine","text":"module procedure construct_from_inference_engine module procedure construct_from_inference_engine() Arguments None Contents None","tags":"","loc":"proc/construct_from_inference_engine.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None Contents None","tags":"","loc":"proc/construct_from_padded_arrays~2.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~2~~CallsGraph proc~infer~2 infer n n proc~infer~2->n b b proc~infer~2->b w w proc~infer~2->w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~2~~CalledByGraph proc~num_inputs~2 num_inputs interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_layers~~CalledByGraph proc~num_layers num_layers interface~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_layers.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(n_out) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_outputs~2~~CalledByGraph proc~num_outputs~2 num_outputs interface~num_outputs~2 num_outputs interface~num_outputs~2->proc~num_outputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs~2.html"},{"title":"to_inference_engine – Inference-Engine","text":"module procedure to_inference_engine pure module module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) Called by proc~~to_inference_engine~~CalledByGraph proc~to_inference_engine to_inference_engine interface~to_inference_engine to_inference_engine interface~to_inference_engine->proc~to_inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"module procedure train pure module module subroutine train(self, mini_batches, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate Calls proc~~train~~CallsGraph proc~train train b b proc~train->b beta beta proc~train->beta y y proc~train->y n n proc~train->n w w proc~train->w obeta obeta proc~train->obeta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~train~~CalledByGraph proc~train train interface~train train interface~train->proc~train Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/train.html"},{"title":"inference_engine_m – Inference-Engine","text":"Specify the user-facing modules, derived types, and type parameters Uses hyperparameters_m NetCDF_file_m sigmoid_m network_configuration_m kind_parameters_m training_configuration_m differentiable_activation_strategy_m inference_engine_m_ activation_strategy_m trainable_engine_m input_output_pair_m tensor_m swish_m relu_m step_m mini_batch_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/inference_engine_m.html"},{"title":"input_output_pair_m – Inference-Engine","text":"Uses kind_parameters_m tensor_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~trainable_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~trainable_engine_m->module~mini_batch_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~add_inputs->module~inference_engine_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces input_output_pair_t shuffle expected_outputs inputs Derived Types input_output_pair_t Interfaces public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) interface public pure module module subroutine shuffle(pairs, random_numbers) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) real, intent(in) :: random_numbers (2:) interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor private elemental,module function construct (inputs, expected_outputs) Type-Bound Procedures procedure, public :: expected_outputs procedure, public :: inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~hyperparameters_m hyperparameters_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m training_configuration_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~hyperparameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~swish_m swish_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m step_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~neuron_m neuron_m module~neuron_m->module~kind_parameters_m module~relu_s relu_s module~relu_s->module~kind_parameters_m module~relu_m relu_m module~relu_s->module~relu_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m->module~sigmoid_m module~inference_engine_m->module~tensor_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m->module~swish_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~relu_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~differentiable_activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~layer_m->module~neuron_m module~layer_m->module~inference_engine_m_ module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~input_output_pair_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~training_configuration_s->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~step_m module~inference_engine_s->module~neuron_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~relu_m module~inference_engine_s->module~layer_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~add_inputs->module~inference_engine_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"mini_batch_m – Inference-Engine","text":"Uses input_output_pair_m kind_parameters_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~mini_batch_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces mini_batch_t input_output_pairs Derived Types mini_batch_t Interfaces public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor private pure,module function construct (input_output_pairs) Type-Bound Procedures procedure, public :: input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"hyperparameters_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m module~~hyperparameters_m~~UsesGraph module~hyperparameters_m hyperparameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: hyperparameters_s module~~hyperparameters_m~~UsedByGraph module~hyperparameters_m hyperparameters_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~training_configuration_m->module~hyperparameters_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces hyperparameters_t equals learning_rate mini_batches optimizer_name to_json Derived Types hyperparameters_t Interfaces public interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) interface private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical interface private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer interface private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) interface private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) Derived Types type, public :: hyperparameters_t Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor private pure,module function from_components (mini_batches, learning_rate, optimizer) private pure,module function from_json (lines) Type-Bound Procedures procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: to_json","tags":"","loc":"module/hyperparameters_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m sourcery_m sourcery_m module~activation_strategy_m->sourcery_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~step_m step_m module~inference_engine_m->module~step_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~step_m->module~activation_strategy_m module~training_configuration_m->module~differentiable_activation_strategy_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~swish_m->module~differentiable_activation_strategy_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~step_s step_s module~step_s->module~step_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~sigmoid_m->module~differentiable_activation_strategy_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~step_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~layer_m module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~relu_m module~relu_m->module~differentiable_activation_strategy_m module~add_inputs->module~inference_engine_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~layer_s layer_s module~layer_s->module~layer_m module~relu_s relu_s module~relu_s->module~relu_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~swish_m module~swish_s->module~sigmoid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_i function_name_i Derived Types activation_strategy_t Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/activation_strategy_m.html"},{"title":"inference_engine_m_ – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses kind_parameters_m differentiable_activation_strategy_m activation_strategy_m sourcery_m tensor_m module~~inference_engine_m_~~UsesGraph module~inference_engine_m_ inference_engine_m_ module~kind_parameters_m kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m sourcery_m sourcery_m module~inference_engine_m_->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m_~~UsedByGraph module~inference_engine_m_ inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~trainable_engine_m->module~inference_engine_m_ module~layer_m->module~inference_engine_m_ module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs module~add_inputs->module~inference_engine_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables key Interfaces inference_engine_t activation_function_name assert_conformable_with infer nodes_per_layer norm num_inputs num_outputs skip subtract to_exchange to_json Derived Types difference_t exchange_t inference_engine_t Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces public interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) interface private pure module module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm type, public :: exchange_t Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor private impure,elemental,module function construct_from_json (file_) private pure,module function construct_from_padded_arrays (metadata, weights, biases, nodes) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with procedure, public :: infer procedure, public :: nodes_per_layer procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: skip procedure, public :: to_exchange procedure, public :: to_json procedure, private :: subtract","tags":"","loc":"module/inference_engine_m_.html"},{"title":"network_configuration_m – Inference-Engine","text":"Uses sourcery_m module~~network_configuration_m~~UsesGraph module~network_configuration_m network_configuration_m sourcery_m sourcery_m module~network_configuration_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: network_configuration_s module~~network_configuration_m~~UsedByGraph module~network_configuration_m network_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~network_configuration_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~training_configuration_m->module~network_configuration_m module~network_configuration_s network_configuration_s module~network_configuration_s->module~network_configuration_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces network_configuration_t activation_name equals nodes_per_layer skip_connections to_json Derived Types network_configuration_t Interfaces public interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) interface private elemental module module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical interface private pure module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) interface private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical interface private pure module module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) Derived Types type, public :: network_configuration_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor private pure,module function from_components (skip_connections, nodes_per_layer, activation_name) private pure,module function from_json (lines) Type-Bound Procedures procedure, public :: activation_name procedure, public :: equals procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/network_configuration_m.html"},{"title":"NetCDF_file_m – Inference-Engine","text":"Used by Descendants: netCDF_file_s module~~netcdf_file_m~~UsedByGraph module~netcdf_file_m NetCDF_file_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~netcdf_file_m module~netcdf_file_s netCDF_file_s module~netcdf_file_s->module~netcdf_file_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces NetCDF_file_t input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Derived Types NetCDF_file_t Interfaces public interface NetCDF_file_t private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t ) interface private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) interface private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) interface private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) interface private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) interface private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar Derived Types type, public :: NetCDF_file_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_name_ Constructor private pure,module function construct (file_name) Type-Bound Procedures generic, public :: input => input_2D_integer, input_1D_double, input_4D_real, input_3D_real, input_real_scalar procedure, public :: input_1D_double procedure, public :: input_2D_integer procedure, public :: input_3D_real procedure, public :: input_4D_real procedure, public :: input_real_scalar","tags":"","loc":"module/netcdf_file_m.html"},{"title":"trainable_engine_m – Inference-Engine","text":"Define an abstraction that supports training a neural network Uses kind_parameters_m differentiable_activation_strategy_m inference_engine_m_ sourcery_m tensor_m mini_batch_m module~~trainable_engine_m~~UsesGraph module~trainable_engine_m trainable_engine_m module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~tensor_m tensor_m module~trainable_engine_m->module~tensor_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: trainable_engine_s module~~trainable_engine_m~~UsedByGraph module~trainable_engine_m trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Interfaces trainable_engine_t assert_consistent infer num_inputs num_layers num_outputs to_inference_engine train Derived Types trainable_engine_t Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Interfaces public interface trainable_engine_t private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) interface private pure module module subroutine train(self, mini_batches, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate Derived Types type, public :: trainable_engine_t Encapsulate the information needed to perform training Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor private pure,module function construct_from_inference_engine (inference_engine) private pure,module function construct_from_padded_arrays (nodes, weights, biases, differentiable_activation_strategy, metadata) Type-Bound Procedures procedure, public :: assert_consistent procedure, public :: infer procedure, public :: num_inputs procedure, public :: num_layers procedure, public :: num_outputs procedure, public :: to_inference_engine procedure, public :: train","tags":"","loc":"module/trainable_engine_m.html"},{"title":"step_m – Inference-Engine","text":"Uses activation_strategy_m sourcery_m kind_parameters_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m sourcery_m sourcery_m module~step_m->sourcery_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m module~step_s step_s module~step_s->module~step_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation function_name Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: function_name","tags":"","loc":"module/step_m.html"},{"title":"relu_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m differentiable_activation_strategy_m module~~relu_m~~UsesGraph module~relu_m relu_m sourcery_m sourcery_m module~relu_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~relu_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: relu_s module~~relu_m~~UsedByGraph module~relu_m relu_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~relu_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~relu_m module~relu_s relu_s module~relu_s->module~relu_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types relu_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: relu_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/relu_m.html"},{"title":"training_configuration_m – Inference-Engine","text":"Uses hyperparameters_m network_configuration_m kind_parameters_m differentiable_activation_strategy_m sourcery_m module~~training_configuration_m~~UsesGraph module~training_configuration_m training_configuration_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~training_configuration_m->module~kind_parameters_m sourcery_m sourcery_m module~training_configuration_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~training_configuration_m->module~differentiable_activation_strategy_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~network_configuration_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: training_configuration_s module~~training_configuration_m~~UsedByGraph module~training_configuration_m training_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~training_configuration_s->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces training_configuration_t differentiable_activation_strategy equals learning_rate mini_batches nodes_per_layer optimizer_name skip_connections to_json Derived Types training_configuration_t Interfaces public interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) interface private module module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable interface private elemental module module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical interface private elemental module module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer interface private module module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) interface private elemental module module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical interface private pure module module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) Derived Types type, public, extends(file_t) :: training_configuration_t Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor private module function from_components (hyperparameters, network_configuration) private module function from_file (file_object) Type-Bound Procedures procedure, public :: differentiable_activation_strategy procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/training_configuration_m.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m differentiable_activation_strategy_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m sourcery_m sourcery_m module~sigmoid_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types sigmoid_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/sigmoid_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m neuron_m inference_engine_m_ module~~layer_m~~UsesGraph module~layer_m layer_m sourcery_m sourcery_m module~layer_m->sourcery_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->sourcery_m module~neuron_m->module~kind_parameters_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces layer_t count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Derived Types layer_t Interfaces public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target interface private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) interface private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private recursive,module function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_inputs procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: inference_engine procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"tensor_m – Inference-Engine","text":"Uses kind_parameters_m module~~tensor_m~~UsesGraph module~tensor_m tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: tensor_s module~~tensor_m~~UsedByGraph module~tensor_m tensor_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~tensor_m module~input_output_pair_m input_output_pair_m module~input_output_pair_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~tensor_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~mini_batch_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~layer_m module~mini_batch_m->module~input_output_pair_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~add_inputs->module~inference_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series module~layer_s layer_s module~layer_s->module~layer_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces tensor_t num_components values Derived Types tensor_t Interfaces public interface tensor_t private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) interface private pure module module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer interface private pure module module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: tensor_t Components Type Visibility Attributes Name Initial procedure, public :: num_components procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor private pure,module function construct_from_components (values)","tags":"","loc":"module/tensor_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m sourcery_m sourcery_m module~activation_strategy_m->sourcery_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~differentiable_activation_strategy_m module~training_configuration_m training_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~swish_m swish_m module~swish_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m->module~sigmoid_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m->module~swish_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~trainable_engine_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~relu_m->module~differentiable_activation_strategy_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~training_configuration_s->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m module~trainable_engine_s->module~trainable_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~relu_m module~inference_engine_s->module~layer_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m program~train_polynomials->module~multiply_inputs program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~relu_s relu_s module~relu_s->module~relu_m module~add_inputs->module~inference_engine_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~power_series power_series module~power_series->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types differentiable_activation_strategy_t Derived Types type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(activation_i), public, nopass :: activation_derivative procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m differentiable_activation_strategy_m module~~swish_m~~UsesGraph module~swish_m swish_m sourcery_m sourcery_m module~swish_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~swish_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m module~raise_inputs_to_a_power raise_inputs_to_a_power module~raise_inputs_to_a_power->module~inference_engine_m program~train_polynomials train_polynomials program~train_polynomials->module~inference_engine_m module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_polynomials~3 train_polynomials program~train_polynomials~3->module~inference_engine_m program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~inference_engine_m program~train_polynomials~4->module~raise_inputs_to_a_power module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~add_inputs add_inputs module~add_inputs->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~inference_engine_m program~train_polynomials~2->module~power_series program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~inference_engine_m program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types swish_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/swish_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses sourcery_m kind_parameters_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m sourcery_m sourcery_m module~neuron_m->sourcery_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~inference_engine_s->module~layer_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces neuron_t bias next_allocated next_pointer num_inputs weights Derived Types neuron_t Interfaces public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private pure,recursive,module function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"multiply_inputs – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~multiply_inputs~~UsesGraph module~multiply_inputs multiply_inputs assert_m assert_m module~multiply_inputs->assert_m module~inference_engine_m inference_engine_m module~multiply_inputs->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~multiply_inputs~~UsedByGraph module~multiply_inputs multiply_inputs program~train_polynomials train_polynomials program~train_polynomials->module~multiply_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions y Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/multiply_inputs.html"},{"title":"power_series – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~power_series~~UsesGraph module~power_series power_series assert_m assert_m module~power_series->assert_m module~inference_engine_m inference_engine_m module~power_series->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~power_series~~UsedByGraph module~power_series power_series program~train_polynomials~2 train_polynomials program~train_polynomials~2->module~power_series Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions y Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/power_series.html"},{"title":"raise_inputs_to_a_power – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~raise_inputs_to_a_power~~UsesGraph module~raise_inputs_to_a_power raise_inputs_to_a_power assert_m assert_m module~raise_inputs_to_a_power->assert_m module~inference_engine_m inference_engine_m module~raise_inputs_to_a_power->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~raise_inputs_to_a_power~~UsedByGraph module~raise_inputs_to_a_power raise_inputs_to_a_power program~train_polynomials~4 train_polynomials program~train_polynomials~4->module~raise_inputs_to_a_power Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions y Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/raise_inputs_to_a_power.html"},{"title":"add_inputs – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~add_inputs~~UsesGraph module~add_inputs add_inputs assert_m assert_m module~add_inputs->assert_m module~inference_engine_m inference_engine_m module~add_inputs->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~add_inputs~~UsedByGraph module~add_inputs add_inputs program~train_polynomials~5 train_polynomials program~train_polynomials~5->module~add_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions y Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/add_inputs.html"},{"title":"saturated_mixing_ratio_m – Inference-Engine","text":"This module supports the program in the file example/learn-saturated-mixing-ratio.f90.\nThe saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function\nin the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90.\nICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. Uses assert_m inference_engine_m module~~saturated_mixing_ratio_m~~UsesGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m assert_m assert_m module~saturated_mixing_ratio_m->assert_m module~inference_engine_m inference_engine_m module~saturated_mixing_ratio_m->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~saturated_mixing_ratio_m~~UsedByGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables T p T_max T_min freezing_threshold i p_max p_min resolution Functions y saturated_mixing_ratio Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 real, private, parameter :: freezing_threshold = 273.15 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) private pure function saturated_mixing_ratio (T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real","tags":"","loc":"module/saturated_mixing_ratio_m.html"},{"title":"thompson_tensors_m – Inference-Engine","text":"This module supports the program in the file example/learn-microphysics-procedures.f90. Uses module_mp_thompson assert_m inference_engine_m module~~thompson_tensors_m~~UsesGraph module~thompson_tensors_m thompson_tensors_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~inference_engine_m inference_engine_m module~thompson_tensors_m->module~inference_engine_m assert_m assert_m module~thompson_tensors_m->assert_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->module~kind_parameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~tensor_m->module~kind_parameters_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~thompson_tensors_m~~UsedByGraph module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables T p T_max T_min i p_max p_min resolution Functions y Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public impure elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/thompson_tensors_m.html"},{"title":"module_mp_thompson – Inference-Engine","text":"!      use options_types, only: mp_options_type\n! commented for compilation outside ICAR ! The subroutine below is commented to support compiling this module outside ICAR !       SUBROUTINE thompson_init(mp_options)\n! \n!       IMPLICIT NONE\n! \n! ! ++ trude\n!       type(mp_options_type), intent(in) :: mp_options\n! ! -- trude\n!       INTEGER:: i, j, k, m, n\n!       LOGICAL:: micro_init\n! !..Allocate space for lookup tables (J. Michalakes 2009Jun08).\n!       micro_init = .FALSE.\n!       if (.NOT. ALLOCATED(tcg_racg) ) then\n!          ALLOCATE(tcg_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))\n!          micro_init = .TRUE.\n!       endif\n! \n!       if (.NOT. ALLOCATED(tmr_racg)) ALLOCATE(tmr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tcr_gacr)) ALLOCATE(tcr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tmg_gacr)) ALLOCATE(tmg_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_racg)) ALLOCATE(tnr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_gacr)) ALLOCATE(tnr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))\n! \n!       if (.NOT. ALLOCATED(tcs_racs1)) ALLOCATE(tcs_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tmr_racs1)) ALLOCATE(tmr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tcs_racs2)) ALLOCATE(tcs_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tmr_racs2)) ALLOCATE(tmr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tcr_sacr1)) ALLOCATE(tcr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tms_sacr1)) ALLOCATE(tms_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tcr_sacr2)) ALLOCATE(tcr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tms_sacr2)) ALLOCATE(tms_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_racs1)) ALLOCATE(tnr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_racs2)) ALLOCATE(tnr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_sacr1)) ALLOCATE(tnr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))\n!       if (.NOT. ALLOCATED(tnr_sacr2)) ALLOCATE(tnr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))\n! \n!       if (.NOT. ALLOCATED(tpi_qcfz)) ALLOCATE(tpi_qcfz(ntb_c,45))\n!       if (.NOT. ALLOCATED(tni_qcfz)) ALLOCATE(tni_qcfz(ntb_c,45))\n! \n!       if (.NOT. ALLOCATED(tpi_qrfz)) ALLOCATE(tpi_qrfz(ntb_r,ntb_r1,45))\n!       if (.NOT. ALLOCATED(tpg_qrfz)) ALLOCATE(tpg_qrfz(ntb_r,ntb_r1,45))\n!       if (.NOT. ALLOCATED(tni_qrfz)) ALLOCATE(tni_qrfz(ntb_r,ntb_r1,45))\n!       if (.NOT. ALLOCATED(tnr_qrfz)) ALLOCATE(tnr_qrfz(ntb_r,ntb_r1,45))\n! \n!       if (.NOT. ALLOCATED(tps_iaus)) ALLOCATE(tps_iaus(ntb_i,ntb_i1))\n!       if (.NOT. ALLOCATED(tni_iaus)) ALLOCATE(tni_iaus(ntb_i,ntb_i1))\n!       if (.NOT. ALLOCATED(tpi_ide)) ALLOCATE(tpi_ide(ntb_i,ntb_i1))\n! \n!       if (.NOT. ALLOCATED(t_Efrw)) ALLOCATE(t_Efrw(nbr,nbc))\n!       if (.NOT. ALLOCATED(t_Efsw)) ALLOCATE(t_Efsw(nbs,nbc))\n! \n!       if (.NOT. ALLOCATED(tnr_rev)) ALLOCATE(tnr_rev(nbr, ntb_r1, ntb_r))\n! \n!       if (micro_init) then\n! \n!       !++ trude\n!          Nt_c = mp_options%Nt_c\n!          TNO = mp_options%TNO\n!          am_s = mp_options%am_s\n!          rho_g = mp_options%rho_g\n!          av_s = mp_options%av_s\n!          bv_s = mp_options%bv_s\n!          fv_s = mp_options%fv_s\n!          av_g = mp_options%av_g\n!          bv_g = mp_options%bv_g\n!          av_i = mp_options%av_i\n!          Ef_rs = mp_options%Ef_rs\n!          Ef_rg = mp_options%Ef_rg\n!          Ef_si = mp_options%Ef_si\n!          Ef_ri = mp_options%Ef_ri\n!          C_cubes = mp_options%C_cubes\n!          C_sqrd = mp_options%C_sqrd\n!          mu_r = mp_options%mu_r\n!          t_adjust = mp_options%t_adjust\n!          Ef_rw_l = mp_options%Ef_rw_l\n!          Ef_sw_l = mp_options%Ef_sw_l\n!          am_g = PI2 rho_g/6.0           ! trude, nb, this should can be defined in the modular section\n!       !--trude\n! !..From Martin et al. (1994), assign gamma shape parameter mu for cloud\n! !.. drops according to general dispersion characteristics (disp=~0.25\n! !.. for Maritime and 0.45 for Continental).\n! !.. disp=SQRT((mu+2)/(mu+1) - 1) so mu varies from 15 for Maritime\n! !.. to 2 for really dirty air.\n!       mu_c = MIN(15., (1000.E6/Nt_c + 2.))\n! \n! !..Schmidt number to one-third used numerous times.\n!       Sc3 = Sc (1./3.)\n! \n! !..Compute min ice diam from mass, min snow/graupel mass from diam.\n!       D0i = (xm0i/am_i) (1./bm_i)\n!       xm0s = am_s * D0s bm_s\n!       xm0g = am_g * D0g bm_g\n! \n! !..These constants various exponents and gamma() assoc with cloud,\n! !.. rain, snow, and graupel.\n!       cce(1) = mu_c + 1.\n!       cce(2) = bm_r + mu_c + 1.\n!       cce(3) = bm_r + mu_c + 4.\n!       ccg(1) = WGAMMA(cce(1))\n!       ccg(2) = WGAMMA(cce(2))\n!       ccg(3) = WGAMMA(cce(3))\n!       ocg1 = 1./ccg(1)\n!       ocg2 = 1./ccg(2)\n! \n!       cie(1) = mu_i + 1.\n!       cie(2) = bm_i + mu_i + 1.\n!       cie(3) = bm_i + mu_i + bv_i + 1.\n!       cie(4) = mu_i + bv_i + 1.\n!       cie(5) = mu_i + 2.\n!       cie(6) = bm_i 0.5 + mu_i + bv_i + 1.\n!       cie(7) = bm_i 0.5 + mu_i + 1.\n!       cig(1) = WGAMMA(cie(1))\n!       cig(2) = WGAMMA(cie(2))\n!       cig(3) = WGAMMA(cie(3))\n!       cig(4) = WGAMMA(cie(4))\n!       cig(5) = WGAMMA(cie(5))\n!       cig(6) = WGAMMA(cie(6))\n!       cig(7) = WGAMMA(cie(7))\n!       oig1 = 1./cig(1)\n!       oig2 = 1./cig(2)\n!       obmi = 1./bm_i\n! \n!       cre(1) = bm_r + 1.\n!       cre(2) = mu_r + 1.\n!       cre(3) = bm_r + mu_r + 1.\n!       cre(4) = bm_r 2. + mu_r + 1.\n!       cre(5) = mu_r + bv_r + 1.\n!       cre(6) = bm_r + mu_r + bv_r + 1.\n!       cre(7) = bm_r 0.5 + mu_r + bv_r + 1.\n!       cre(8) = bm_r + mu_r + bv_r + 3.\n!       cre(9) = mu_r + bv_r + 3.\n!       cre(10) = mu_r + 2.\n!       cre(11) = 0.5 (bv_r + 5. + 2. mu_r)\n!       cre(12) = bm_r 0.5 + mu_r + 1.\n!       cre(13) = bm_r 2. + mu_r + bv_r + 1.\n!       do n = 1, 13\n!          crg(n) = WGAMMA(cre(n))\n!       enddo\n!       obmr = 1./bm_r\n!       ore1 = 1./cre(1)\n!       org1 = 1./crg(1)\n!       org2 = 1./crg(2)\n!       org3 = 1./crg(3)\n! \n!       cse(1) = bm_s + 1.\n!       cse(2) = bm_s + 2.\n!       cse(3) = bm_s 2.\n!       cse(4) = bm_s + bv_s + 1.\n!       cse(5) = bm_s 2. + bv_s + 1.\n!       cse(6) = bm_s 2. + 1.\n!       cse(7) = bm_s + mu_s + 1.\n!       cse(8) = bm_s + mu_s + 2.\n!       cse(9) = bm_s + mu_s + 3.\n!       cse(10) = bm_s + mu_s + bv_s + 1.\n!       cse(11) = bm_s 2. + mu_s + bv_s + 1.\n!       cse(12) = bm_s 2. + mu_s + 1.\n!       cse(13) = bv_s + 2.\n!       cse(14) = bm_s + bv_s\n!       cse(15) = mu_s + 1.\n!       cse(16) = 1.0 + (1.0 + bv_s)/2.\n!       cse(17) = cse(16) + mu_s + 1.\n!       cse(18) = bv_s + mu_s + 3.\n!       do n = 1, 18\n!          csg(n) = WGAMMA(cse(n))\n!       enddo\n!       oams = 1./am_s\n!       obms = 1./bm_s\n!       ocms = oams obms\n! \n!       cge(1) = bm_g + 1.\n!       cge(2) = mu_g + 1.\n!       cge(3) = bm_g + mu_g + 1.\n!       cge(4) = bm_g 2. + mu_g + 1.\n!       cge(5) = bm_g 2. + mu_g + bv_g + 1.\n!       cge(6) = bm_g + mu_g + bv_g + 1.\n!       cge(7) = bm_g + mu_g + bv_g + 2.\n!       cge(8) = bm_g + mu_g + bv_g + 3.\n!       cge(9) = mu_g + bv_g + 3.\n!       cge(10) = mu_g + 2.\n!       cge(11) = 0.5 (bv_g + 5. + 2. mu_g)\n!       cge(12) = 0.5*(bv_g + 5.) + mu_g\n!       do n = 1, 12\n!          cgg(n) = WGAMMA(cge(n))\n!       enddo\n!       oamg = 1./am_g\n!       obmg = 1./bm_g\n!       ocmg = oamg obmg\n!       oge1 = 1./cge(1)\n!       ogg1 = 1./cgg(1)\n!       ogg2 = 1./cgg(2)\n!       ogg3 = 1./cgg(3)\n! \n! !+---+-----------------------------------------------------------------+\n! !..Simplify various rate eqns the best we can now.\n! !+---+-----------------------------------------------------------------+\n! \n! !..Rain collecting cloud water and cloud ice\n!       t1_qr_qc = PI2 .25 av_r * crg(9)\n!       t1_qr_qi = PI2 .25 av_r * crg(9)\n!       t2_qr_qi = PI2 .25 am_r av_r * crg(8)\n! \n! !..Graupel collecting cloud water\n!       t1_qg_qc = PI2 .25 av_g * cgg(9)\n! \n! !..Snow collecting cloud water\n!       t1_qs_qc = PI2 .25 av_s\n! \n! !..Snow collecting cloud ice\n!       t1_qs_qi = PI2 .25 av_s\n! \n! !..Evaporation of rain; ignore depositional growth of rain.\n!       t1_qr_ev = 0.78 * crg(10)\n!       t2_qr_ev = 0.308 Sc3 SQRT(av_r) * crg(11)\n! !..Sublimation/depositional growth of snow\n!       t1_qs_sd = 0.86\n!       t2_qs_sd = 0.28 Sc3 SQRT(av_s)\n! \n! !..Melting of snow\n!       t1_qs_me = PI2 4. C_sqrd olfus * 0.86\n!       t2_qs_me = PI2 4. C_sqrd olfus * 0.28 Sc3 SQRT(av_s)\n! \n! !..Sublimation/depositional growth of graupel\n!       t1_qg_sd = 0.86 * cgg(10)\n!       t2_qg_sd = 0.28 Sc3 SQRT(av_g) * cgg(11)\n! \n! !..Melting of graupel\n!       t1_qg_me = PI2 4. C_cube olfus * 0.86 * cgg(10)\n!       t2_qg_me = PI2 4. C_cube olfus * 0.28 Sc3 SQRT(av_g) * cgg(11)\n! \n! !..Constants for helping find lookup table indexes.\n!       nic2 = NINT(ALOG10(r_c(1)))\n!       nii2 = NINT(ALOG10(r_i(1)))\n!       nii3 = NINT(ALOG10(Nt_i(1)))\n!       nir2 = NINT(ALOG10(r_r(1)))\n!       nir3 = NINT(ALOG10(N0r_exp(1)))\n!       nis2 = NINT(ALOG10(r_s(1)))\n!       nig2 = NINT(ALOG10(r_g(1)))\n!       nig3 = NINT(ALOG10(N0g_exp(1)))\n! \n! !..Create bins of cloud water (from min diameter up to 100 microns).\n!       Dc(1) = D0c 1.0d0\n!       dtc(1) = D0c 1.0d0\n!       do n = 2, nbc\n!          Dc(n) = Dc(n-1) + 1.0D-6\n!          dtc(n) = (Dc(n) - Dc(n-1))\n!       enddo\n! \n! !..Create bins of cloud ice (from min diameter up to 5x min snow size).\n!       xDx(1) = D0i 1.0d0\n!       xDx(nbi+1) = 5.0d0 D0s\n!       do n = 2, nbi\n!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbi) &\n! DLOG(xDx(nbi+1)/xDx(1)) +DLOG(xDx(1)))\n!       enddo\n!       do n = 1, nbi\n!          Di(n) = DSQRT(xDx(n) xDx(n+1))\n!          dti(n) = xDx(n+1) - xDx(n)\n!       enddo\n! \n! !..Create bins of rain (from min diameter up to 5 mm).\n!       xDx(1) = D0r 1.0d0\n!       xDx(nbr+1) = 0.005d0\n!       do n = 2, nbr\n!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) &\n! DLOG(xDx(nbr+1)/xDx(1)) +DLOG(xDx(1)))\n!       enddo\n!       do n = 1, nbr\n!          Dr(n) = DSQRT(xDx(n) xDx(n+1))\n!          dtr(n) = xDx(n+1) - xDx(n)\n!       enddo\n! \n! !..Create bins of snow (from min diameter up to 2 cm).\n!       xDx(1) = D0s 1.0d0\n!       xDx(nbs+1) = 0.02d0\n!       do n = 2, nbs\n!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) &\n! DLOG(xDx(nbs+1)/xDx(1)) +DLOG(xDx(1)))\n!       enddo\n!       do n = 1, nbs\n!          Ds(n) = DSQRT(xDx(n) xDx(n+1))\n!          dts(n) = xDx(n+1) - xDx(n)\n!       enddo\n! \n! !..Create bins of graupel (from min diameter up to 5 cm).\n!       xDx(1) = D0g 1.0d0\n!       xDx(nbg+1) = 0.05d0\n!       do n = 2, nbg\n!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) &\n! DLOG(xDx(nbg+1)/xDx(1)) +DLOG(xDx(1)))\n!       enddo\n!       do n = 1, nbg\n!          Dg(n) = DSQRT(xDx(n) xDx(n+1))\n!          dtg(n) = xDx(n+1) - xDx(n)\n!       enddo\n! \n! !+---+-----------------------------------------------------------------+\n! !..Create lookup tables for most costly calculations.\n! !+---+-----------------------------------------------------------------+\n! \n!       do m = 1, ntb_r\n!          do k = 1, ntb_r1\n!             do j = 1, ntb_g\n!                do i = 1, ntb_g1\n!                   tcg_racg(i,j,k,m) = 0.0d0\n!                   tmr_racg(i,j,k,m) = 0.0d0\n!                   tcr_gacr(i,j,k,m) = 0.0d0\n!                   tmg_gacr(i,j,k,m) = 0.0d0\n!                   tnr_racg(i,j,k,m) = 0.0d0\n!                   tnr_gacr(i,j,k,m) = 0.0d0\n!                enddo\n!             enddo\n!          enddo\n!       enddo\n! \n!       do m = 1, ntb_r\n!          do k = 1, ntb_r1\n!             do j = 1, ntb_t\n!                do i = 1, ntb_s\n!                   tcs_racs1(i,j,k,m) = 0.0d0\n!                   tmr_racs1(i,j,k,m) = 0.0d0\n!                   tcs_racs2(i,j,k,m) = 0.0d0\n!                   tmr_racs2(i,j,k,m) = 0.0d0\n!                   tcr_sacr1(i,j,k,m) = 0.0d0\n!                   tms_sacr1(i,j,k,m) = 0.0d0\n!                   tcr_sacr2(i,j,k,m) = 0.0d0\n!                   tms_sacr2(i,j,k,m) = 0.0d0\n!                   tnr_racs1(i,j,k,m) = 0.0d0\n!                   tnr_racs2(i,j,k,m) = 0.0d0\n!                   tnr_sacr1(i,j,k,m) = 0.0d0\n!                   tnr_sacr2(i,j,k,m) = 0.0d0\n!                enddo\n!             enddo\n!          enddo\n!       enddo\n! \n!       do k = 1, 45\n!          do j = 1, ntb_r1\n!             do i = 1, ntb_r\n!                tpi_qrfz(i,j,k) = 0.0d0\n!                tni_qrfz(i,j,k) = 0.0d0\n!                tpg_qrfz(i,j,k) = 0.0d0\n!                tnr_qrfz(i,j,k) = 0.0d0\n!             enddo\n!          enddo\n!          do i = 1, ntb_c\n!             tpi_qcfz(i,k) = 0.0d0\n!             tni_qcfz(i,k) = 0.0d0\n!          enddo\n!       enddo\n! \n!       do j = 1, ntb_i1\n!          do i = 1, ntb_i\n!             tps_iaus(i,j) = 0.0d0\n!             tni_iaus(i,j) = 0.0d0\n!             tpi_ide(i,j) = 0.0d0\n!          enddo\n!       enddo\n! \n!       do j = 1, nbc\n!          do i = 1, nbr\n!             t_Efrw(i,j) = 0.0\n!          enddo\n!          do i = 1, nbs\n!             t_Efsw(i,j) = 0.0\n!          enddo\n!       enddo\n! \n!       do k = 1, ntb_r\n!          do j = 1, ntb_r1\n!             do i = 1, nbr\n!                tnr_rev(i,j,k) = 0.0d0\n!             enddo\n!          enddo\n!       enddo\n! \n! !       CALL wrf_debug(150, 'CREATING MICROPHYSICS LOOKUP TABLES ... ')\n! !       WRITE (wrf_err_message, '(a, f5.2, a, f5.2, a, f5.2, a, f5.2)') &\n! !           ' using: mu_c=',mu_c,' mu_i=',mu_i,' mu_r=',mu_r,' mu_g=',mu_g\n! !       CALL wrf_debug(150, wrf_err_message)\n! \n! !..Collision efficiency between rain/snow and cloud water.\n! !       CALL wrf_debug(200, '  creating qc collision eff tables')\n!       call table_Efrw\n!       call table_Efsw\n! \n! !..Drop evaporation.\n! !     CALL wrf_debug(200, '  creating rain evap table')\n! !     call table_dropEvap\n! \n! !..Initialize various constants for computing radar reflectivity.\n! !       xam_r = am_r\n! !       xbm_r = bm_r\n! !       xmu_r = mu_r\n! !       xam_s = am_s\n! !       xbm_s = bm_s\n! !       xmu_s = mu_s\n! !       xam_g = am_g\n! !       xbm_g = bm_g\n! !       xmu_g = mu_g\n! !       call radar_init\n! \n!       if (.not. iiwarm) then\n! \n! !..Rain collecting graupel & graupel collecting rain.\n!       ! CALL wrf_debug(200, '  creating rain collecting graupel table')\n!       call qr_acr_qg\n! \n! !..Rain collecting snow & snow collecting rain.\n!       ! CALL wrf_debug(200, '  creating rain collecting snow table')\n!       call qr_acr_qs\n! \n! !..Cloud water and rain freezing (Bigg, 1953).\n!       ! CALL wrf_debug(200, '  creating freezing of water drops table')\n!       call freezeH2O\n! \n! !..Conversion of some ice mass into snow category.\n!       ! CALL wrf_debug(200, '  creating ice converting to snow table')\n!       call qi_aut_qs\n! \n!       endif\n! \n!       ! CALL wrf_debug(150, ' ... DONE microphysical lookup tables')\n! \n!       endif\n! \n!       END SUBROUTINE thompson_init Used by module~~module_mp_thompson~~UsedByGraph module~module_mp_thompson module_mp_thompson module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~module_mp_thompson program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Dc Dg Di Dr Ds dtc dtg dti dtr dts mp_debug t1_qg_me t1_qg_qc t1_qg_sd t1_qr_ev t1_qr_qc t1_qr_qi t1_qs_me t1_qs_qc t1_qs_qi t1_qs_sd t2_qg_me t2_qg_sd t2_qr_ev t2_qr_qi t2_qs_me t2_qs_sd t_Efrw t_Efsw tcg_racg tcr_gacr tcr_sacr1 tcr_sacr2 tcs_racs1 tcs_racs2 tmg_gacr tmr_racg tmr_racs1 tmr_racs2 tms_sacr1 tms_sacr2 tni_iaus tni_qcfz tni_qrfz tnr_gacr tnr_qrfz tnr_racg tnr_racs1 tnr_racs2 tnr_rev tnr_sacr1 tnr_sacr2 tpg_qrfz tpi_ide tpi_qcfz tpi_qrfz tps_iaus xDx ATO C_cube C_cubes C_sqrd Cp2 D0c D0g D0i D0r D0s Ef_rg Ef_ri Ef_rs Ef_rw_l Ef_si Ef_sw_l HGFR IFDRY Kap0 Kap1 Lam0 Lam1 N0g_exp N0r_exp Nt_c Nt_i PI2 R1 R2 R8SIZE RR2 Rv Sc Sc3 TNO T_0 Tc am_g am_i am_r am_s av_g av_i av_r av_s bm_g bm_i bm_r bm_s bv_g bv_i bv_r bv_s cce ccg cge cgg cie cig cre crg cse csg eps fv_r fv_s gonv_max gonv_min iiwarm lfus lsub lvap0 mu_c mu_g mu_i mu_r mu_s nbc nbg nbi nbins nbr nbs nic2 nig2 nig3 nii2 nii3 nir2 nir3 nis2 ntb_c ntb_g ntb_g1 ntb_i ntb_i1 ntb_r ntb_r1 ntb_s ntb_t oRv oamg oams obmg obmi obmr obms ocg1 ocg2 ocmg ocms oge1 ogg1 ogg2 ogg3 oig1 oig2 olfus ore1 org1 org2 org3 r_c r_g r_i r_r r_s rho_g rho_i rho_not rho_s rho_w sa sb t_adjust xm0g xm0i xm0s Functions GAMMLN GAMMP RSIF RSLF WGAMMA Subroutines GCF GSER freezeH2O mp_gt_driver mp_thompson qi_aut_qs qr_acr_qg qr_acr_qs table_Efrw table_Efsw table_dropEvap Variables Type Visibility Attributes Name Initial double precision, public, DIMENSION(nbc) :: Dc double precision, public, DIMENSION(nbg) :: Dg double precision, public, DIMENSION(nbi) :: Di double precision, public, DIMENSION(nbr) :: Dr double precision, public, DIMENSION(nbs) :: Ds double precision, public, DIMENSION(nbc) :: dtc double precision, public, DIMENSION(nbg) :: dtg double precision, public, DIMENSION(nbi) :: dti double precision, public, DIMENSION(nbr) :: dtr double precision, public, DIMENSION(nbs) :: dts character(len=256), public :: mp_debug real, public :: t1_qg_me real, public :: t1_qg_qc real, public :: t1_qg_sd real, public :: t1_qr_ev real, public :: t1_qr_qc real, public :: t1_qr_qi real, public :: t1_qs_me real, public :: t1_qs_qc real, public :: t1_qs_qi real, public :: t1_qs_sd real, public :: t2_qg_me real, public :: t2_qg_sd real, public :: t2_qr_ev real, public :: t2_qr_qi real, public :: t2_qs_me real, public :: t2_qs_sd real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: t_Efrw real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: t_Efsw real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcg_racg real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcr_gacr real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcr_sacr1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcr_sacr2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcs_racs1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tcs_racs2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tmg_gacr real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tmr_racg real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tmr_racs1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tmr_racs2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tms_sacr1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tms_sacr2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: tni_iaus real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: tni_qcfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:) :: tni_qrfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_gacr real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:) :: tnr_qrfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_racg real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_racs1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_racs2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:) :: tnr_rev real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_sacr1 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:,:) :: tnr_sacr2 real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:) :: tpg_qrfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: tpi_ide real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: tpi_qcfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:,:) :: tpi_qrfz real(kind=R8SIZE), public, ALLOCATABLE, DIMENSION(:,:) :: tps_iaus double precision, public, DIMENSION(nbins+1) :: xDx real, private, parameter :: ATO = 0.304 real, private, parameter :: C_cube = 0.5 real, private :: C_cubes real, private :: C_sqrd real, private, parameter :: Cp2 = 1004.0 real, private, parameter :: D0c = 1.E-6 real, private, parameter :: D0g = 250.E-6 real, private :: D0i real, private, parameter :: D0r = 50.E-6 real, private, parameter :: D0s = 200.E-6 real, private :: Ef_rg real, private :: Ef_ri real, private :: Ef_rs logical, private :: Ef_rw_l real, private :: Ef_si logical, private :: Ef_sw_l real, private, parameter :: HGFR = 235.16 integer, private, parameter :: IFDRY = 0 real, private, parameter :: Kap0 = 490.6 real, private, parameter :: Kap1 = 17.46 real, private, parameter :: Lam0 = 20.78 real, private, parameter :: Lam1 = 3.29 real, private, parameter, DIMENSION(ntb_g1) :: N0g_exp = (/1.e4, 2.e4, 3.e4, 4.e4, 5.e4, 6.e4, 7.e4, 8.e4, 9.e4, 1.e5, 2.e5, 3.e5, 4.e5, 5.e5, 6.e5, 7.e5, 8.e5, 9.e5, 1.e6, 2.e6, 3.e6, 4.e6, 5.e6, 6.e6, 7.e6, 8.e6, 9.e6, 1.e7/) real, private, parameter, DIMENSION(ntb_r1) :: N0r_exp = (/1.e6, 2.e6, 3.e6, 4.e6, 5.e6, 6.e6, 7.e6, 8.e6, 9.e6, 1.e7, 2.e7, 3.e7, 4.e7, 5.e7, 6.e7, 7.e7, 8.e7, 9.e7, 1.e8, 2.e8, 3.e8, 4.e8, 5.e8, 6.e8, 7.e8, 8.e8, 9.e8, 1.e9, 2.e9, 3.e9, 4.e9, 5.e9, 6.e9, 7.e9, 8.e9, 9.e9, 1.e10/) real, private :: Nt_c real, private, parameter, DIMENSION(ntb_i1) :: Nt_i = (/1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 1.e1, 2.e1, 3.e1, 4.e1, 5.e1, 6.e1, 7.e1, 8.e1, 9.e1, 1.e2, 2.e2, 3.e2, 4.e2, 5.e2, 6.e2, 7.e2, 8.e2, 9.e2, 1.e3, 2.e3, 3.e3, 4.e3, 5.e3, 6.e3, 7.e3, 8.e3, 9.e3, 1.e4, 2.e4, 3.e4, 4.e4, 5.e4, 6.e4, 7.e4, 8.e4, 9.e4, 1.e5, 2.e5, 3.e5, 4.e5, 5.e5, 6.e5, 7.e5, 8.e5, 9.e5, 1.e6/) real, private, parameter :: PI2 = 3.1415926536 real, private, parameter :: R1 = 1.E-12 real, private, parameter :: R2 = 1.E-6 integer, private, parameter :: R8SIZE = 8 real, private, parameter :: RR2 = 287.04 real, private, parameter :: Rv = 461.5 real, private, parameter :: Sc = 0.632 real, private :: Sc3 real, private :: TNO real, private, parameter :: T_0 = 273.15 real, private, parameter, DIMENSION(ntb_t) :: Tc = (/-0.01, -5., -10., -15., -20., -25., -30., -35., -40./) real, private :: am_g real, private, parameter :: am_i = PI2*rho_i/6.0 real, private, parameter :: am_r = PI2*rho_w/6.0 real, private :: am_s real, private :: av_g real, private :: av_i real, private, parameter :: av_r = 4854.0 real, private :: av_s real, private, parameter :: bm_g = 3.0 real, private, parameter :: bm_i = 3.0 real, private, parameter :: bm_r = 3.0 real, private, parameter :: bm_s = 2.0 real, private :: bv_g real, private, parameter :: bv_i = 1.0 real, private, parameter :: bv_r = 1.0 real, private :: bv_s real, private, DIMENSION(3) :: cce real, private, DIMENSION(3) :: ccg real, private, DIMENSION(12) :: cge real, private, DIMENSION(12) :: cgg real, private, DIMENSION(7) :: cie real, private, DIMENSION(7) :: cig real, private, DIMENSION(13) :: cre real, private, DIMENSION(13) :: crg real, private, DIMENSION(18) :: cse real, private, DIMENSION(18) :: csg real, private, parameter :: eps = 1.E-15 real, private, parameter :: fv_r = 195.0 real, private :: fv_s real, private, parameter :: gonv_max = 3.E6 real, private, parameter :: gonv_min = 1.E4 logical, private, parameter :: iiwarm = .false. real, private, parameter :: lfus = lsub-lvap0 real, private, parameter :: lsub = 2.834E6 real, private, parameter :: lvap0 = 2.5E6 real, private :: mu_c real, private, parameter :: mu_g = 0.0 real, private, parameter :: mu_i = 0.0 real, private :: mu_r real, private, parameter :: mu_s = 0.6357 integer, private, parameter :: nbc = nbins integer, private, parameter :: nbg = nbins integer, private, parameter :: nbi = nbins integer, private, parameter :: nbins = 100 integer, private, parameter :: nbr = nbins integer, private, parameter :: nbs = nbins integer, private :: nic2 integer, private :: nig2 integer, private :: nig3 integer, private :: nii2 integer, private :: nii3 integer, private :: nir2 integer, private :: nir3 integer, private :: nis2 integer, private, parameter :: ntb_c = 37 integer, private, parameter :: ntb_g = 28 integer, private, parameter :: ntb_g1 = 28 integer, private, parameter :: ntb_i = 64 integer, private, parameter :: ntb_i1 = 55 integer, private, parameter :: ntb_r = 37 integer, private, parameter :: ntb_r1 = 37 integer, private, parameter :: ntb_s = 28 integer, private, parameter :: ntb_t = 9 real, private, parameter :: oRv = 1./Rv real, private :: oamg real, private :: oams real, private :: obmg real, private :: obmi real, private :: obmr real, private :: obms real, private :: ocg1 real, private :: ocg2 real, private :: ocmg real, private :: ocms real, private :: oge1 real, private :: ogg1 real, private :: ogg2 real, private :: ogg3 real, private :: oig1 real, private :: oig2 real, private, parameter :: olfus = 1./lfus real, private :: ore1 real, private :: org1 real, private :: org2 real, private :: org3 real, private, parameter, DIMENSION(ntb_c) :: r_c = (/1.e-6, 2.e-6, 3.e-6, 4.e-6, 5.e-6, 6.e-6, 7.e-6, 8.e-6, 9.e-6, 1.e-5, 2.e-5, 3.e-5, 4.e-5, 5.e-5, 6.e-5, 7.e-5, 8.e-5, 9.e-5, 1.e-4, 2.e-4, 3.e-4, 4.e-4, 5.e-4, 6.e-4, 7.e-4, 8.e-4, 9.e-4, 1.e-3, 2.e-3, 3.e-3, 4.e-3, 5.e-3, 6.e-3, 7.e-3, 8.e-3, 9.e-3, 1.e-2/) real, private, parameter, DIMENSION(ntb_g) :: r_g = (/1.e-5, 2.e-5, 3.e-5, 4.e-5, 5.e-5, 6.e-5, 7.e-5, 8.e-5, 9.e-5, 1.e-4, 2.e-4, 3.e-4, 4.e-4, 5.e-4, 6.e-4, 7.e-4, 8.e-4, 9.e-4, 1.e-3, 2.e-3, 3.e-3, 4.e-3, 5.e-3, 6.e-3, 7.e-3, 8.e-3, 9.e-3, 1.e-2/) real, private, parameter, DIMENSION(ntb_i) :: r_i = (/1.e-10, 2.e-10, 3.e-10, 4.e-10, 5.e-10, 6.e-10, 7.e-10, 8.e-10, 9.e-10, 1.e-9, 2.e-9, 3.e-9, 4.e-9, 5.e-9, 6.e-9, 7.e-9, 8.e-9, 9.e-9, 1.e-8, 2.e-8, 3.e-8, 4.e-8, 5.e-8, 6.e-8, 7.e-8, 8.e-8, 9.e-8, 1.e-7, 2.e-7, 3.e-7, 4.e-7, 5.e-7, 6.e-7, 7.e-7, 8.e-7, 9.e-7, 1.e-6, 2.e-6, 3.e-6, 4.e-6, 5.e-6, 6.e-6, 7.e-6, 8.e-6, 9.e-6, 1.e-5, 2.e-5, 3.e-5, 4.e-5, 5.e-5, 6.e-5, 7.e-5, 8.e-5, 9.e-5, 1.e-4, 2.e-4, 3.e-4, 4.e-4, 5.e-4, 6.e-4, 7.e-4, 8.e-4, 9.e-4, 1.e-3/) real, private, parameter, DIMENSION(ntb_r) :: r_r = (/1.e-6, 2.e-6, 3.e-6, 4.e-6, 5.e-6, 6.e-6, 7.e-6, 8.e-6, 9.e-6, 1.e-5, 2.e-5, 3.e-5, 4.e-5, 5.e-5, 6.e-5, 7.e-5, 8.e-5, 9.e-5, 1.e-4, 2.e-4, 3.e-4, 4.e-4, 5.e-4, 6.e-4, 7.e-4, 8.e-4, 9.e-4, 1.e-3, 2.e-3, 3.e-3, 4.e-3, 5.e-3, 6.e-3, 7.e-3, 8.e-3, 9.e-3, 1.e-2/) real, private, parameter, DIMENSION(ntb_s) :: r_s = (/1.e-5, 2.e-5, 3.e-5, 4.e-5, 5.e-5, 6.e-5, 7.e-5, 8.e-5, 9.e-5, 1.e-4, 2.e-4, 3.e-4, 4.e-4, 5.e-4, 6.e-4, 7.e-4, 8.e-4, 9.e-4, 1.e-3, 2.e-3, 3.e-3, 4.e-3, 5.e-3, 6.e-3, 7.e-3, 8.e-3, 9.e-3, 1.e-2/) real, private :: rho_g real, private, parameter :: rho_i = 890.0 real, private, parameter :: rho_not = 101325.0/(287.05*298.0) real, private, parameter :: rho_s = 100.0 real, private, parameter :: rho_w = 1000.0 real, private, parameter, DIMENSION(10) :: sa = (/5.065339, -0.062659, -3.032362, 0.029469, -0.000285, 0.31255, 0.000204, 0.003199, 0.0, -0.015952/) real, private, parameter, DIMENSION(10) :: sb = (/0.476221, -0.015896, 0.165977, 0.007468, -0.000141, 0.060366, 0.000079, 0.000594, 0.0, -0.003577/) real, private :: t_adjust real, private :: xm0g real, private, parameter :: xm0i = 1.E-12 real, private :: xm0s Functions public function GAMMLN (XX) Arguments Type Intent Optional Attributes Name real, intent(in) :: XX Return Value real public function GAMMP (A, X) Arguments Type Intent Optional Attributes Name real, intent(in) :: A real, intent(in) :: X Return Value real public function RSIF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real public function RSLF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real public function WGAMMA (y) Arguments Type Intent Optional Attributes Name real, intent(in) :: y Return Value real Subroutines public subroutine GCF (GAMMCF, A, X, GLN) Arguments Type Intent Optional Attributes Name real :: GAMMCF real, intent(in) :: A real, intent(in) :: X real :: GLN public subroutine GSER (GAMSER, A, X, GLN) Arguments Type Intent Optional Attributes Name real :: GAMSER real, intent(in) :: A real, intent(in) :: X real :: GLN public subroutine freezeH2O () Arguments None public subroutine mp_gt_driver (qv, qc, qr, qi, qs, qg, ni, nr, th, pii, p, dz, dt_in, itimestep, RAINNC, RAINNCV, SNOWNC, SNOWNCV, GRAUPELNC, GRAUPELNCV, SR, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte) Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qv real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qc real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qr real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qi real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qs real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: qg real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: ni real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: nr real, intent(inout), DIMENSION(ims:ime, kms:kme, jms:jme) :: th real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: pii real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: p real, intent(in), DIMENSION(ims:ime, kms:kme, jms:jme) :: dz real, intent(in) :: dt_in integer, intent(in) :: itimestep real, intent(inout), DIMENSION(ims:ime, jms:jme) :: RAINNC real, intent(inout), DIMENSION(ims:ime, jms:jme) :: RAINNCV real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: SNOWNC real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: SNOWNCV real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: GRAUPELNC real, intent(inout), optional DIMENSION(ims:ime, jms:jme) :: GRAUPELNCV real, intent(inout), DIMENSION(ims:ime, jms:jme) :: SR integer, intent(in) :: ids integer, intent(in) :: ide integer, intent(in) :: jds integer, intent(in) :: jde integer, intent(in) :: kds integer, intent(in) :: kde integer, intent(in) :: ims integer, intent(in) :: ime integer, intent(in) :: jms integer, intent(in) :: jme integer, intent(in) :: kms integer, intent(in) :: kme integer, intent(in) :: its integer, intent(in) :: ite integer, intent(in) :: jts integer, intent(in) :: jte integer, intent(in) :: kts integer, intent(in) :: kte public subroutine mp_thompson (qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, nr1d, t1d, p1d, dzq, pptrain, pptsnow, pptgraul, pptice, kts, kte, dt, ii, jj) -- trude Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(kts:kte) :: qv1d real, intent(inout), DIMENSION(kts:kte) :: qc1d real, intent(inout), DIMENSION(kts:kte) :: qi1d real, intent(inout), DIMENSION(kts:kte) :: qr1d real, intent(inout), DIMENSION(kts:kte) :: qs1d real, intent(inout), DIMENSION(kts:kte) :: qg1d real, intent(inout), DIMENSION(kts:kte) :: ni1d real, intent(inout), DIMENSION(kts:kte) :: nr1d real, intent(inout), DIMENSION(kts:kte) :: t1d real, intent(inout), DIMENSION(kts:kte) :: p1d real, intent(in), DIMENSION(kts:kte) :: dzq real, intent(inout) :: pptrain real, intent(inout) :: pptsnow real, intent(inout) :: pptgraul real, intent(inout) :: pptice integer, intent(in) :: kts integer, intent(in) :: kte real, intent(in) :: dt integer, intent(in) :: ii integer, intent(in) :: jj public subroutine qi_aut_qs () Arguments None public subroutine qr_acr_qg () Arguments None public subroutine qr_acr_qs () Arguments None public subroutine table_Efrw () Arguments None public subroutine table_Efsw () Arguments None public subroutine table_dropEvap () Arguments None","tags":"","loc":"module/module_mp_thompson.html"},{"title":"training_configuration_s – Inference-Engine","text":"Uses assert_m inference_engine_m Ancestors: training_configuration_m module~~training_configuration_s~~UsesGraph module~training_configuration_s training_configuration_s assert_m assert_m module~training_configuration_s->assert_m module~inference_engine_m inference_engine_m module~training_configuration_s->module~inference_engine_m module~training_configuration_m training_configuration_m module~training_configuration_s->module~training_configuration_m module~inference_engine_m->module~training_configuration_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m sourcery_m sourcery_m module~training_configuration_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->sourcery_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~tensor_m module~input_output_pair_m->module~kind_parameters_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables footer header separator Module Procedures differentiable_activation_strategy equals from_components from_file learning_rate mini_batches nodes_per_layer optimizer_name skip_connections to_json Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: footer = \"}\" character(len=*), private, parameter :: header = \"{\" character(len=*), private, parameter :: separator = \",\" Module Procedures module procedure differentiable_activation_strategy module module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable module procedure equals elemental module module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical module procedure from_components module procedure from_components() Arguments None module procedure from_file module procedure from_file() Arguments None module procedure learning_rate elemental module module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) module procedure mini_batches elemental module module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer module procedure nodes_per_layer module module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) module procedure optimizer_name elemental module module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure skip_connections elemental module module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical module procedure to_json pure module module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"module/training_configuration_s.html"},{"title":"relu_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: relu_m module~~relu_s~~UsesGraph module~relu_s relu_s module~kind_parameters_m kind_parameters_m module~relu_s->module~kind_parameters_m module~relu_m relu_m module~relu_s->module~relu_m module~relu_m->module~kind_parameters_m sourcery_m sourcery_m module~relu_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables one zero Module Procedures activation activation_derivative function_name Variables Type Visibility Attributes Name Initial real(kind=rkind), private, parameter :: one = 1._rkind real(kind=rkind), private, parameter :: zero = 0._rkind Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/relu_s.html"},{"title":"netCDF_file_s – Inference-Engine","text":"Uses assert_m netcdf Ancestors: NetCDF_file_m module~~netcdf_file_s~~UsesGraph module~netcdf_file_s netCDF_file_s assert_m assert_m module~netcdf_file_s->assert_m netcdf netcdf module~netcdf_file_s->netcdf module~netcdf_file_m NetCDF_file_m module~netcdf_file_s->module~netcdf_file_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions get_shape Module Procedures construct input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Module Procedures module procedure construct module procedure construct() Arguments None module procedure input_1D_double module module subroutine input_1D_double(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) module procedure input_2D_integer module module subroutine input_2D_integer(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) module procedure input_3D_real module module subroutine input_3D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) module procedure input_4D_real module module subroutine input_4D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) module procedure input_real_scalar module module subroutine input_real_scalar(self, varname, scalar) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"module/netcdf_file_s.html"},{"title":"tensor_s – Inference-Engine","text":"Uses Ancestors: tensor_m module~~tensor_s~~UsesGraph module~tensor_s tensor_s module~tensor_m tensor_m module~tensor_s->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_components num_components values Module Procedures module procedure construct_from_components module procedure construct_from_components() Arguments None module procedure num_components pure module module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer module procedure values pure module module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/tensor_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses assert_m intrinsic_array_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s assert_m assert_m module~layer_s->assert_m intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m module~layer_m layer_m module~layer_s->module~layer_m sourcery_m sourcery_m module~layer_m->sourcery_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->sourcery_m module~neuron_m->module~kind_parameters_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Module Procedures module procedure construct module procedure construct() Arguments None module procedure count_inputs module module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) module procedure inference_engine module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"module/layer_s.html"},{"title":"hyperparameters_s – Inference-Engine","text":"Uses assert_m Ancestors: hyperparameters_m module~~hyperparameters_s~~UsesGraph module~hyperparameters_s hyperparameters_s assert_m assert_m module~hyperparameters_s->assert_m module~hyperparameters_m hyperparameters_m module~hyperparameters_s->module~hyperparameters_m sourcery_m sourcery_m module~hyperparameters_m->sourcery_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables learning_rate_key mini_batches_key optimizer_key Module Procedures equals from_components from_json learning_rate mini_batches optimizer_name to_json Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: learning_rate_key = \"learning rate\" character(len=*), private, parameter :: mini_batches_key = \"mini-batches\" character(len=*), private, parameter :: optimizer_key = \"optimizer\" Module Procedures module procedure equals elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical module procedure from_components module procedure from_components() Arguments None module procedure from_json module procedure from_json() Arguments None module procedure learning_rate elemental module module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) module procedure mini_batches elemental module module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer module procedure optimizer_name elemental module module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) module procedure to_json pure module module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"module/hyperparameters_s.html"},{"title":"mini_batch_s – Inference-Engine","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct input_output_pairs Module Procedures module procedure construct module procedure construct() Arguments None module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses relu_m layer_m sourcery_m swish_m sigmoid_m assert_m neuron_m step_m Ancestors: inference_engine_m_ module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s module~swish_m swish_m module~inference_engine_s->module~swish_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m assert_m assert_m module~inference_engine_s->assert_m module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m module~step_m step_m module~inference_engine_s->module~step_m module~relu_m relu_m module~inference_engine_s->module~relu_m sourcery_m sourcery_m module~inference_engine_s->sourcery_m module~layer_m layer_m module~inference_engine_s->module~layer_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_s->module~inference_engine_m_ module~swish_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m module~neuron_m->sourcery_m module~neuron_m->module~kind_parameters_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~relu_m->sourcery_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~layer_m->module~neuron_m module~layer_m->sourcery_m module~layer_m->module~inference_engine_m_ module~layer_m->module~kind_parameters_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces assert_consistency Subroutines set_activation_strategy Module Subroutines difference_consistency inference_engine_consistency Module Procedures activation_function_name assert_conformable_with construct_from_json construct_from_padded_arrays infer nodes_per_layer norm num_inputs num_outputs skip subtract to_exchange to_json Interfaces interface assert_consistency pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Subroutines pure subroutine set_activation_strategy (inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Module Subroutines pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Module Procedures module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine module procedure construct_from_json module procedure construct_from_json() Arguments None module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure skip pure module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) module procedure to_exchange pure module module function to_exchange(self) result(exchange) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/inference_engine_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m sourcery_m sourcery_m module~neuron_m->sourcery_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bias construct next_allocated next_pointer num_inputs weights Module Procedures module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure construct module procedure construct() Arguments None module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m sourcery_m sourcery_m module~step_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/step_s.html"},{"title":"network_configuration_s – Inference-Engine","text":"Uses assert_m sourcery_m Ancestors: network_configuration_m module~~network_configuration_s~~UsesGraph module~network_configuration_s network_configuration_s assert_m assert_m module~network_configuration_s->assert_m sourcery_m sourcery_m module~network_configuration_s->sourcery_m module~network_configuration_m network_configuration_m module~network_configuration_s->module~network_configuration_m module~network_configuration_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name_key nodes_per_layer_key skip_connections_key Module Procedures activation_name equals from_components from_json nodes_per_layer skip_connections to_json Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: activation_name_key = \"activation function\" character(len=*), private, parameter :: nodes_per_layer_key = \"nodes per layer\" character(len=*), private, parameter :: skip_connections_key = \"skip connections\" Module Procedures module procedure activation_name elemental module module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure equals elemental module module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical module procedure from_components module procedure from_components() Arguments None module procedure from_json module procedure from_json() Arguments None module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable, (:) module procedure skip_connections elemental module module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical module procedure to_json pure module module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable, (:)","tags":"","loc":"module/network_configuration_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m sourcery_m sourcery_m module~sigmoid_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/sigmoid_s.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m sourcery_m sourcery_m module~sigmoid_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/swish_s.html"},{"title":"input_output_pair_s – Inference-Engine","text":"Uses assert_m Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s assert_m assert_m module~input_output_pair_s->assert_m module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct expected_outputs inputs shuffle Module Procedures module procedure construct module procedure construct() Arguments None module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure shuffle pure module module subroutine shuffle(pairs, random_numbers) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) real, intent(in) :: random_numbers (2:)","tags":"","loc":"module/input_output_pair_s.html"},{"title":"trainable_engine_s – Inference-Engine","text":"Uses intrinsic_array_m input_output_pair_m tensor_m sigmoid_m assert_m Ancestors: trainable_engine_m module~~trainable_engine_s~~UsesGraph module~trainable_engine_s trainable_engine_s assert_m assert_m module~trainable_engine_s->assert_m module~sigmoid_m sigmoid_m module~trainable_engine_s->module~sigmoid_m module~tensor_m tensor_m module~trainable_engine_s->module~tensor_m module~input_output_pair_m input_output_pair_m module~trainable_engine_s->module~input_output_pair_m intrinsic_array_m intrinsic_array_m module~trainable_engine_s->intrinsic_array_m module~trainable_engine_m trainable_engine_m module~trainable_engine_s->module~trainable_engine_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m sourcery_m sourcery_m module~sigmoid_m->sourcery_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~input_output_pair_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->sourcery_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~differentiable_activation_strategy_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Module Procedures assert_consistent construct_from_inference_engine construct_from_padded_arrays infer num_inputs num_layers num_outputs to_inference_engine train Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self module procedure construct_from_inference_engine module procedure construct_from_inference_engine() Arguments None module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(n_out) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure to_inference_engine pure module module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) module procedure train pure module module subroutine train(self, mini_batches, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"module/trainable_engine_s.html"},{"title":"train_polynomials – Inference-Engine","text":"Uses multiply_inputs assert_m inference_engine_m sourcery_m program~~train_polynomials~~UsesGraph program~train_polynomials train_polynomials module~multiply_inputs multiply_inputs program~train_polynomials->module~multiply_inputs module~inference_engine_m inference_engine_m program~train_polynomials->module~inference_engine_m assert_m assert_m program~train_polynomials->assert_m sourcery_m sourcery_m program~train_polynomials->sourcery_m module~multiply_inputs->module~inference_engine_m module~multiply_inputs->assert_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~train_polynomials~~CallsGraph program~train_polynomials train_polynomials mini_batches mini_batches program~train_polynomials->mini_batches random_numbers random_numbers program~train_polynomials->random_numbers bins bins program~train_polynomials->bins proc~output output program~train_polynomials->proc~output inputs inputs program~train_polynomials->inputs output_sizes output_sizes program~train_polynomials->output_sizes proc~y y program~train_polynomials->proc~y network_outputs network_outputs program~train_polynomials->network_outputs string_t string_t program~train_polynomials->string_t input_output_pairs input_output_pairs program~train_polynomials->input_output_pairs desired_outputs desired_outputs program~train_polynomials->desired_outputs cost cost program~train_polynomials->cost random_init random_init program~train_polynomials->random_init proc~perturbed_identity_network perturbed_identity_network program~train_polynomials->proc~perturbed_identity_network intrinsic_array_t intrinsic_array_t program~train_polynomials->intrinsic_array_t assert assert program~train_polynomials->assert bin_t bin_t program~train_polynomials->bin_t interface~shuffle shuffle program~train_polynomials->interface~shuffle proc~y->assert x x proc~y->x proc~perturbed_identity_network->string_t proc~e e proc~perturbed_identity_network->proc~e proc~shuffle shuffle interface~shuffle->proc~shuffle proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions e perturbed_identity_network Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_polynomials.html"},{"title":"learn_microphysics_procedures – Inference-Engine","text":"Uses sourcery_m iso_fortran_env assert_m inference_engine_m thompson_tensors_m program~~learn_microphysics_procedures~~UsesGraph program~learn_microphysics_procedures learn_microphysics_procedures assert_m assert_m program~learn_microphysics_procedures->assert_m module~inference_engine_m inference_engine_m program~learn_microphysics_procedures->module~inference_engine_m iso_fortran_env iso_fortran_env program~learn_microphysics_procedures->iso_fortran_env sourcery_m sourcery_m program~learn_microphysics_procedures->sourcery_m module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures->module~thompson_tensors_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~thompson_tensors_m->assert_m module~thompson_tensors_m->module~inference_engine_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Train a neural network proxies for procedures in the Thompson microphysics model\nin of ICAR (https://github.com/BerkeleyLab/icar). Calls program~~learn_microphysics_procedures~~CallsGraph program~learn_microphysics_procedures learn_microphysics_procedures inputs inputs program~learn_microphysics_procedures->inputs network_outputs network_outputs program~learn_microphysics_procedures->network_outputs file_t file_t program~learn_microphysics_procedures->file_t cost cost program~learn_microphysics_procedures->cost nodes_per_layer nodes_per_layer program~learn_microphysics_procedures->nodes_per_layer intrinsic_array_t intrinsic_array_t program~learn_microphysics_procedures->intrinsic_array_t mini_batches mini_batches program~learn_microphysics_procedures->mini_batches proc~output~2 output program~learn_microphysics_procedures->proc~output~2 output_sizes output_sizes program~learn_microphysics_procedures->output_sizes desired_outputs desired_outputs program~learn_microphysics_procedures->desired_outputs random_numbers random_numbers program~learn_microphysics_procedures->random_numbers proc~perturbed_identity_network~2 perturbed_identity_network program~learn_microphysics_procedures->proc~perturbed_identity_network~2 string_t string_t program~learn_microphysics_procedures->string_t input_output_pairs input_output_pairs program~learn_microphysics_procedures->input_output_pairs assert assert program~learn_microphysics_procedures->assert bin_t bin_t program~learn_microphysics_procedures->bin_t interface~shuffle shuffle program~learn_microphysics_procedures->interface~shuffle proc~print_diagnostics print_diagnostics program~learn_microphysics_procedures->proc~print_diagnostics bins bins program~learn_microphysics_procedures->bins proc~y~7 y program~learn_microphysics_procedures->proc~y~7 random_init random_init program~learn_microphysics_procedures->random_init proc~open_plot_file_for_appending open_plot_file_for_appending program~learn_microphysics_procedures->proc~open_plot_file_for_appending proc~perturbed_identity_network~2->string_t proc~e~2 e proc~perturbed_identity_network~2->proc~e~2 proc~shuffle shuffle interface~shuffle->proc~shuffle proc~y~7->assert proc~rsif RSIF proc~y~7->proc~rsif proc~rslf RSLF proc~y~7->proc~rslf proc~open_plot_file_for_appending->file_t proc~open_plot_file_for_appending->string_t proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables clock_rate command_line counter_end counter_start network_file Functions e perturbed_identity_network Subroutines open_plot_file_for_appending output print_diagnostics Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/learn_microphysics_procedures.html"},{"title":"print_training_configuration – Inference-Engine","text":"Uses inference_engine_m sourcery_m program~~print_training_configuration~~UsesGraph program~print_training_configuration print_training_configuration module~inference_engine_m inference_engine_m program~print_training_configuration->module~inference_engine_m sourcery_m sourcery_m program~print_training_configuration->sourcery_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Demonstrate how to construct and print a training_configuration_t object Contents None","tags":"","loc":"program/print_training_configuration.html"},{"title":"train_saturated_mixture_ratio – Inference-Engine","text":"Uses saturated_mixing_ratio_m sourcery_m iso_fortran_env assert_m inference_engine_m program~~train_saturated_mixture_ratio~~UsesGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m assert_m assert_m program~train_saturated_mixture_ratio->assert_m module~inference_engine_m inference_engine_m program~train_saturated_mixture_ratio->module~inference_engine_m iso_fortran_env iso_fortran_env program~train_saturated_mixture_ratio->iso_fortran_env sourcery_m sourcery_m program~train_saturated_mixture_ratio->sourcery_m module~saturated_mixing_ratio_m->assert_m module~saturated_mixing_ratio_m->module~inference_engine_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program trains a neural network to learn the saturated mixing ratio function of ICAR. Calls program~~train_saturated_mixture_ratio~~CallsGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio inputs inputs program~train_saturated_mixture_ratio->inputs network_outputs network_outputs program~train_saturated_mixture_ratio->network_outputs file_t file_t program~train_saturated_mixture_ratio->file_t cost cost program~train_saturated_mixture_ratio->cost intrinsic_array_t intrinsic_array_t program~train_saturated_mixture_ratio->intrinsic_array_t nodes_per_layer nodes_per_layer program~train_saturated_mixture_ratio->nodes_per_layer proc~output~3 output program~train_saturated_mixture_ratio->proc~output~3 mini_batches mini_batches program~train_saturated_mixture_ratio->mini_batches output_sizes output_sizes program~train_saturated_mixture_ratio->output_sizes desired_outputs desired_outputs program~train_saturated_mixture_ratio->desired_outputs proc~perturbed_identity_network~3 perturbed_identity_network program~train_saturated_mixture_ratio->proc~perturbed_identity_network~3 proc~y~6 y program~train_saturated_mixture_ratio->proc~y~6 random_numbers random_numbers program~train_saturated_mixture_ratio->random_numbers proc~print_diagnostics~2 print_diagnostics program~train_saturated_mixture_ratio->proc~print_diagnostics~2 string_t string_t program~train_saturated_mixture_ratio->string_t input_output_pairs input_output_pairs program~train_saturated_mixture_ratio->input_output_pairs assert assert program~train_saturated_mixture_ratio->assert interface~shuffle shuffle program~train_saturated_mixture_ratio->interface~shuffle bin_t bin_t program~train_saturated_mixture_ratio->bin_t bins bins program~train_saturated_mixture_ratio->bins proc~open_plot_file_for_appending~2 open_plot_file_for_appending program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 random_init random_init program~train_saturated_mixture_ratio->random_init proc~perturbed_identity_network~3->string_t proc~e~3 e proc~perturbed_identity_network~3->proc~e~3 proc~y~6->assert proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~6->proc~saturated_mixing_ratio x x proc~y~6->x proc~shuffle shuffle interface~shuffle->proc~shuffle proc~open_plot_file_for_appending~2->file_t proc~open_plot_file_for_appending~2->string_t proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables clock_rate command_line counter_end counter_start network_file Functions e perturbed_identity_network Subroutines open_plot_file_for_appending output print_diagnostics Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/train_saturated_mixture_ratio.html"},{"title":"train_polynomials – Inference-Engine","text":"Uses assert_m inference_engine_m power_series sourcery_m program~~train_polynomials~2~~UsesGraph program~train_polynomials~2 train_polynomials assert_m assert_m program~train_polynomials~2->assert_m module~inference_engine_m inference_engine_m program~train_polynomials~2->module~inference_engine_m sourcery_m sourcery_m program~train_polynomials~2->sourcery_m module~power_series power_series program~train_polynomials~2->module~power_series module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~power_series->assert_m module~power_series->module~inference_engine_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~train_polynomials~2~~CallsGraph program~train_polynomials~2 train_polynomials inputs inputs program~train_polynomials~2->inputs proc~output~4 output program~train_polynomials~2->proc~output~4 network_outputs network_outputs program~train_polynomials~2->network_outputs cost cost program~train_polynomials~2->cost intrinsic_array_t intrinsic_array_t program~train_polynomials~2->intrinsic_array_t mini_batches mini_batches program~train_polynomials~2->mini_batches output_sizes output_sizes program~train_polynomials~2->output_sizes desired_outputs desired_outputs program~train_polynomials~2->desired_outputs random_numbers random_numbers program~train_polynomials~2->random_numbers string_t string_t program~train_polynomials~2->string_t input_output_pairs input_output_pairs program~train_polynomials~2->input_output_pairs proc~perturbed_identity_network~4 perturbed_identity_network program~train_polynomials~2->proc~perturbed_identity_network~4 white_noise white_noise program~train_polynomials~2->white_noise assert assert program~train_polynomials~2->assert interface~shuffle shuffle program~train_polynomials~2->interface~shuffle bin_t bin_t program~train_polynomials~2->bin_t bins bins program~train_polynomials~2->bins proc~y~2 y program~train_polynomials~2->proc~y~2 random_init random_init program~train_polynomials~2->random_init proc~perturbed_identity_network~4->string_t proc~e~4 e proc~perturbed_identity_network~4->proc~e~4 proc~shuffle shuffle interface~shuffle->proc~shuffle proc~y~2->assert x x proc~y~2->x proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions e perturbed_identity_network Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_polynomials~2.html"},{"title":"train_and_write – Inference-Engine","text":"Uses assert_m inference_engine_m sourcery_m program~~train_and_write~~UsesGraph program~train_and_write train_and_write assert_m assert_m program~train_and_write->assert_m module~inference_engine_m inference_engine_m program~train_and_write->module~inference_engine_m sourcery_m sourcery_m program~train_and_write->sourcery_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to train a simple neural network starting from a randomized initial condition and \nhow to write the initial network and the trained network to separate JSON files.  The network has two hiden layers.\nThe input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match\nthe corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions,\nthe desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere.\nThe initial condition corresponds to the desired network with all weights and biases perturbed by a random variable\nthat is uniformly distributed on the range [0,0.1]. Calls program~~train_and_write~~CallsGraph program~train_and_write train_and_write bins bins program~train_and_write->bins mini_batches mini_batches program~train_and_write->mini_batches random_numbers random_numbers program~train_and_write->random_numbers proc~output~5 output program~train_and_write->proc~output~5 inputs inputs program~train_and_write->inputs network_outputs network_outputs program~train_and_write->network_outputs string_t string_t program~train_and_write->string_t input_output_pairs input_output_pairs program~train_and_write->input_output_pairs cost cost program~train_and_write->cost random_init random_init program~train_and_write->random_init proc~perturbed_identity_network~5 perturbed_identity_network program~train_and_write->proc~perturbed_identity_network~5 intrinsic_array_t intrinsic_array_t program~train_and_write->intrinsic_array_t assert assert program~train_and_write->assert bin_t bin_t program~train_and_write->bin_t interface~shuffle shuffle program~train_and_write->interface~shuffle proc~perturbed_identity_network~5->string_t proc~shuffle shuffle interface~shuffle->proc~shuffle proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions perturbed_identity_network Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_and_write.html"},{"title":"train_polynomials – Inference-Engine","text":"Uses assert_m inference_engine_m sourcery_m program~~train_polynomials~3~~UsesGraph program~train_polynomials~3 train_polynomials assert_m assert_m program~train_polynomials~3->assert_m module~inference_engine_m inference_engine_m program~train_polynomials~3->module~inference_engine_m sourcery_m sourcery_m program~train_polynomials~3->sourcery_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~train_polynomials~3~~CallsGraph program~train_polynomials~3 train_polynomials mini_batches mini_batches program~train_polynomials~3->mini_batches random_numbers random_numbers program~train_polynomials~3->random_numbers bins bins program~train_polynomials~3->bins inputs inputs program~train_polynomials~3->inputs proc~perturbed_identity_network~6 perturbed_identity_network program~train_polynomials~3->proc~perturbed_identity_network~6 proc~output~6 output program~train_polynomials~3->proc~output~6 network_outputs network_outputs program~train_polynomials~3->network_outputs string_t string_t program~train_polynomials~3->string_t input_output_pairs input_output_pairs program~train_polynomials~3->input_output_pairs desired_outputs desired_outputs program~train_polynomials~3->desired_outputs cost cost program~train_polynomials~3->cost random_init random_init program~train_polynomials~3->random_init proc~y~3 y program~train_polynomials~3->proc~y~3 intrinsic_array_t intrinsic_array_t program~train_polynomials~3->intrinsic_array_t assert assert program~train_polynomials~3->assert bin_t bin_t program~train_polynomials~3->bin_t interface~shuffle shuffle program~train_polynomials~3->interface~shuffle proc~perturbed_identity_network~6->string_t proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 proc~y~3->assert x x proc~y~3->x proc~shuffle shuffle interface~shuffle->proc~shuffle proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions e perturbed_identity_network y Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_polynomials~3.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses inference_engine_m kind_parameters_m sourcery_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m sourcery_m sourcery_m program~write_read_infer->sourcery_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference.  The network performs an identity mapping from any\nnon-negative inputs to the corresponding outputs using a RELU activation\nfunction. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer string_t string_t program~write_read_infer->string_t proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network file_t file_t proc~write_read_query_infer->file_t proc~identity_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line file_name Functions identity_network Subroutines write_read_query_infer Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Functions function identity_network () result(inference_engine) Arguments None Return Value type( inference_engine_t ) Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"train_polynomials – Inference-Engine","text":"Uses assert_m inference_engine_m raise_inputs_to_a_power sourcery_m program~~train_polynomials~4~~UsesGraph program~train_polynomials~4 train_polynomials assert_m assert_m program~train_polynomials~4->assert_m module~inference_engine_m inference_engine_m program~train_polynomials~4->module~inference_engine_m sourcery_m sourcery_m program~train_polynomials~4->sourcery_m module~raise_inputs_to_a_power raise_inputs_to_a_power program~train_polynomials~4->module~raise_inputs_to_a_power module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~raise_inputs_to_a_power->assert_m module~raise_inputs_to_a_power->module~inference_engine_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~train_polynomials~4~~CallsGraph program~train_polynomials~4 train_polynomials mini_batches mini_batches program~train_polynomials~4->mini_batches proc~output~7 output program~train_polynomials~4->proc~output~7 random_numbers random_numbers program~train_polynomials~4->random_numbers bins bins program~train_polynomials~4->bins inputs inputs program~train_polynomials~4->inputs output_sizes output_sizes program~train_polynomials~4->output_sizes network_outputs network_outputs program~train_polynomials~4->network_outputs string_t string_t program~train_polynomials~4->string_t input_output_pairs input_output_pairs program~train_polynomials~4->input_output_pairs desired_outputs desired_outputs program~train_polynomials~4->desired_outputs cost cost program~train_polynomials~4->cost random_init random_init program~train_polynomials~4->random_init proc~perturbed_identity_network~7 perturbed_identity_network program~train_polynomials~4->proc~perturbed_identity_network~7 proc~y~4 y program~train_polynomials~4->proc~y~4 intrinsic_array_t intrinsic_array_t program~train_polynomials~4->intrinsic_array_t assert assert program~train_polynomials~4->assert bin_t bin_t program~train_polynomials~4->bin_t interface~shuffle shuffle program~train_polynomials~4->interface~shuffle proc~perturbed_identity_network~7->string_t proc~e~6 e proc~perturbed_identity_network~7->proc~e~6 proc~y~4->assert x x proc~y~4->x proc~shuffle shuffle interface~shuffle->proc~shuffle proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions e perturbed_identity_network Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_polynomials~4.html"},{"title":"train_polynomials – Inference-Engine","text":"Uses assert_m inference_engine_m add_inputs sourcery_m program~~train_polynomials~5~~UsesGraph program~train_polynomials~5 train_polynomials assert_m assert_m program~train_polynomials~5->assert_m module~inference_engine_m inference_engine_m program~train_polynomials~5->module~inference_engine_m sourcery_m sourcery_m program~train_polynomials~5->sourcery_m module~add_inputs add_inputs program~train_polynomials~5->module~add_inputs module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~step_m step_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~add_inputs->assert_m module~add_inputs->module~inference_engine_m module~hyperparameters_m->sourcery_m module~hyperparameters_m->module~kind_parameters_m module~training_configuration_m->sourcery_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~activation_strategy_m->sourcery_m module~activation_strategy_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~swish_m->sourcery_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->sourcery_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->sourcery_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~relu_m->sourcery_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~train_polynomials~5~~CallsGraph program~train_polynomials~5 train_polynomials mini_batches mini_batches program~train_polynomials~5->mini_batches proc~output~8 output program~train_polynomials~5->proc~output~8 random_numbers random_numbers program~train_polynomials~5->random_numbers bins bins program~train_polynomials~5->bins inputs inputs program~train_polynomials~5->inputs output_sizes output_sizes program~train_polynomials~5->output_sizes network_outputs network_outputs program~train_polynomials~5->network_outputs string_t string_t program~train_polynomials~5->string_t input_output_pairs input_output_pairs program~train_polynomials~5->input_output_pairs desired_outputs desired_outputs program~train_polynomials~5->desired_outputs cost cost program~train_polynomials~5->cost random_init random_init program~train_polynomials~5->random_init proc~perturbed_identity_network~8 perturbed_identity_network program~train_polynomials~5->proc~perturbed_identity_network~8 proc~y~5 y program~train_polynomials~5->proc~y~5 intrinsic_array_t intrinsic_array_t program~train_polynomials~5->intrinsic_array_t assert assert program~train_polynomials~5->assert bin_t bin_t program~train_polynomials~5->bin_t interface~shuffle shuffle program~train_polynomials~5->interface~shuffle proc~perturbed_identity_network~8->string_t proc~e~7 e proc~perturbed_identity_network~8->proc~e~7 proc~y~5->assert x x proc~y~5->x proc~shuffle shuffle interface~shuffle->proc~shuffle proc~shuffle->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line final_network_file intial_network_file Functions e perturbed_identity_network Subroutines output Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file type(string_t) :: intial_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real,allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_polynomials~5.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Specify the user-facing modules, derived types, and type parameters use activation_strategy_m , only : activation_strategy_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use hyperparameters_m , only : hyperparameters_t use input_output_pair_m , only : input_output_pair_t , shuffle use inference_engine_m_ , only : inference_engine_t , difference_t use kind_parameters_m , only : rkind use mini_batch_m , only : mini_batch_t use NetCDF_file_m , only : NetCDF_file_t use network_configuration_m , only : network_configuration_t use relu_m , only : relu_t use sigmoid_m , only : sigmoid_t use step_m , only : step_t use swish_m , only : swish_t use tensor_m , only : tensor_t use trainable_engine_m , only : trainable_engine_t use training_configuration_m , only : training_configuration_t implicit none end module","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"training_configuration_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_s.f90~~EfferentGraph sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules training_configuration_s Source Code training_configuration_s.f90 Source Code submodule ( training_configuration_m ) training_configuration_s use assert_m , only : assert use inference_engine_m , only : relu_t , sigmoid_t , swish_t implicit none character ( len =* ), parameter :: header = \"{\" , footer = \"}\" , separator = \",\" contains module procedure from_components training_configuration % hyperparameters_ = hyperparameters training_configuration % network_configuration_ = network_configuration training_configuration % file_t = file_t ([ & string_t ( header ), & training_configuration % hyperparameters_ % to_json (), & string_t ( separator ), & training_configuration % network_configuration_ % to_json (), & string_t ( footer ) & ]) end procedure module procedure from_file integer , parameter :: hyperparameters_start = 2 , hyperparameters_end = 6 , separator_line = 7 ! line numbers integer , parameter :: net_config_start = 8 , net_config_end = 12 ! line numbers integer , parameter :: file_start = hyperparameters_start - 1 , file_end = net_config_end + 1 ! line numbers training_configuration % file_t = file_object associate ( lines => training_configuration % file_t % lines ()) call assert ( trim ( adjustl ( lines ( file_start )% string ())) == header , \"training_configuration_s(from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( trim ( adjustl ( lines ( separator_line )% string ())) == separator , \"training_configuration_s(from_file): separator\" , & lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( trim ( adjustl ( lines ( file_end )% string ())) == footer , \"training_configuration_s(from_file): footer\" , lines ( file_end )) end associate end procedure module procedure to_json json_lines = self % lines () end procedure module procedure equals lhs_eq_rhs = & lhs % hyperparameters_ == rhs % hyperparameters_ . and . & lhs % network_configuration_ == rhs % network_configuration_ end procedure module procedure mini_batches num_mini_batches = self % hyperparameters_ % mini_batches () end procedure module procedure optimizer_name identifier = self % hyperparameters_ % optimizer_name () end procedure module procedure learning_rate rate = self % hyperparameters_ % learning_rate () end procedure module procedure nodes_per_layer nodes = self % network_configuration_ % nodes_per_layer () end procedure module procedure skip_connections using_skip = self % network_configuration_ % skip_connections () end procedure module procedure differentiable_activation_strategy associate ( activation_name => self % network_configuration_ % activation_name ()) select case ( activation_name % string ()) case ( \"relu\" ) strategy = relu_t () case ( \"sigmoid\" ) strategy = sigmoid_t () case ( \"swish\" ) strategy = swish_t () case default error stop 'activation_strategy_factory_s(factory): unrecognized activation name \"' // activation_name % string () // '\"' end select end associate end procedure end submodule training_configuration_s","tags":"","loc":"sourcefile/training_configuration_s.f90.html"},{"title":"relu_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_s.f90~~EfferentGraph sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules relu_s Source Code relu_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( relu_m ) relu_s use kind_parameters_m , only : rkind implicit none real ( rkind ), parameter :: zero = 0._rkind , one = 1._rkind contains module procedure activation y = max ( zero , x ) end procedure module procedure activation_derivative y = merge ( one , zero , x > zero ) end procedure module procedure function_name string = string_t ( \"relu\" ) end procedure end submodule relu_s","tags":"","loc":"sourcefile/relu_s.f90.html"},{"title":"input_output_pair_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules input_output_pair_m Source Code input_output_pair_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use kind_parameters_m , only : rkind use tensor_m , only : tensor_t implicit none private public :: input_output_pair_t public :: shuffle type input_output_pair_t private type ( tensor_t ) inputs_ , expected_outputs_ contains procedure :: inputs procedure :: expected_outputs end type interface input_output_pair_t elemental module function construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ) input_output_pair end function end interface interface elemental module function inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_inputs end function elemental module function expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_expected_outputs end function pure module subroutine shuffle ( pairs , random_numbers ) implicit none type ( input_output_pair_t ), intent ( inout ) :: pairs (:) real , intent ( in ) :: random_numbers ( 2 :) end subroutine end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kind_parameters_m Source Code kind_parameters_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"mini_batch_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mini_batch_m Source Code mini_batch_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : rkind implicit none private public :: mini_batch_t type mini_batch_t private type ( input_output_pair_t ), allocatable :: input_output_pairs_ (:) contains procedure :: input_output_pairs end type interface mini_batch_t pure module function construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function end interface interface pure module function input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"NetCDF_file_s.f90 – Inference-Engine","text":"Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro\neffectively eliminates this file's source code when building with an Intel compiler. This file depends on sourcefile~~netcdf_file_s.f90~~EfferentGraph sourcefile~netcdf_file_s.f90 NetCDF_file_s.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~netcdf_file_s.f90->sourcefile~netcdf_file_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules netCDF_file_s Source Code NetCDF_file_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #ifndef __INTEL_FORTRAN !! Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro !! effectively eliminates this file's source code when building with an Intel compiler. submodule ( netCDF_file_m ) netCDF_file_s use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert , intrinsic_array_t implicit none contains module procedure construct netCDF_file % file_name_ = file_name end procedure function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_variable\" // trim ( nf90_strerror ( nf_status )), & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_variable\" // trim ( nf90_strerror ( nf_status )), & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_dimension\" // trim ( nf90_strerror ( nf_status )),& trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function module procedure input_real_scalar character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , & \"Net_CDF_file_m(input_real_scalar): nf90_open \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_real_scalar): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , scalar )) ! read data call assert ( nf_status == nf90_noerr , \"NetCDF_file_s(input_real_scalar): nf90_get_var \" , trim ( nf90_strerror ( nf_status ))) end associate end procedure module procedure input_2D_integer character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , & \"Net_CDF_file_m(input_2D_integer): nf90_open\" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_2D_integer): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_2D_integer): size(array_shape)==rank(values)\" ) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"NetCDF_file_s(input_2D_integer): nf90_get_var\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_1D_double character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_1D_double): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_1D_double): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_4D_real character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_4D_real): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_4D_real): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ), array_shape ( 3 ), array_shape ( 4 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_3D_real character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_3D_real): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_3D_real): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ), array_shape ( 3 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure end submodule netCDF_file_s #endif // __INTEL_FORTRAN","tags":"","loc":"sourcefile/netcdf_file_s.f90.html"},{"title":"hyperparameters_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_m.f90~~EfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~hyperparameters_m.f90~~AfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules hyperparameters_m Source Code hyperparameters_m.f90 Source Code module hyperparameters_m use sourcery_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: hyperparameters_t type hyperparameters_t private integer :: mini_batches_ = 10 real :: learning_rate_ = 1.5 character ( len = :), allocatable :: optimizer_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate end type interface hyperparameters_t pure module function from_json ( lines ) result ( hyperparameters ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( hyperparameters_t ) hyperparameters end function pure module function from_components ( mini_batches , learning_rate , optimizer ) result ( hyperparameters ) implicit none integer , intent ( in ) :: mini_batches real , intent ( in ) :: learning_rate character ( len =* ), intent ( in ) :: optimizer type ( hyperparameters_t ) hyperparameters end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( hyperparameters_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( hyperparameters_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( hyperparameters_t ), intent ( in ) :: self real ( rkind ) rate end function end interface end module","tags":"","loc":"sourcefile/hyperparameters_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m ! External dependencies use kind_parameters_m , only : rkind use sourcery_m , only : string_t implicit none private public :: activation_strategy_t public :: activation_i public :: function_name_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation procedure ( function_name_i ), nopass , deferred :: function_name end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name_i () result ( string ) implicit none type ( string_t ) string end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"tensor_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_s.f90~~EfferentGraph sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules tensor_s Source Code tensor_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_m ) tensor_s implicit none contains module procedure construct_from_components tensor % values_ = values end procedure module procedure values tensor_values = self % values_ end procedure module procedure num_components n = size ( self % values_ ) end procedure end submodule tensor_s","tags":"","loc":"sourcefile/tensor_s.f90.html"},{"title":"inference_engine_m_.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m_.f90~~EfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m_.f90~~AfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m_ Source Code inference_engine_m_.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m_ !! Define an abstraction that supports inference operationsn on a neural network use activation_strategy_m , only : activation_strategy_t use sourcery_m , only : file_t , string_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: inference_engine_t public :: difference_t public :: exchange_t character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference private type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: infer procedure :: to_json procedure :: num_inputs procedure :: num_outputs procedure :: nodes_per_layer procedure :: assert_conformable_with procedure :: skip procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: activation_function_name procedure :: to_exchange end type type exchange_t type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation end type type difference_t private real ( rkind ), allocatable :: weights_difference_ (:,:,:), biases_difference_ (:,:) integer , allocatable :: nodes_difference_ (:) contains procedure :: norm end type interface inference_engine_t pure module function construct_from_padded_arrays ( metadata , weights , biases , nodes ) result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface pure module function to_exchange ( self ) result ( exchange ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( exchange_t ) exchange end function impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( difference_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( difference_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function pure module function nodes_per_layer ( self ) result ( node_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer , allocatable :: node_count (:) end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function pure module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function end interface end module inference_engine_m_","tags":"","loc":"sourcefile/inference_engine_m_.f90.html"},{"title":"network_configuration_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~network_configuration_m.f90~~AfferentGraph sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~network_configuration_s.f90 network_configuration_s.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules network_configuration_m Source Code network_configuration_m.f90 Source Code module network_configuration_m use sourcery_m , only : string_t implicit none private public :: network_configuration_t type network_configuration_t private logical :: skip_connections_ = . false . integer , allocatable :: nodes_per_layer_ (:) character ( len = :), allocatable :: activation_name_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: activation_name procedure :: nodes_per_layer procedure :: skip_connections end type interface network_configuration_t pure module function from_json ( lines ) result ( network_configuration ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( network_configuration_t ) network_configuration end function pure module function from_components ( skip_connections , nodes_per_layer , activation_name ) result ( network_configuration ) implicit none logical , intent ( in ) :: skip_connections integer , intent ( in ) :: nodes_per_layer (:) character ( len =* ), intent ( in ) :: activation_name type ( network_configuration_t ) network_configuration end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( network_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function activation_name ( self ) result ( string ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ) string end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( network_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( network_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/network_configuration_m.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules layer_s Source Code layer_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_t construct: layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure inference_engine associate ( & num_inputs => hidden_layers % count_inputs (), & num_outputs => output_layer % count_neurons (), & neurons_per_hidden_layer => hidden_layers % count_neurons (), & num_hidden_layers => hidden_layers % count_layers (), & num_output_layers => output_layer % count_layers () & ) call assert ( num_output_layers == 1 , \"inference_engine_s(construct_from_json): 1 output layer\" , num_output_layers ) associate ( nodes => [ num_inputs , neurons_per_hidden_layer , num_outputs ]) associate ( n_max => maxval ( nodes )) block real ( rkind ), allocatable :: weights (:,:,:), biases (:,:) type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer j , l allocate ( weights ( n_max , n_max , num_hidden_layers + num_output_layers )) allocate ( biases ( n_max , num_hidden_layers + num_output_layers )) layer_ptr => hidden_layers l = 0 loop_over_hidden_Layers : & do l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_hidden_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_hidden_neurons if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next_pointer () end do loop_over_hidden_Layers layer_ptr => output_layer l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_output_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_output_neurons inference_engine_ = inference_engine_t ( metadata , weights , biases , nodes ) end block end associate end associate end associate end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer = [ neurons_per_layer , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure count_inputs num_inputs = layer % neuron % num_inputs () ! assume fully connected input layer end procedure module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"NetCDF_file_m.f90 – Inference-Engine","text":"Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro\neffectively eliminates this file's source code when building with an Intel compiler. Files dependent on this one sourcefile~~netcdf_file_m.f90~~AfferentGraph sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~netcdf_file_s.f90 NetCDF_file_s.f90 sourcefile~netcdf_file_s.f90->sourcefile~netcdf_file_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules NetCDF_file_m Source Code NetCDF_file_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #ifndef __INTEL_FORTRAN !! Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro !! effectively eliminates this file's source code when building with an Intel compiler. module NetCDF_file_m implicit none private public :: NetCDF_file_t type NetCDF_file_t private character ( len = :), allocatable :: file_name_ contains procedure :: input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar generic :: input => input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar end type interface NetCDF_file_t pure module function construct ( file_name ) result ( NetCDF_file ) implicit none character ( len =* ), intent ( in ) :: file_name type ( NetCDF_file_t ) NetCDF_file end function end interface interface module subroutine input_real_scalar ( self , varname , scalar ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ) :: scalar end subroutine module subroutine input_2D_integer ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname integer , intent ( out ), allocatable :: values (:,:) end subroutine module subroutine input_1D_double ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname double precision , intent ( out ), allocatable :: values (:) end subroutine module subroutine input_4D_real ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ), allocatable :: values (:,:,:,:) end subroutine module subroutine input_3D_real ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ), allocatable :: values (:,:,:) end subroutine end interface end module NetCDF_file_m #endif // __INTEL_FORTRAN","tags":"","loc":"sourcefile/netcdf_file_m.f90.html"},{"title":"hyperparameters_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_s.f90~~EfferentGraph sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules hyperparameters_s Source Code hyperparameters_s.f90 Source Code submodule ( hyperparameters_m ) hyperparameters_s use assert_m , only : assert implicit none character ( len =* ), parameter :: mini_batches_key = \"mini-batches\" character ( len =* ), parameter :: learning_rate_key = \"learning rate\" character ( len =* ), parameter :: optimizer_key = \"optimizer\" contains module procedure from_components hyperparameters % mini_batches_ = mini_batches hyperparameters % learning_rate_ = learning_rate hyperparameters % optimizer_ = optimizer end procedure module procedure equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % optimizer_ ) . and . allocated ( rhs % optimizer_ ), \"hyperparameters_s(equals): allocated optimizers\" ) lhs_equals_rhs = & lhs % mini_batches_ == rhs % mini_batches_ . and . & lhs % optimizer_ == rhs % optimizer_ . and . & abs ( lhs % learning_rate_ - rhs % learning_rate_ ) <= tolerance end procedure module procedure from_json integer l logical hyperparameters_key_found hyperparameters_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"hyperparameters\" ) then hyperparameters_key_found = . true . hyperparameters % mini_batches_ = lines ( l + 1 )% get_json_value ( string_t ( mini_batches_key ), mold = 0 ) hyperparameters % learning_rate_ = lines ( l + 2 )% get_json_value ( string_t ( learning_rate_key ), mold = 0. ) hyperparameters % optimizer_ = lines ( l + 3 )% get_json_value ( string_t ( optimizer_key ), mold = string_t ( \"\" )) return end if end do call assert ( hyperparameters_key_found , \"hyperparameters_s(from_json): hyperparameters_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_width = 18 character ( len = max_width ) mini_batches_string , learning_rate_string write ( mini_batches_string , * ) self % mini_batches_ write ( learning_rate_string , * ) self % learning_rate_ lines = [ & string_t ( indent // '\"hyperparameters\": {' ), & string_t ( indent // indent // '\"' // mini_batches_key // '\" : ' // trim ( adjustl ( mini_batches_string )) // \",\" ), & string_t ( indent // indent // '\"' // learning_rate_key // '\" : ' // trim ( adjustl ( learning_rate_string )) // \",\" ), & string_t ( indent // indent // '\"' // optimizer_key // '\" : \"' // trim ( adjustl ( self % optimizer_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure mini_batches num_mini_batches = self % mini_batches_ end procedure module procedure optimizer_name identifier = string_t ( self % optimizer_ ) end procedure module procedure learning_rate rate = self % learning_rate_ end procedure end submodule hyperparameters_s","tags":"","loc":"sourcefile/hyperparameters_s.f90.html"},{"title":"trainable_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_m.f90~~EfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~trainable_engine_m.f90~~AfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules trainable_engine_m Source Code trainable_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module trainable_engine_m !! Define an abstraction that supports training a neural network use sourcery_m , only : string_t use inference_engine_m_ , only : inference_engine_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use mini_batch_m , only : mini_batch_t implicit none private public :: trainable_engine_t type trainable_engine_t !! Encapsulate the information needed to perform training private type ( string_t ), allocatable :: metadata_ (:) real ( rkind ), allocatable :: w (:,:,:) ! weights real ( rkind ), allocatable :: b (:,:) ! biases integer , allocatable :: n (:) ! nodes per layer class ( differentiable_activation_strategy_t ), allocatable :: differentiable_activation_strategy_ contains procedure :: assert_consistent procedure :: train procedure :: infer procedure :: num_layers procedure :: num_inputs procedure :: num_outputs procedure :: to_inference_engine end type integer , parameter :: input_layer = 0 interface trainable_engine_t pure module function construct_from_padded_arrays ( nodes , weights , biases , differentiable_activation_strategy , metadata ) & result ( trainable_engine ) implicit none integer , intent ( in ) :: nodes ( input_layer :) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) class ( differentiable_activation_strategy_t ), intent ( in ) :: differentiable_activation_strategy type ( string_t ), intent ( in ) :: metadata (:) type ( trainable_engine_t ) trainable_engine end function pure module function construct_from_inference_engine ( inference_engine ) result ( trainable_engine ) implicit none type ( inference_engine_t ), intent ( in ) :: inference_engine type ( trainable_engine_t ) trainable_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( trainable_engine_t ), intent ( in ) :: self end subroutine pure module subroutine train ( self , mini_batches , cost , adam , learning_rate ) implicit none class ( trainable_engine_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches (:) real ( rkind ), intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ) :: adam real ( rkind ), intent ( in ) :: learning_rate end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_inputs ( self ) result ( n_in ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_in end function elemental module function num_outputs ( self ) result ( n_out ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_out end function elemental module function num_layers ( self ) result ( n_layers ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_layers end function pure module function to_inference_engine ( self ) result ( inference_engine ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( inference_engine_t ) :: inference_engine end function end interface end module trainable_engine_m","tags":"","loc":"sourcefile/trainable_engine_m.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind use sourcery_m , only : string_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"relu_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_m.f90~~EfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~relu_m.f90~~AfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules relu_m Source Code relu_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module relu_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_m , only : string_t implicit none private public :: relu_t type , extends ( differentiable_activation_strategy_t ) :: relu_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module relu_m","tags":"","loc":"sourcefile/relu_m.f90.html"},{"title":"mini_batch_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules mini_batch_s Source Code mini_batch_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"training_configuration_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_m.f90~~EfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~training_configuration_m.f90~~AfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules training_configuration_m Source Code training_configuration_m.f90 Source Code module training_configuration_m use sourcery_m , only : string_t , file_t use hyperparameters_m , only : hyperparameters_t use network_configuration_m , only : network_configuration_t use kind_parameters_m , only : rkind use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: training_configuration_t type , extends ( file_t ) :: training_configuration_t private type ( hyperparameters_t ) hyperparameters_ type ( network_configuration_t ) network_configuration_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate procedure :: differentiable_activation_strategy procedure :: nodes_per_layer procedure :: skip_connections end type interface training_configuration_t module function from_components ( hyperparameters , network_configuration ) result ( training_configuration ) implicit none type ( hyperparameters_t ), intent ( in ) :: hyperparameters type ( network_configuration_t ), intent ( in ) :: network_configuration type ( training_configuration_t ) training_configuration end function module function from_file ( file_object ) result ( training_configuration ) implicit none type ( file_t ), intent ( in ) :: file_object type ( training_configuration_t ) training_configuration end function end interface interface pure module function to_json ( self ) result ( json_lines ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: json_lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_eq_rhs ) implicit none class ( training_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( training_configuration_t ), intent ( in ) :: self real ( rkind ) rate end function module function differentiable_activation_strategy ( self ) result ( strategy ) implicit none class ( training_configuration_t ), intent ( in ) :: self class ( differentiable_activation_strategy_t ), allocatable :: strategy end function module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( training_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/training_configuration_m.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sigmoid_m Source Code sigmoid_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_m , only : string_t implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m_ ) inference_engine_s use assert_m , only : assert , intrinsic_array_t use step_m , only : step_t use swish_m , only : swish_t use sigmoid_m , only : sigmoid_t use relu_m , only : relu_t use layer_m , only : layer_t use neuron_m , only : neuron_t use sourcery_m , only : separated_values implicit none interface assert_consistency module procedure inference_engine_consistency module procedure difference_consistency end interface contains module procedure to_exchange exchange % metadata_ = self % metadata_ exchange % weights_ = self % weights_ exchange % biases_ = self % biases_ exchange % nodes_ = self % nodes_ exchange % activation_strategy_ = self % activation_strategy_ end procedure module procedure infer real ( rkind ), allocatable :: z (:,:), a (:,:) integer , parameter :: input_layer = 0 integer j , k , l call assert_consistency ( self ) associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , output_layer => ubound ( self % nodes_ , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) a ( 1 : n ( l ), l ) = self % activation_strategy_ % activation ( z ) end associate end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end procedure pure module subroutine inference_engine_consistency ( self ) type ( inference_engine_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_ ), allocated ( self % biases_ ), allocated ( self % nodes_ ), allocated ( self % activation_strategy_ )]& ) call assert ( all ( all_allocated ), \"inference_engine_s(inference_engine_consistency): fully_allocated\" , & intrinsic_array_t ( all_allocated )) end associate associate ( max_width => maxval ( self % nodes_ ), component_dims => [ size ( self % biases_ , 1 ), size ( self % weights_ , 1 ), size ( self % weights_ , 2 )]) call assert ( all ( component_dims == max_width ), \"inference_engine_s(inference_engine_consistency): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate associate ( input_subscript => lbound ( self % nodes_ , 1 )) call assert ( input_subscript == input_layer , \"inference_engine_s(inference_engine_consistency): n base subsscript\" , & input_subscript ) end associate end subroutine pure module subroutine difference_consistency ( self ) type ( difference_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_difference_ ), allocated ( self % biases_difference_ ), allocated ( self % nodes_difference_ )] & ) call assert ( all ( all_allocated ), \"inference_engine_s(difference_consistency): fully_allocated\" , intrinsic_array_t ( all_allocated )) end associate call assert ( all ( size ( self % biases_difference_ , 1 ) == [ size ( self % weights_difference_ , 1 ), size ( self % weights_difference_ , 2 )]), & \"inference_engine_s(difference_consistency): conformable arrays\" & ) end subroutine pure subroutine set_activation_strategy ( inference_engine ) type ( inference_engine_t ), intent ( inout ) :: inference_engine character ( len = :), allocatable :: function_name ! This code is called in both constructors and and can't be refactored into a factory method ! pattern because the result would need to be allocatable and polymorphic, which would preclude ! the function being pure so it wouldn't be possible to call it from inside the pure constructor ! functions. function_name = inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () select case ( function_name ) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case ( \"relu\" ) inference_engine % activation_strategy_ = relu_t () case default error stop \"inference_engine_s(set_activation_strategy): unrecognized activation strategy '\" // function_name // \"'\" end select end subroutine module procedure construct_from_padded_arrays inference_engine % metadata_ = metadata inference_engine % weights_ = weights inference_engine % biases_ = biases inference_engine % nodes_ = nodes call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) end procedure construct_from_padded_arrays module procedure construct_from_json type ( string_t ), allocatable :: lines (:), metadata (:) type ( layer_t ) hidden_layers , output_layer type ( neuron_t ) output_neuron real ( rkind ), allocatable :: hidden_weights (:,:,:) integer l lines = file_ % lines () l = 1 call assert ( adjustl ( lines ( l )% string ()) == \"{\" , \"construct_from_json: expecting '{' to start outermost object\" , lines ( l )% string ()) l = 2 metadata = [ string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"false\" )] if ( adjustl ( lines ( l )% string ()) == '\"metadata\": {' ) then block character ( len = :), allocatable :: justified_line do l = l + 1 justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == \"},\" ) exit metadata ( findloc ( key , trim ( get_key_string ( justified_line )), dim = 1 )) = get_key_value ( justified_line ) end do l = l + 1 end block end if call assert ( adjustl ( lines ( l )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( l )% string ()) l = l + 1 block integer , parameter :: lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l ) associate ( output_layer_line_number => l + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end block inference_engine = hidden_layers % inference_engine ( metadata , output_layer ) call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) contains pure function get_key_string ( line ) result ( unquoted_key ) character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: unquoted_key associate ( opening_key_quotes => index ( line , '\"' ), separator => index ( line , ':' )) associate ( closing_key_quotes => opening_key_quotes + index ( line ( opening_key_quotes + 1 :), '\"' )) unquoted_key = trim ( line ( opening_key_quotes + 1 : closing_key_quotes - 1 )) end associate end associate end function function get_key_value ( line ) result ( value_ ) character ( len =* ), intent ( in ) :: line type ( string_t ) value_ associate ( text_after_colon => line ( index ( line , ':' ) + 1 :)) associate ( opening_value_quotes => index ( text_after_colon , '\"' )) associate ( closing_value_quotes => opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' )) if ( any ([ opening_value_quotes , closing_value_quotes ] == 0 )) then value_ = string_t ( trim ( adjustl (( text_after_colon )))) else value_ = string_t ( text_after_colon ( opening_value_quotes + 1 : closing_value_quotes - 1 )) end if end associate end associate end associate end function end procedure construct_from_json module procedure assert_conformable_with call assert_consistency ( self ) call assert_consistency ( inference_engine ) associate ( equal_shapes => [ & shape ( self % weights_ ) == shape ( inference_engine % weights_ ), & shape ( self % biases_ ) == shape ( inference_engine % biases_ ), & shape ( self % nodes_ ) == shape ( inference_engine % nodes_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( same_type_as ( self % activation_strategy_ , inference_engine % activation_strategy_ ), \"assert_conformable_with: types)\" ) end procedure module procedure subtract call assert_consistency ( self ) call assert_consistency ( rhs ) call self % assert_conformable_with ( rhs ) block integer l allocate ( difference % weights_difference_ , mold = self % weights_ ) allocate ( difference % biases_difference_ , mold = self % biases_ ) allocate ( difference % nodes_difference_ , mold = self % nodes_ ) difference % weights_difference_ = 0. difference % biases_difference_ = 0. difference % nodes_difference_ = 0. l = 0 difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) associate ( n => self % nodes_ ) do concurrent ( l = 1 : ubound ( n , 1 )) difference % weights_difference_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = self % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - rhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) difference % biases_difference_ ( 1 : n ( l ), l ) = self % biases_ ( 1 : n ( l ), l ) - rhs % biases_ ( 1 : n ( l ), l ) difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) end do end associate end block call assert_consistency ( difference ) end procedure module procedure norm norm_of_self = maxval ([ abs ( self % weights_difference_ ), abs ( self % biases_difference_ ), real ( abs ( self % nodes_difference_ ))]) end procedure module procedure num_outputs call assert_consistency ( self ) output_count = self % nodes_ ( ubound ( self % nodes_ , 1 )) end procedure module procedure num_inputs call assert_consistency ( self ) input_count = self % nodes_ ( lbound ( self % nodes_ , 1 )) end procedure module procedure nodes_per_layer call assert_consistency ( self ) node_count = self % nodes_ end procedure module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , metadata_outer_braces = 2 call assert_consistency ( self ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => size ( self % nodes_ ) - 2 , & neurons_per_layer => self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 ), & num_outputs => self % num_outputs (), & num_inputs => self % num_inputs () & ) call assert ( all ( neurons_per_layer == self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 : ubound ( self % nodes_ , 1 ) - 1 )), & \"to_json: uniform hidden layers\" ) associate ( num_lines => & outer_object_braces & + metadata_outer_braces + size ( key ) & + hidden_layer_outer_brackets + ( num_hidden_layers ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '    \"metadata\": {' ) line = line + 1 lines ( line ) = string_t ( '        \"modelName\": \"' // & self % metadata_ ( findloc ( key , \"modelName\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"modelAuthor\": \"' // & self % metadata_ ( findloc ( key , \"modelAuthor\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"compilationDate\": \"' // & self % metadata_ ( findloc ( key , \"compilationDate\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"activationFunction\": \"' // & self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"usingSkipConnections\": ' // & self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string ()) line = line + 1 lines ( line ) = string_t ( '    },' ) line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) block integer l associate ( n => self % nodes_ ) l = 1 write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate end block lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ] \" , \"         ],\" , any ( num_hidden_layers == [ 1 , line ])))) do layer = 1 , num_hidden_layers - 1 line = line + 1 lines ( line ) = string_t ( '         [' ) block real ( rkind ), allocatable :: hidden_layer_weights (:,:) integer j , l associate ( n => self % nodes_ , l => layer + 1 ) allocate ( hidden_layer_weights ( n ( l ), n ( l - 1 ))) do concurrent ( j = 1 : n ( l )) hidden_layer_weights ( j , 1 : n ( l - 1 )) = self % weights_ ( j , 1 : n ( l - 1 ), l ) end do hidden_layer_weights = transpose ( hidden_layer_weights ) end associate do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) hidden_layer_weights (:, neuron ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do end block line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers - 1 ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) associate ( n => self % nodes_ , l => ubound ( self % nodes_ , 1 )) write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , ubound ( self % biases_ , 2 )) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == num_outputs ))) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure skip use_skip_connections = self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string () == \"true\" end procedure module procedure activation_function_name activation_name = self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 )) end procedure end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules neuron_s Source Code neuron_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"neuron_s(construct): neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"neuron_s(construct): neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"neuron_s(construct): neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"neuron_s(construct): neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure module procedure function_name string = string_t ( \"step\" ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"network_configuration_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~network_configuration_s.f90~~EfferentGraph sourcefile~network_configuration_s.f90 network_configuration_s.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules network_configuration_s Source Code network_configuration_s.f90 Source Code submodule ( network_configuration_m ) network_configuration_s use assert_m , only : assert use sourcery_m , only : csv implicit none character ( len =* ), parameter :: skip_connections_key = \"skip connections\" character ( len =* ), parameter :: nodes_per_layer_key = \"nodes per layer\" character ( len =* ), parameter :: activation_name_key = \"activation function\" contains module procedure from_components network_configuration % skip_connections_ = skip_connections network_configuration % nodes_per_layer_ = nodes_per_layer network_configuration % activation_name_ = activation_name end procedure module procedure equals call assert ( allocated ( lhs % activation_name_ ) . and . allocated ( rhs % activation_name_ ), & \"network_configuration_s(equals): allocated({lhs,rhs}%activation_name_)\" ) lhs_equals_rhs = & lhs % skip_connections_ . eqv . rhs % skip_connections_ . and . & lhs % activation_name_ == rhs % activation_name_ . and . & all ( lhs % nodes_per_layer_ == rhs % nodes_per_layer_ ) end procedure module procedure from_json integer l logical network_configuration_key_found network_configuration_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"network configuration\" ) then network_configuration_key_found = . true . network_configuration % skip_connections_ = lines ( l + 1 )% get_json_value ( string_t ( skip_connections_key ), mold = . true .) network_configuration % nodes_per_layer_ = lines ( l + 2 )% get_json_value ( string_t ( nodes_per_layer_key ), mold = [ integer :: ]) network_configuration % activation_name_ = lines ( l + 3 )% get_json_value ( string_t ( activation_name_key ), mold = string_t ( \"\" )) return end if end do call assert ( network_configuration_key_found , \"network_configuration_s(from_json): network_configuration_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_logical_width = 6 , char_per_elem = 10 , brackets = 2 character ( len = max_logical_width ) skip_connections_string character ( len = :), allocatable :: nodes_per_layer_string allocate ( character ( len = size ( self % nodes_per_layer_ ) * char_per_elem + brackets ) :: nodes_per_layer_string ) write ( skip_connections_string , * ) trim ( merge ( \"true \" , \"false\" , self % skip_connections_ )) write ( nodes_per_layer_string , csv ) self % nodes_per_layer_ lines = [ & string_t ( indent // '\"network configuration\": {' ), & string_t ( indent // indent // '\"' // skip_connections_key // '\" : ' // trim ( adjustl ( skip_connections_string )) // ',' ), & string_t ( indent // indent // '\"' // nodes_per_layer_key // '\" : [' // trim ( adjustl ( nodes_per_layer_string )) // '],' ), & string_t ( indent // indent // '\"' // activation_name_key // '\" : \"' // trim ( adjustl ( self % activation_name_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure activation_name string = self % activation_name_ end procedure module procedure nodes_per_layer nodes = self % nodes_per_layer_ end procedure module procedure skip_connections using_skip = self % skip_connections_ end procedure end submodule network_configuration_s","tags":"","loc":"sourcefile/network_configuration_s.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules sigmoid_s Source Code sigmoid_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure module procedure function_name string = string_t ( \"sigmoid\" ) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layer_m Source Code layer_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use sourcery_m , only : string_t use kind_parameters_m , only : rkind use inference_engine_m_ , only : inference_engine_t implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: inference_engine procedure :: count_layers procedure :: count_neurons procedure :: count_inputs procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function inference_engine ( hidden_layers , metadata , output_layer ) result ( inference_engine_ ) implicit none class ( layer_t ), intent ( in ), target :: hidden_layers type ( layer_t ), intent ( in ), target :: output_layer type ( string_t ), intent ( in ) :: metadata (:) type ( inference_engine_t ) inference_engine_ end function module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ), intent ( in ) :: layer integer num_inputs end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules swish_s Source Code swish_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure module procedure function_name string = string_t ( \"swish\" ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"input_output_pair_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules input_output_pair_s Source Code input_output_pair_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s use assert_m , only : assert implicit none contains module procedure construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure inputs my_inputs = self % inputs_ end procedure module procedure expected_outputs my_expected_outputs = self % expected_outputs_ end procedure module procedure shuffle type ( input_output_pair_t ) temp integer i , j call assert ( size ( random_numbers ) >= size ( pairs ) - 1 , \"input_output_pair_s(shuffle): size(random_numbers) >= size(pairs)-1\" ) durstenfeld_shuffle : & do i = size ( pairs ), 2 , - 1 j = 1 + int ( random_numbers ( i ) * i ) temp = pairs ( i ) pairs ( i ) = pairs ( j ) pairs ( j ) = temp end do durstenfeld_shuffle end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"tensor_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_m.f90~~EfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~tensor_m.f90~~AfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules tensor_m Source Code tensor_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_m use kind_parameters_m , only : rkind implicit none private public :: tensor_t type tensor_t private real ( rkind ), allocatable :: values_ (:) contains procedure values procedure num_components end type interface tensor_t pure module function construct_from_components ( values ) result ( tensor ) implicit none real ( rkind ), intent ( in ) :: values (:) type ( tensor_t ) tensor end function end interface interface pure module function values ( self ) result ( tensor_values ) implicit none class ( tensor_t ), intent ( in ) :: self real ( rkind ), allocatable :: tensor_values (:) end function pure module function num_components ( self ) result ( n ) implicit none class ( tensor_t ), intent ( in ) :: self integer n end function end interface end module tensor_m","tags":"","loc":"sourcefile/tensor_m.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules differentiable_activation_strategy_m Source Code differentiable_activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules swish_m Source Code swish_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_m , only : string_t implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules neuron_m Source Code neuron_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use sourcery_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"trainable_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_s.f90~~EfferentGraph sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules trainable_engine_s Source Code trainable_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( trainable_engine_m ) trainable_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use input_output_pair_m , only : input_output_pair_t use sigmoid_m , only : sigmoid_t use tensor_m , only : tensor_t implicit none integer , parameter :: input_layer = 0 contains module procedure num_inputs n_in = self % n ( input_layer ) end procedure module procedure num_layers n_layers = size ( self % n , 1 ) end procedure module procedure num_outputs n_out = self % n ( ubound ( self % n , 1 )) end procedure module procedure construct_from_inference_engine associate ( exchange => inference_engine % to_exchange ()) trainable_engine % metadata_ = exchange % metadata_ trainable_engine % w = exchange % weights_ trainable_engine % b = exchange % biases_ trainable_engine % n = exchange % nodes_ select type ( activation => exchange % activation_strategy_ ) class is ( differentiable_activation_strategy_t ) trainable_engine % differentiable_activation_strategy_ = activation class default error stop \"trainable_engine_s(from_inference_engine): activation strategy must be a differentiable_activation_stragegy_t\" end select end associate end procedure module procedure assert_consistent associate ( & fully_allocated => [ allocated ( self % w ), allocated ( self % b ), allocated ( self % n ), allocated ( self % differentiable_activation_strategy_ )] & ) call assert ( all ( fully_allocated ), \"trainable_engine_s(assert_consistent): fully_allocated\" , intrinsic_array_t ( fully_allocated )) end associate associate ( max_width => maxval ( self % n ), component_dims => [ size ( self % b , 1 ), size ( self % w , 1 ), size ( self % w , 2 )]) call assert ( all ( component_dims == max_width ), \"trainable_engine_s(assert_consistent): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate call assert ( lbound ( self % n , 1 ) == input_layer , \"trainable_engine_s(assert_consistent): n base subsscript\" , lbound ( self % n , 1 )) end procedure module procedure infer real ( rkind ), allocatable :: z (:,:), a (:,:) integer l call self % assert_consistent associate ( w => self % w , b => self % b , n => self % n , output_layer => ubound ( self % n , 1 )) allocate ( z , mold = b ) allocate ( a ( maxval ( n ), input_layer : output_layer )) ! Activations a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end procedure module procedure train integer l , batch , mini_batch_size , pair real ( rkind ), allocatable :: & z (:,:), a (:,:), delta (:,:), dcdw (:,:,:), dcdb (:,:), vdw (:,:,:), sdw (:,:,:), vdb (:,:), sdb (:,:), vdwc (:,:,:), sdwc (:,:,:), & vdbc (:,:), sdbc (:,:) type ( tensor_t ), allocatable :: inputs (:), expected_outputs (:) real ( rkind ) eta , alpha eta = learning_rate alpha = learning_rate call self % assert_consistent associate ( output_layer => ubound ( self % n , 1 )) allocate ( a ( maxval ( self % n ), input_layer : output_layer )) ! Activations allocate ( dcdw , mold = self % w ) ! Gradient of cost function with respect to weights allocate ( vdw , mold = self % w ) allocate ( sdw , mold = self % w ) allocate ( vdwc , mold = self % w ) allocate ( sdwc , mold = self % w ) allocate ( z , mold = self % b ) ! z-values: Sum z_j&#94;l = w_jk&#94;{l} a_k&#94;{l-1} + b_j&#94;l allocate ( delta , mold = self % b ) allocate ( dcdb , mold = self % b ) ! Gradient of cost function with respect with biases allocate ( vdb , mold = self % b ) allocate ( sdb , mold = self % b ) allocate ( vdbc , mold = self % b ) allocate ( sdbc , mold = self % b ) vdw = 0.d0 sdw = 1.d0 vdb = 0.d0 sdb = 1.d0 associate ( w => self % w , b => self % b , n => self % n , num_mini_batches => size ( mini_batches )) if ( present ( cost )) allocate ( cost ( num_mini_batches )) iterate_across_batches : & do batch = 1 , num_mini_batches if ( present ( cost )) cost ( batch ) = 0. dcdw = 0. ; dcdb = 0. associate ( input_output_pairs => mini_batches ( batch )% input_output_pairs ()) inputs = input_output_pairs % inputs () expected_outputs = input_output_pairs % expected_outputs () mini_batch_size = size ( input_output_pairs ) end associate iterate_through_batch : & do pair = 1 , mini_batch_size a ( 1 : self % num_inputs (), input_layer ) = inputs ( pair )% values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward associate ( y => expected_outputs ( pair )% values ()) if ( present ( cost )) & cost ( batch ) = cost ( batch ) + sum (( y ( 1 : n ( output_layer )) - a ( 1 : n ( output_layer ), output_layer )) ** 2 ) / ( 2.e0 * mini_batch_size ) delta ( 1 : n ( output_layer ), output_layer ) = & ( a ( 1 : n ( output_layer ), output_layer ) - y ( 1 : n ( output_layer ))) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( output_layer ), output_layer )) end associate associate ( n_hidden => self % num_layers () - 2 ) back_propagate_error : & do l = n_hidden , 1 , - 1 delta ( 1 : n ( l ), l ) = matmul ( transpose ( w ( 1 : n ( l + 1 ), 1 : n ( l ), l + 1 )), delta ( 1 : n ( l + 1 ), l + 1 )) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( l ), l )) end do back_propagate_error end associate block integer j sum_gradients : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) + delta ( 1 : n ( l ), l ) do concurrent ( j = 1 : n ( l )) dcdw ( j , 1 : n ( l - 1 ), l ) = dcdw ( j , 1 : n ( l - 1 ), l ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do end do sum_gradients end block end do iterate_through_batch if ( adam ) then block ! Adam parameters real , parameter :: beta ( * ) = [. 9_rkind , . 999_rkind ] real , parameter :: obeta ( * ) = [ 1._rkind - beta ( 1 ), 1._rkind - beta ( 2 )] real , parameter :: epsilon = real ( 1.D-08 , rkind ) adjust_weights_and_biases : & do l = 1 , output_layer dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( mini_batch_size ) vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 1 ) * vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 1 ) * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 2 ) * sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 2 ) * ( dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ** 2 ) vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1._rkind - beta ( 1 ) ** num_mini_batches ) sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1._rkind - beta ( 2 ) ** num_mini_batches ) w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) & - alpha * vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( sqrt ( sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l )) + epsilon ) ! Adjust weights dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size vdb ( 1 : n ( l ), l ) = beta ( 1 ) * vdb ( 1 : n ( l ), l ) + obeta ( 1 ) * dcdb ( 1 : n ( l ), l ) sdb ( 1 : n ( l ), l ) = beta ( 2 ) * sdb ( 1 : n ( l ), l ) + obeta ( 2 ) * ( dcdb ( 1 : n ( l ), l ) ** 2 ) vdbc ( 1 : n ( l ), l ) = vdb ( 1 : n ( l ), l ) / ( 1._rkind - beta ( 1 ) ** num_mini_batches ) sdbc ( 1 : n ( l ), l ) = sdb ( 1 : n ( l ), l ) / ( 1._rkind - beta ( 2 ) ** num_mini_batches ) b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - alpha * vdbc ( 1 : n ( l ), l ) / ( sqrt ( sdbc ( 1 : n ( l ), l )) + epsilon ) ! Adjust weights end do adjust_weights_and_biases end block else adjust_weights_and_biases : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - eta * dcdb ( 1 : n ( l ), l ) ! Adjust biases dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / mini_batch_size w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - eta * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ! Adjust weights end do adjust_weights_and_biases end if end do iterate_across_batches end associate end associate end procedure module procedure construct_from_padded_arrays trainable_engine % metadata_ = metadata trainable_engine % n = nodes trainable_engine % w = weights trainable_engine % b = biases trainable_engine % differentiable_activation_strategy_ = differentiable_activation_strategy call trainable_engine % assert_consistent end procedure module procedure to_inference_engine inference_engine = inference_engine_t ( metadata = self % metadata_ , weights = self % w , biases = self % b , nodes = self % n ) end procedure end submodule trainable_engine_s","tags":"","loc":"sourcefile/trainable_engine_s.f90.html"},{"title":"learn-multiplication.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-multiplication.f90~~EfferentGraph sourcefile~learn-multiplication.f90 learn-multiplication.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_polynomials Modules multiply_inputs Source Code learn-multiplication.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module multiply_inputs !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) * x ( 2 ), x ( 2 ) * x ( 3 ), x ( 3 ) * x ( 4 ), x ( 4 ) * x ( 5 ), x ( 5 ) * x ( 6 ), x ( 6 ) * x ( 8 )]) end associate end function end module program train_polynomials !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use multiply_inputs , only : y implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-polynomials -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-multiplication.f90.html"},{"title":"learn-microphysics-procedures.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-microphysics-procedures.f90~~EfferentGraph sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs learn_microphysics_procedures Source Code learn-microphysics-procedures.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program learn_microphysics_procedures !! Train a neural network proxies for procedures in the Thompson microphysics model !! in of ICAR (https://github.com/BerkeleyLab/icar). use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , sigmoid_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use thompson_tensors_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run learn_microphysics_procedures -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 10 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 2 ] real , parameter :: cost_tolerance = 1.E-08 call random_init ( image_distinct = . true ., repeatable = . true .) open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \" Inputs (normalized)          | Outputs                    | Desired outputs\" do p = 1 , num_pairs print \"(6(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do end associate end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = sigmoid_t (), & metadata = & [ string_t ( \"Thompson microphysics procedures\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"sigmoid\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-microphysics-procedures.f90.html"},{"title":"print-training-configuration.f90 – Inference-Engine","text":"This file depends on sourcefile~~print-training-configuration.f90~~EfferentGraph sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs print_training_configuration Source Code print-training-configuration.f90 Source Code program print_training_configuration !! Demonstrate how to construct and print a training_configuration_t object use inference_engine_m , only : training_configuration_t , hyperparameters_t , network_configuration_t use sourcery_m , only : file_t implicit none associate ( training_configuration => training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" ) & )) associate ( lines => training_configuration % to_json ()) associate ( json_file => file_t ( lines )) call json_file % write_lines () end associate end associate end associate end program","tags":"","loc":"sourcefile/print-training-configuration.f90.html"},{"title":"learn-saturated-mixing-ratio.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-saturated-mixing-ratio.f90~~EfferentGraph sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_saturated_mixture_ratio Source Code learn-saturated-mixing-ratio.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_saturated_mixture_ratio !! This program trains a neural network to learn the saturated mixing ratio function of ICAR. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use saturated_mixing_ratio_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example learn-saturated-mixing-ratio -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 6 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 1 ] real , parameter :: cost_tolerance = 1.E-08 call random_init ( image_distinct = . true ., repeatable = . true .) open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \"Inputs (normalized)          | Outputs      | Desired outputs\" do p = 1 , num_pairs print \"(4(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do end associate end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Saturated Mixing Ratio\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-saturated-mixing-ratio.f90.html"},{"title":"learn-power-series.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-power-series.f90~~EfferentGraph sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_polynomials Modules power_series Source Code learn-power-series.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module power_series !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ 1 + x ( 1 ) + ( x ( 1 ) ** 2 ) / 2 + ( x ( 1 ) ** 3 ) / 6 , x ( 2 ), x ( 3 ), x ( 4 ), x ( 5 ), x ( 6 )]) end associate end function end module program train_polynomials !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use power_series , only : y implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-polynomials -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 10000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) real white_noise ( 1 : num_inputs , 1 : num_pairs ) call random_number ( white_noise ) inputs = [( tensor_t ( real ([( white_noise ( j , i ), j = 1 , num_inputs )])), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 196 , 196 , 196 , 196 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-power-series.f90.html"},{"title":"train-and-write.f90 – Inference-Engine","text":"This file depends on sourcefile~~train-and-write.f90~~EfferentGraph sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_and_write Source Code train-and-write.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_and_write !! This program demonstrates how to train a simple neural network starting from a randomized initial condition and !! how to write the initial network and the trained network to separate JSON files.  The network has two hiden layers. !! The input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match !! the corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions, !! the desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere. !! The initial condition corresponds to the desired network with all weights and biases perturbed by a random variable !! that is uniformly distributed on the range [0,0.1]. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-and-write -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 5 , num_epochs = 500 , num_mini_batches = 3 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.2 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) call assert ( num_inputs == num_outputs , \"trainable_engine_test_m(identity_mapping): # inputs == # outputs\" , & intrinsic_array_t ([ num_inputs , num_outputs ]) & ) block integer i , j inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] end block associate ( outputs => inputs ) input_output_pairs = input_output_pair_t ( inputs , outputs ) end associate block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \" Outputs                          |& Desired outputs                    |& Errors\" do p = 1 , num_pairs print * , network_outputs ( p )% values (), \"|\" , inputs ( p )% values (), \"|\" , network_outputs ( p )% values () - inputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) integer i real , parameter :: identity ( * , * , * ) = & reshape ( real ([( [ 1 , 0 ], [ 0 , 1 ], i = 1 , layers - 1 )]), [ max_n , max_n , layers - 1 ]) real w_harvest ( size ( identity , 1 ), size ( identity , 2 ), size ( identity , 3 )), b_harvest ( size ( identity , 1 ), size ( identity , 3 )) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = nodes_per_layer , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/train-and-write.f90.html"},{"title":"fit-polynomials.f90 – Inference-Engine","text":"This file depends on sourcefile~~fit-polynomials.f90~~EfferentGraph sourcefile~fit-polynomials.f90 fit-polynomials.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~fit-polynomials.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_polynomials Source Code fit-polynomials.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_polynomials !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-polynomials -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 5 , num_epochs = 500 , num_mini_batches = 3 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.1 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) call assert ( num_outputs == size ( desired_outputs ( 1 )% values ()), & \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , size ( desired_outputs ( 1 )% values ())]) & ) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \" Outputs                                             | Desired outputs\" do p = 1 , num_pairs print * , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ), x ( 2 ) + x ( 3 ), x ( 4 ), x ( 5 ), 0.5 * x ( 6 ) + 1.5 * x ( 7 ), x ( 8 )]) end associate end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 8 , 8 , 8 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/fit-polynomials.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs write_read_infer Source Code write-read-infer.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference.  The network performs an identity mapping from any !! non-negative inputs to the corresponding outputs using a RELU activation !! function. use inference_engine_m , only : inference_engine_t , relu_t , tensor_t use sourcery_m , only : string_t , command_line_t , file_t use kind_parameters_m , only : rkind implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example identity -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains function identity_network () result ( inference_engine ) type ( inference_engine_t ) inference_engine integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) inference_engine = inference_engine_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = reshape ([ real ( rkind ) :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]), & biases = reshape ([ real ( rkind ) :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) end function subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"},{"title":"learn-exponentiation.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-exponentiation.f90~~EfferentGraph sourcefile~learn-exponentiation.f90 learn-exponentiation.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_polynomials Modules raise_inputs_to_a_power Source Code learn-exponentiation.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module raise_inputs_to_a_power !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) ** 2 , x ( 2 ) ** 3 , x ( 3 ) ** 4 , x ( 4 ) ** 4 , x ( 5 ) ** 3 , x ( 6 ) ** 2 ]) end associate end function end module program train_polynomials !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use raise_inputs_to_a_power , only : y implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-polynomials -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-exponentiation.f90.html"},{"title":"learn-addition.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-addition.f90~~EfferentGraph sourcefile~learn-addition.f90 learn-addition.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_polynomials Modules add_inputs Source Code learn-addition.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module add_inputs !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) + x ( 2 ), x ( 2 ) + x ( 3 ), x ( 3 ) + x ( 4 ), x ( 4 ) + x ( 5 ), x ( 5 ) + x ( 6 ), x ( 6 ) + x ( 8 )]) end associate end function end module program train_polynomials !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use add_inputs , only : y implicit none type ( string_t ) intial_network_file , final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-polynomials -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs , random_numbers ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-addition.f90.html"},{"title":"saturated_mixing_ratio_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~saturated_mixing_ratio_m.f90~~EfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~saturated_mixing_ratio_m.f90~~AfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules saturated_mixing_ratio_m Source Code saturated_mixing_ratio_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. module saturated_mixing_ratio_m !! This module supports the program in the file example/learn-saturated-mixing-ratio.f90. !! The saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function !! in the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90. !! ICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: freezing_threshold = 27 3.15 ! [K] real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains pure function saturated_mixing_ratio ( T_normalized , p_normalized ) result ( sat_mr ) !! Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) real , intent ( in ) :: T_normalized , p_normalized real sat_mr associate ( & temperature => T_min + ( T_max - T_min ) * T_normalized , & pressure => p_min + ( p_max - p_min ) * p_normalized & ) associate ( below_freezing => temperature < freezing_threshold ) associate ( & a => merge ( 2 1.8745584 , 1 7.2693882 , below_freezing ), & b => merge ( 7.66 , 3 5.86 , below_freezing ) & ) associate ( p_threshold => 61 0.78 * exp ( a * ( temperature - 27 3.16 ) / ( temperature - b ))) !(Pa)) associate ( e_s => merge ( pressure * 0.99999 , p_threshold , ( pressure - p_threshold ) <= 0 )) sat_mr = 0.6219907 * e_s / ( pressure - e_s ) !(kg/kg) end associate end associate end associate end associate end associate end function elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ saturated_mixing_ratio ( x ( 1 ), x ( 2 ))]) end associate end function end module","tags":"","loc":"sourcefile/saturated_mixing_ratio_m.f90.html"},{"title":"thompson_tensors_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~thompson_tensors_m.f90~~EfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~thompson_tensors_m.f90~~AfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules thompson_tensors_m Source Code thompson_tensors_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module thompson_tensors_m !! This module supports the program in the file example/learn-microphysics-procedures.f90. use module_mp_thompson , only : rslf , rsif use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains elemental impure function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) associate ( temperature => T_min + ( T_max - T_min ) * x ( 1 ), pressure => p_min + ( p_max - p_min ) * x ( 2 ) ) a = tensor_t ([ rslf ( pressure , temperature ), rsif ( pressure , temperature )]) end associate end associate end function end module","tags":"","loc":"sourcefile/thompson_tensors_m.f90.html"},{"title":"mp_thompson.f90 – Inference-Engine","text":"This subroutine computes the moisture tendencies of water vapor,\n   cloud droplets, rain, cloud ice (pristine), snow, and graupel. Prior to WRFv2.2 this code was based on Reisner et al (1998), but\n   few of those pieces remain.  A complete description is now found in\n   Thompson, G., P. R. Field, R. M. Rasmussen, and W. D. Hall, 2008:\n   Explicit Forecasts of winter precipitation using an improved bulk\n   microphysics scheme. Part II: Implementation of a new snow\n   parameterization.  Mon. Wea. Rev., 136, 5095-5115.\n   Prior to WRFv3.1, this code was single-moment rain prediction as\n   described in the reference above, but in v3.1 and higher, the\n   scheme is two-moment rain (predicted rain number concentration). Most importantly, users may wish to modify the prescribed number of\n   cloud droplets (Nt_c; see guidelines mentioned below).  Otherwise,\n   users may alter the rain and graupel size distribution parameters\n   to use exponential (Marshal-Palmer) or generalized gamma shape.\n   The snow field assumes a combination of two gamma functions (from\n   Field et al. 2005) and would require significant modifications\n   throughout the entire code to alter its shape as well as accretion\n   rates.  Users may also alter the constants used for density of rain,\n   graupel, ice, and snow, but the latter is not constant when using\n   Paul Field's snow distribution and moments methods.  Other values\n   users can modify include the constants for mass and/or velocity\n   power law relations and assumed capacitances used in deposition/\n   sublimation/evaporation/melting.\n   Remaining values should probably be left alone. Modifications for ICAR include OPENMP paralellization and the ability\n  to input many important parameters so they are no longer hard coded @author Greg Thompson, NCAR-RAL, gthompsn@ucar.edu, 303-497-2805\n  Last modified: 27 Jul 2012 Files dependent on this one sourcefile~~mp_thompson.f90~~AfferentGraph sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules module_mp_thompson Source Code mp_thompson.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. !>---------------------------------------------------------------------- !!   This subroutine computes the moisture tendencies of water vapor, !!   cloud droplets, rain, cloud ice (pristine), snow, and graupel. !! !!   Prior to WRFv2.2 this code was based on Reisner et al (1998), but !!   few of those pieces remain.  A complete description is now found in !!   Thompson, G., P. R. Field, R. M. Rasmussen, and W. D. Hall, 2008: !!   Explicit Forecasts of winter precipitation using an improved bulk !!   microphysics scheme. Part II: Implementation of a new snow !!   parameterization.  Mon. Wea. Rev., 136, 5095-5115. !!   Prior to WRFv3.1, this code was single-moment rain prediction as !!   described in the reference above, but in v3.1 and higher, the !!   scheme is two-moment rain (predicted rain number concentration). !! !!   Most importantly, users may wish to modify the prescribed number of !!   cloud droplets (Nt_c; see guidelines mentioned below).  Otherwise, !!   users may alter the rain and graupel size distribution parameters !!   to use exponential (Marshal-Palmer) or generalized gamma shape. !!   The snow field assumes a combination of two gamma functions (from !!   Field et al. 2005) and would require significant modifications !!   throughout the entire code to alter its shape as well as accretion !!   rates.  Users may also alter the constants used for density of rain, !!   graupel, ice, and snow, but the latter is not constant when using !!   Paul Field's snow distribution and moments methods.  Other values !!   users can modify include the constants for mass and/or velocity !!   power law relations and assumed capacitances used in deposition/ !!   sublimation/evaporation/melting. !!   Remaining values should probably be left alone. !! !!  Modifications for ICAR include OPENMP paralellization and the ability !!  to input many important parameters so they are no longer hard coded !! !!  @author Greg Thompson, NCAR-RAL, gthompsn@ucar.edu, 303-497-2805 !!  Last modified: 27 Jul 2012 !! !!-------------------------------------------------------------------- !wrft:model_layer:physics !+---+-----------------------------------------------------------------+ ! MODULE module_mp_thompson !!!      use options_types, only: mp_options_type !!! commented for compilation outside ICAR !       USE module_wrf_error ! \t\tUSE module_mp_radar !     USE module_utility, ONLY: WRFU_Clock, WRFU_Alarm !     USE module_domain, ONLY : HISTORY_ALARM, Is_alarm_tstep IMPLICIT NONE LOGICAL , PARAMETER , PRIVATE :: iiwarm = . false . INTEGER , PARAMETER , PRIVATE :: IFDRY = 0 REAL , PARAMETER , PRIVATE :: T_0 = 27 3.15 !      REAL, PARAMETER, PRIVATE:: PI = 3.1415926536  !trude added. Note, pi is defined in data_structures, and conflict with definition here. Need to determine what to to about it. REAL , PARAMETER , PRIVATE :: PI2 = 3.1415926536 !trude added. Note, pi is defined in data_structures, and conflict with definition here. Need to determine what to to about it. !..Densities of rain, snow, graupel, and cloud ice. REAL , PARAMETER , PRIVATE :: rho_w = 100 0.0 REAL , PARAMETER , PRIVATE :: rho_s = 10 0.0 !     REAL, PARAMETER, PRIVATE:: rho_g = 500.0   ! trude commented out for changing from parameter to input variable REAL , PARAMETER , PRIVATE :: rho_i = 89 0.0 !..Prescribed number of cloud droplets.  Set according to known data or !.. roughly 100 per cc (100.E6 m&#94;-3) for Maritime cases and !.. 300 per cc (300.E6 m&#94;-3) for Continental.  Gamma shape parameter, !.. mu_c, calculated based on Nt_c is important in autoconversion !.. scheme. ! ++ trude comment out !      REAL, PARAMETER, PRIVATE:: Nt_c = 100.E6 ! -- trude comment out !..Generalized gamma distributions for rain, graupel and cloud ice. !.. N(D) = N_0 * D**mu * exp(-lamda*D);  mu=0 is exponential. !      REAL, PARAMETER, PRIVATE:: mu_r = 0.0 REAL , PARAMETER , PRIVATE :: mu_g = 0.0 REAL , PARAMETER , PRIVATE :: mu_i = 0.0 REAL , PRIVATE :: mu_c !..Sum of two gamma distrib for snow (Field et al. 2005). !.. N(D) = M2**4/M3**3 * [Kap0*exp(-M2*Lam0*D/M3) !..    + Kap1*(M2/M3)**mu_s * D**mu_s * exp(-M2*Lam1*D/M3)] !.. M2 and M3 are the (bm_s)th and (bm_s+1)th moments respectively !.. calculated as function of ice water content and temperature. REAL , PARAMETER , PRIVATE :: mu_s = 0.6357 REAL , PARAMETER , PRIVATE :: Kap0 = 49 0.6 REAL , PARAMETER , PRIVATE :: Kap1 = 1 7.46 REAL , PARAMETER , PRIVATE :: Lam0 = 2 0.78 REAL , PARAMETER , PRIVATE :: Lam1 = 3.29 !..Y-intercept parameter for graupel is not constant and depends on !.. mixing ratio.  Also, when mu_g is non-zero, these become equiv !.. y-intercept for an exponential distrib and proper values are !.. computed based on same mixing ratio and total number concentration. REAL , PARAMETER , PRIVATE :: gonv_min = 1.E4 REAL , PARAMETER , PRIVATE :: gonv_max = 3.E6 !..Mass power law relations:  mass = am*D**bm !.. Snow from Field et al. (2005), others assume spherical form. REAL , PARAMETER , PRIVATE :: am_r = PI2 * rho_w / 6.0 REAL , PARAMETER , PRIVATE :: bm_r = 3.0 !      REAL, PARAMETER, PRIVATE:: am_s = 0.069  ! trude commented out for changing from parameter to input variable REAL , PARAMETER , PRIVATE :: bm_s = 2.0 !      REAL, PARAMETER, PRIVATE:: am_g = PI2*rho_g/6.0  ! trude commented out. am_g need to be calculated later since rho_g is an imput variable REAL , PARAMETER , PRIVATE :: bm_g = 3.0 REAL , PARAMETER , PRIVATE :: am_i = PI2 * rho_i / 6.0 REAL , PARAMETER , PRIVATE :: bm_i = 3.0 !..Fallspeed power laws relations:  v = (av*D**bv)*exp(-fv*D) !.. Rain from Ferrier (1994), ice, snow, and graupel from !.. Thompson et al (2008). Coefficient fv is zero for graupel/ice. REAL , PARAMETER , PRIVATE :: av_r = 485 4.0 REAL , PARAMETER , PRIVATE :: bv_r = 1.0 REAL , PARAMETER , PRIVATE :: fv_r = 19 5.0 !      REAL, PARAMETER, PRIVATE:: av_s = 40.0 ! trude commented out.  Will be used as input vaiable. !      REAL, PARAMETER, PRIVATE:: bv_s = 0.55 ! trude commented out.  Will be used as input vaiable. !      REAL, PARAMETER, PRIVATE:: fv_s = 100.0 ! trude commented out.  Will be used as input vaiable. !      REAL, PARAMETER, PRIVATE:: av_g = 442.0 ! trude commented out.  Will be used as input vaiable. !      REAL, PARAMETER, PRIVATE:: bv_g = 0.89 ! trude commented out.  Will be used as input vaiable. !      REAL, PARAMETER, PRIVATE:: av_i = 1847.5 REAL , PARAMETER , PRIVATE :: bv_i = 1.0 !..Capacitance of sphere and plates/aggregates: D**3, D**2 REAL , PARAMETER , PRIVATE :: C_cube = 0.5 !      REAL, PARAMETER, PRIVATE:: C_sqrd = 0.3 !..Collection efficiencies.  Rain/snow/graupel collection of cloud !.. droplets use variables (Ef_rw, Ef_sw, Ef_gw respectively) and !.. get computed elsewhere because they are dependent on stokes !.. number. !      REAL, PARAMETER, PRIVATE:: Ef_si = 0.05 !      REAL, PARAMETER, PRIVATE:: Ef_rs = 0.95 !      REAL, PARAMETER, PRIVATE:: Ef_rg = 0.75 !      REAL, PARAMETER, PRIVATE:: Ef_ri = 0.95 !..Minimum microphys values !.. R1 value, 1.E-12, cannot be set lower because of numerical !.. problems with Paul Field's moments and should not be set larger !.. because of truncation problems in snow/ice growth. REAL , PARAMETER , PRIVATE :: R1 = 1.E-12 REAL , PARAMETER , PRIVATE :: R2 = 1.E-6 REAL , PARAMETER , PRIVATE :: eps = 1.E-15 !..Constants in Cooper curve relation for cloud ice number. !     REAL, PARAMETER, PRIVATE:: TNO = 5.0  ! trude comment this out for use as input variable instead REAL , PARAMETER , PRIVATE :: ATO = 0.304 !..Rho_not used in fallspeed relations (rho_not/rho)**.5 adjustment. REAL , PARAMETER , PRIVATE :: rho_not = 10132 5.0 / ( 28 7.05 * 29 8.0 ) !..Schmidt number REAL , PARAMETER , PRIVATE :: Sc = 0.632 REAL , PRIVATE :: Sc3 !..Homogeneous freezing temperature REAL , PARAMETER , PRIVATE :: HGFR = 23 5.16 !..Water vapor and air gas constants at constant pressure REAL , PARAMETER , PRIVATE :: Rv = 46 1.5 REAL , PARAMETER , PRIVATE :: oRv = 1. / Rv !      REAL, PARAMETER, PRIVATE:: R = 287.04 !trude added. Note, R = 287.058 is defined in data_structures, and conflict with definition here. Need to determine what to to about it. REAL , PARAMETER , PRIVATE :: RR2 = 28 7.04 !trude added. Note, R = 287.058 is defined in data_structures, and conflict with definition here. Need to determine what to to about it. !      REAL, PARAMETER, PRIVATE:: Cp = 1004.0 !trude added. Note, Cp = 1012.0 is defined in data_structures, and conflict with definition here. Need to determine what to to about it. REAL , PARAMETER , PRIVATE :: Cp2 = 100 4.0 !trude added. Note, Cp = 1012.0 is defined in data_structures, and conflict with definition here. Need to determine what to to about it. !..Enthalpy of sublimation, vaporization, and fusion at 0C. REAL , PARAMETER , PRIVATE :: lsub = 2.834E6 REAL , PARAMETER , PRIVATE :: lvap0 = 2.5E6 REAL , PARAMETER , PRIVATE :: lfus = lsub - lvap0 REAL , PARAMETER , PRIVATE :: olfus = 1. / lfus !..Ice initiates with this mass (kg), corresponding diameter calc. !..Min diameters and mass of cloud, rain, snow, and graupel (m, kg). REAL , PARAMETER , PRIVATE :: xm0i = 1.E-12 REAL , PARAMETER , PRIVATE :: D0c = 1.E-6 REAL , PARAMETER , PRIVATE :: D0r = 5 0.E-6 REAL , PARAMETER , PRIVATE :: D0s = 20 0.E-6 REAL , PARAMETER , PRIVATE :: D0g = 25 0.E-6 REAL , PRIVATE :: D0i , xm0s , xm0g !..Lookup table dimensions INTEGER , PARAMETER , PRIVATE :: nbins = 100 INTEGER , PARAMETER , PRIVATE :: nbc = nbins INTEGER , PARAMETER , PRIVATE :: nbi = nbins INTEGER , PARAMETER , PRIVATE :: nbr = nbins INTEGER , PARAMETER , PRIVATE :: nbs = nbins INTEGER , PARAMETER , PRIVATE :: nbg = nbins INTEGER , PARAMETER , PRIVATE :: ntb_c = 37 INTEGER , PARAMETER , PRIVATE :: ntb_i = 64 INTEGER , PARAMETER , PRIVATE :: ntb_r = 37 INTEGER , PARAMETER , PRIVATE :: ntb_s = 28 INTEGER , PARAMETER , PRIVATE :: ntb_g = 28 INTEGER , PARAMETER , PRIVATE :: ntb_g1 = 28 INTEGER , PARAMETER , PRIVATE :: ntb_r1 = 37 INTEGER , PARAMETER , PRIVATE :: ntb_i1 = 55 INTEGER , PARAMETER , PRIVATE :: ntb_t = 9 INTEGER , PRIVATE :: nic2 , nii2 , nii3 , nir2 , nir3 , nis2 , nig2 , nig3 DOUBLE PRECISION , DIMENSION ( nbins + 1 ) :: xDx DOUBLE PRECISION , DIMENSION ( nbc ) :: Dc , dtc DOUBLE PRECISION , DIMENSION ( nbi ) :: Di , dti DOUBLE PRECISION , DIMENSION ( nbr ) :: Dr , dtr DOUBLE PRECISION , DIMENSION ( nbs ) :: Ds , dts DOUBLE PRECISION , DIMENSION ( nbg ) :: Dg , dtg !..Lookup tables for cloud water content (kg/m**3). REAL , DIMENSION ( ntb_c ), PARAMETER , PRIVATE :: & r_c = ( / 1.e-6 , 2.e-6 , 3.e-6 , 4.e-6 , 5.e-6 , 6.e-6 , 7.e-6 , 8.e-6 , 9.e-6 , & 1.e-5 , 2.e-5 , 3.e-5 , 4.e-5 , 5.e-5 , 6.e-5 , 7.e-5 , 8.e-5 , 9.e-5 , & 1.e-4 , 2.e-4 , 3.e-4 , 4.e-4 , 5.e-4 , 6.e-4 , 7.e-4 , 8.e-4 , 9.e-4 , & 1.e-3 , 2.e-3 , 3.e-3 , 4.e-3 , 5.e-3 , 6.e-3 , 7.e-3 , 8.e-3 , 9.e-3 , & 1.e-2 / ) !..Lookup tables for cloud ice content (kg/m**3). REAL , DIMENSION ( ntb_i ), PARAMETER , PRIVATE :: & r_i = ( / 1.e-10 , 2.e-10 , 3.e-10 , 4.e-10 , & 5.e-10 , 6.e-10 , 7.e-10 , 8.e-10 , 9.e-10 , & 1.e-9 , 2.e-9 , 3.e-9 , 4.e-9 , 5.e-9 , 6.e-9 , 7.e-9 , 8.e-9 , 9.e-9 , & 1.e-8 , 2.e-8 , 3.e-8 , 4.e-8 , 5.e-8 , 6.e-8 , 7.e-8 , 8.e-8 , 9.e-8 , & 1.e-7 , 2.e-7 , 3.e-7 , 4.e-7 , 5.e-7 , 6.e-7 , 7.e-7 , 8.e-7 , 9.e-7 , & 1.e-6 , 2.e-6 , 3.e-6 , 4.e-6 , 5.e-6 , 6.e-6 , 7.e-6 , 8.e-6 , 9.e-6 , & 1.e-5 , 2.e-5 , 3.e-5 , 4.e-5 , 5.e-5 , 6.e-5 , 7.e-5 , 8.e-5 , 9.e-5 , & 1.e-4 , 2.e-4 , 3.e-4 , 4.e-4 , 5.e-4 , 6.e-4 , 7.e-4 , 8.e-4 , 9.e-4 , & 1.e-3 / ) !..Lookup tables for rain content (kg/m**3). REAL , DIMENSION ( ntb_r ), PARAMETER , PRIVATE :: & r_r = ( / 1.e-6 , 2.e-6 , 3.e-6 , 4.e-6 , 5.e-6 , 6.e-6 , 7.e-6 , 8.e-6 , 9.e-6 , & 1.e-5 , 2.e-5 , 3.e-5 , 4.e-5 , 5.e-5 , 6.e-5 , 7.e-5 , 8.e-5 , 9.e-5 , & 1.e-4 , 2.e-4 , 3.e-4 , 4.e-4 , 5.e-4 , 6.e-4 , 7.e-4 , 8.e-4 , 9.e-4 , & 1.e-3 , 2.e-3 , 3.e-3 , 4.e-3 , 5.e-3 , 6.e-3 , 7.e-3 , 8.e-3 , 9.e-3 , & 1.e-2 / ) !..Lookup tables for graupel content (kg/m**3). REAL , DIMENSION ( ntb_g ), PARAMETER , PRIVATE :: & r_g = ( / 1.e-5 , 2.e-5 , 3.e-5 , 4.e-5 , 5.e-5 , 6.e-5 , 7.e-5 , 8.e-5 , 9.e-5 , & 1.e-4 , 2.e-4 , 3.e-4 , 4.e-4 , 5.e-4 , 6.e-4 , 7.e-4 , 8.e-4 , 9.e-4 , & 1.e-3 , 2.e-3 , 3.e-3 , 4.e-3 , 5.e-3 , 6.e-3 , 7.e-3 , 8.e-3 , 9.e-3 , & 1.e-2 / ) !..Lookup tables for snow content (kg/m**3). REAL , DIMENSION ( ntb_s ), PARAMETER , PRIVATE :: & r_s = ( / 1.e-5 , 2.e-5 , 3.e-5 , 4.e-5 , 5.e-5 , 6.e-5 , 7.e-5 , 8.e-5 , 9.e-5 , & 1.e-4 , 2.e-4 , 3.e-4 , 4.e-4 , 5.e-4 , 6.e-4 , 7.e-4 , 8.e-4 , 9.e-4 , & 1.e-3 , 2.e-3 , 3.e-3 , 4.e-3 , 5.e-3 , 6.e-3 , 7.e-3 , 8.e-3 , 9.e-3 , & 1.e-2 / ) !..Lookup tables for rain y-intercept parameter (/m**4). REAL , DIMENSION ( ntb_r1 ), PARAMETER , PRIVATE :: & N0r_exp = ( / 1.e6 , 2.e6 , 3.e6 , 4.e6 , 5.e6 , 6.e6 , 7.e6 , 8.e6 , 9.e6 , & 1.e7 , 2.e7 , 3.e7 , 4.e7 , 5.e7 , 6.e7 , 7.e7 , 8.e7 , 9.e7 , & 1.e8 , 2.e8 , 3.e8 , 4.e8 , 5.e8 , 6.e8 , 7.e8 , 8.e8 , 9.e8 , & 1.e9 , 2.e9 , 3.e9 , 4.e9 , 5.e9 , 6.e9 , 7.e9 , 8.e9 , 9.e9 , & 1.e10 / ) !..Lookup tables for graupel y-intercept parameter (/m**4). REAL , DIMENSION ( ntb_g1 ), PARAMETER , PRIVATE :: & N0g_exp = ( / 1.e4 , 2.e4 , 3.e4 , 4.e4 , 5.e4 , 6.e4 , 7.e4 , 8.e4 , 9.e4 , & 1.e5 , 2.e5 , 3.e5 , 4.e5 , 5.e5 , 6.e5 , 7.e5 , 8.e5 , 9.e5 , & 1.e6 , 2.e6 , 3.e6 , 4.e6 , 5.e6 , 6.e6 , 7.e6 , 8.e6 , 9.e6 , & 1.e7 / ) !..Lookup tables for ice number concentration (/m**3). REAL , DIMENSION ( ntb_i1 ), PARAMETER , PRIVATE :: & Nt_i = ( / 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , & 1.e1 , 2.e1 , 3.e1 , 4.e1 , 5.e1 , 6.e1 , 7.e1 , 8.e1 , 9.e1 , & 1.e2 , 2.e2 , 3.e2 , 4.e2 , 5.e2 , 6.e2 , 7.e2 , 8.e2 , 9.e2 , & 1.e3 , 2.e3 , 3.e3 , 4.e3 , 5.e3 , 6.e3 , 7.e3 , 8.e3 , 9.e3 , & 1.e4 , 2.e4 , 3.e4 , 4.e4 , 5.e4 , 6.e4 , 7.e4 , 8.e4 , 9.e4 , & 1.e5 , 2.e5 , 3.e5 , 4.e5 , 5.e5 , 6.e5 , 7.e5 , 8.e5 , 9.e5 , & 1.e6 / ) !..For snow moments conversions (from Field et al. 2005) REAL , DIMENSION ( 10 ), PARAMETER , PRIVATE :: & sa = ( / 5.065339 , - 0.062659 , - 3.032362 , 0.029469 , - 0.000285 , & 0.31255 , 0.000204 , 0.003199 , 0.0 , - 0.015952 / ) REAL , DIMENSION ( 10 ), PARAMETER , PRIVATE :: & sb = ( / 0.476221 , - 0.015896 , 0.165977 , 0.007468 , - 0.000141 , & 0.060366 , 0.000079 , 0.000594 , 0.0 , - 0.003577 / ) !..Temperatures (5 C interval 0 to -40) used in lookup tables. REAL , DIMENSION ( ntb_t ), PARAMETER , PRIVATE :: & Tc = ( /- 0.01 , - 5. , - 1 0. , - 1 5. , - 2 0. , - 2 5. , - 3 0. , - 3 5. , - 4 0. / ) !..Lookup tables for various accretion/collection terms. !.. ntb_x refers to the number of elements for rain, snow, graupel, !.. and temperature array indices.  Variables beginning with t-p/c/m/n !.. represent lookup tables.  Save compile-time memory by making !.. allocatable (2009Jun12, J. Michalakes). INTEGER , PARAMETER , PRIVATE :: R8SIZE = 8 REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:,:,:) :: & tcg_racg , tmr_racg , tcr_gacr , tmg_gacr , & tnr_racg , tnr_gacr REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:,:,:) :: & tcs_racs1 , tmr_racs1 , tcs_racs2 , tmr_racs2 , & tcr_sacr1 , tms_sacr1 , tcr_sacr2 , tms_sacr2 , & tnr_racs1 , tnr_racs2 , tnr_sacr1 , tnr_sacr2 REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:) :: & tpi_qcfz , tni_qcfz REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:,:) :: & tpi_qrfz , tpg_qrfz , tni_qrfz , tnr_qrfz REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:) :: & tps_iaus , tni_iaus , tpi_ide REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:) :: t_Efrw REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:) :: t_Efsw REAL ( KIND = R8SIZE ), ALLOCATABLE , DIMENSION (:,:,:) :: tnr_rev !..Variables holding a bunch of exponents and gamma values (cloud water, !.. cloud ice, rain, snow, then graupel). REAL , DIMENSION ( 3 ), PRIVATE :: cce , ccg REAL , PRIVATE :: ocg1 , ocg2 REAL , DIMENSION ( 7 ), PRIVATE :: cie , cig REAL , PRIVATE :: oig1 , oig2 , obmi REAL , DIMENSION ( 13 ), PRIVATE :: cre , crg REAL , PRIVATE :: ore1 , org1 , org2 , org3 , obmr REAL , DIMENSION ( 18 ), PRIVATE :: cse , csg REAL , PRIVATE :: oams , obms , ocms REAL , DIMENSION ( 12 ), PRIVATE :: cge , cgg REAL , PRIVATE :: oge1 , ogg1 , ogg2 , ogg3 , oamg , obmg , ocmg !..Declaration of precomputed constants in various rate eqns. REAL :: t1_qr_qc , t1_qr_qi , t2_qr_qi , t1_qg_qc , t1_qs_qc , t1_qs_qi REAL :: t1_qr_ev , t2_qr_ev REAL :: t1_qs_sd , t2_qs_sd , t1_qg_sd , t2_qg_sd REAL :: t1_qs_me , t2_qs_me , t1_qg_me , t2_qg_me CHARACTER * 256 :: mp_debug ! TRUDE REAL , PRIVATE :: Nt_c , TNO , am_s , rho_g , av_s , bv_s , fv_s , av_g , bv_g , av_i , Ef_si , Ef_rs , Ef_rg , Ef_ri REAL , PRIVATE :: C_cubes , C_sqrd , mu_r , t_adjust LOGICAL , PRIVATE :: Ef_rw_l , Ef_sw_l REAL , PRIVATE :: am_g !+---+ !+---+-----------------------------------------------------------------+ !..END DECLARATIONS !+---+-----------------------------------------------------------------+ !+---+ !ctrlL CONTAINS !!! The subroutine below is commented to support compiling this module outside ICAR !!!       SUBROUTINE thompson_init(mp_options) !!! !!!       IMPLICIT NONE !!! !!! ! ++ trude !!!       type(mp_options_type), intent(in) :: mp_options !!! ! -- trude !!!       INTEGER:: i, j, k, m, n !!!       LOGICAL:: micro_init !!! !..Allocate space for lookup tables (J. Michalakes 2009Jun08). !!!       micro_init = .FALSE. !!!       if (.NOT. ALLOCATED(tcg_racg) ) then !!!          ALLOCATE(tcg_racg(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!!          micro_init = .TRUE. !!!       endif !!! !!!       if (.NOT. ALLOCATED(tmr_racg)) ALLOCATE(tmr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tcr_gacr)) ALLOCATE(tcr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tmg_gacr)) ALLOCATE(tmg_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_racg)) ALLOCATE(tnr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_gacr)) ALLOCATE(tnr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r)) !!! !!!       if (.NOT. ALLOCATED(tcs_racs1)) ALLOCATE(tcs_racs1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tmr_racs1)) ALLOCATE(tmr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tcs_racs2)) ALLOCATE(tcs_racs2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tmr_racs2)) ALLOCATE(tmr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tcr_sacr1)) ALLOCATE(tcr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tms_sacr1)) ALLOCATE(tms_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tcr_sacr2)) ALLOCATE(tcr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tms_sacr2)) ALLOCATE(tms_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_racs1)) ALLOCATE(tnr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_racs2)) ALLOCATE(tnr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_sacr1)) ALLOCATE(tnr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r)) !!!       if (.NOT. ALLOCATED(tnr_sacr2)) ALLOCATE(tnr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r)) !!! !!!       if (.NOT. ALLOCATED(tpi_qcfz)) ALLOCATE(tpi_qcfz(ntb_c,45)) !!!       if (.NOT. ALLOCATED(tni_qcfz)) ALLOCATE(tni_qcfz(ntb_c,45)) !!! !!!       if (.NOT. ALLOCATED(tpi_qrfz)) ALLOCATE(tpi_qrfz(ntb_r,ntb_r1,45)) !!!       if (.NOT. ALLOCATED(tpg_qrfz)) ALLOCATE(tpg_qrfz(ntb_r,ntb_r1,45)) !!!       if (.NOT. ALLOCATED(tni_qrfz)) ALLOCATE(tni_qrfz(ntb_r,ntb_r1,45)) !!!       if (.NOT. ALLOCATED(tnr_qrfz)) ALLOCATE(tnr_qrfz(ntb_r,ntb_r1,45)) !!! !!!       if (.NOT. ALLOCATED(tps_iaus)) ALLOCATE(tps_iaus(ntb_i,ntb_i1)) !!!       if (.NOT. ALLOCATED(tni_iaus)) ALLOCATE(tni_iaus(ntb_i,ntb_i1)) !!!       if (.NOT. ALLOCATED(tpi_ide)) ALLOCATE(tpi_ide(ntb_i,ntb_i1)) !!! !!!       if (.NOT. ALLOCATED(t_Efrw)) ALLOCATE(t_Efrw(nbr,nbc)) !!!       if (.NOT. ALLOCATED(t_Efsw)) ALLOCATE(t_Efsw(nbs,nbc)) !!! !!!       if (.NOT. ALLOCATED(tnr_rev)) ALLOCATE(tnr_rev(nbr, ntb_r1, ntb_r)) !!! !!!       if (micro_init) then !!! !!!       !++ trude !!!          Nt_c = mp_options%Nt_c !!!          TNO = mp_options%TNO !!!          am_s = mp_options%am_s !!!          rho_g = mp_options%rho_g !!!          av_s = mp_options%av_s !!!          bv_s = mp_options%bv_s !!!          fv_s = mp_options%fv_s !!!          av_g = mp_options%av_g !!!          bv_g = mp_options%bv_g !!!          av_i = mp_options%av_i !!!          Ef_rs = mp_options%Ef_rs !!!          Ef_rg = mp_options%Ef_rg !!!          Ef_si = mp_options%Ef_si !!!          Ef_ri = mp_options%Ef_ri !!!          C_cubes = mp_options%C_cubes !!!          C_sqrd = mp_options%C_sqrd !!!          mu_r = mp_options%mu_r !!!          t_adjust = mp_options%t_adjust !!!          Ef_rw_l = mp_options%Ef_rw_l !!!          Ef_sw_l = mp_options%Ef_sw_l !!!          am_g = PI2*rho_g/6.0           ! trude, nb, this should can be defined in the modular section !!!       !--trude !!! !..From Martin et al. (1994), assign gamma shape parameter mu for cloud !!! !.. drops according to general dispersion characteristics (disp=~0.25 !!! !.. for Maritime and 0.45 for Continental). !!! !.. disp=SQRT((mu+2)/(mu+1) - 1) so mu varies from 15 for Maritime !!! !.. to 2 for really dirty air. !!!       mu_c = MIN(15., (1000.E6/Nt_c + 2.)) !!! !!! !..Schmidt number to one-third used numerous times. !!!       Sc3 = Sc**(1./3.) !!! !!! !..Compute min ice diam from mass, min snow/graupel mass from diam. !!!       D0i = (xm0i/am_i)**(1./bm_i) !!!       xm0s = am_s * D0s**bm_s !!!       xm0g = am_g * D0g**bm_g !!! !!! !..These constants various exponents and gamma() assoc with cloud, !!! !.. rain, snow, and graupel. !!!       cce(1) = mu_c + 1. !!!       cce(2) = bm_r + mu_c + 1. !!!       cce(3) = bm_r + mu_c + 4. !!!       ccg(1) = WGAMMA(cce(1)) !!!       ccg(2) = WGAMMA(cce(2)) !!!       ccg(3) = WGAMMA(cce(3)) !!!       ocg1 = 1./ccg(1) !!!       ocg2 = 1./ccg(2) !!! !!!       cie(1) = mu_i + 1. !!!       cie(2) = bm_i + mu_i + 1. !!!       cie(3) = bm_i + mu_i + bv_i + 1. !!!       cie(4) = mu_i + bv_i + 1. !!!       cie(5) = mu_i + 2. !!!       cie(6) = bm_i*0.5 + mu_i + bv_i + 1. !!!       cie(7) = bm_i*0.5 + mu_i + 1. !!!       cig(1) = WGAMMA(cie(1)) !!!       cig(2) = WGAMMA(cie(2)) !!!       cig(3) = WGAMMA(cie(3)) !!!       cig(4) = WGAMMA(cie(4)) !!!       cig(5) = WGAMMA(cie(5)) !!!       cig(6) = WGAMMA(cie(6)) !!!       cig(7) = WGAMMA(cie(7)) !!!       oig1 = 1./cig(1) !!!       oig2 = 1./cig(2) !!!       obmi = 1./bm_i !!! !!!       cre(1) = bm_r + 1. !!!       cre(2) = mu_r + 1. !!!       cre(3) = bm_r + mu_r + 1. !!!       cre(4) = bm_r*2. + mu_r + 1. !!!       cre(5) = mu_r + bv_r + 1. !!!       cre(6) = bm_r + mu_r + bv_r + 1. !!!       cre(7) = bm_r*0.5 + mu_r + bv_r + 1. !!!       cre(8) = bm_r + mu_r + bv_r + 3. !!!       cre(9) = mu_r + bv_r + 3. !!!       cre(10) = mu_r + 2. !!!       cre(11) = 0.5*(bv_r + 5. + 2.*mu_r) !!!       cre(12) = bm_r*0.5 + mu_r + 1. !!!       cre(13) = bm_r*2. + mu_r + bv_r + 1. !!!       do n = 1, 13 !!!          crg(n) = WGAMMA(cre(n)) !!!       enddo !!!       obmr = 1./bm_r !!!       ore1 = 1./cre(1) !!!       org1 = 1./crg(1) !!!       org2 = 1./crg(2) !!!       org3 = 1./crg(3) !!! !!!       cse(1) = bm_s + 1. !!!       cse(2) = bm_s + 2. !!!       cse(3) = bm_s*2. !!!       cse(4) = bm_s + bv_s + 1. !!!       cse(5) = bm_s*2. + bv_s + 1. !!!       cse(6) = bm_s*2. + 1. !!!       cse(7) = bm_s + mu_s + 1. !!!       cse(8) = bm_s + mu_s + 2. !!!       cse(9) = bm_s + mu_s + 3. !!!       cse(10) = bm_s + mu_s + bv_s + 1. !!!       cse(11) = bm_s*2. + mu_s + bv_s + 1. !!!       cse(12) = bm_s*2. + mu_s + 1. !!!       cse(13) = bv_s + 2. !!!       cse(14) = bm_s + bv_s !!!       cse(15) = mu_s + 1. !!!       cse(16) = 1.0 + (1.0 + bv_s)/2. !!!       cse(17) = cse(16) + mu_s + 1. !!!       cse(18) = bv_s + mu_s + 3. !!!       do n = 1, 18 !!!          csg(n) = WGAMMA(cse(n)) !!!       enddo !!!       oams = 1./am_s !!!       obms = 1./bm_s !!!       ocms = oams**obms !!! !!!       cge(1) = bm_g + 1. !!!       cge(2) = mu_g + 1. !!!       cge(3) = bm_g + mu_g + 1. !!!       cge(4) = bm_g*2. + mu_g + 1. !!!       cge(5) = bm_g*2. + mu_g + bv_g + 1. !!!       cge(6) = bm_g + mu_g + bv_g + 1. !!!       cge(7) = bm_g + mu_g + bv_g + 2. !!!       cge(8) = bm_g + mu_g + bv_g + 3. !!!       cge(9) = mu_g + bv_g + 3. !!!       cge(10) = mu_g + 2. !!!       cge(11) = 0.5*(bv_g + 5. + 2.*mu_g) !!!       cge(12) = 0.5*(bv_g + 5.) + mu_g !!!       do n = 1, 12 !!!          cgg(n) = WGAMMA(cge(n)) !!!       enddo !!!       oamg = 1./am_g !!!       obmg = 1./bm_g !!!       ocmg = oamg**obmg !!!       oge1 = 1./cge(1) !!!       ogg1 = 1./cgg(1) !!!       ogg2 = 1./cgg(2) !!!       ogg3 = 1./cgg(3) !!! !!! !+---+-----------------------------------------------------------------+ !!! !..Simplify various rate eqns the best we can now. !!! !+---+-----------------------------------------------------------------+ !!! !!! !..Rain collecting cloud water and cloud ice !!!       t1_qr_qc = PI2*.25*av_r * crg(9) !!!       t1_qr_qi = PI2*.25*av_r * crg(9) !!!       t2_qr_qi = PI2*.25*am_r*av_r * crg(8) !!! !!! !..Graupel collecting cloud water !!!       t1_qg_qc = PI2*.25*av_g * cgg(9) !!! !!! !..Snow collecting cloud water !!!       t1_qs_qc = PI2*.25*av_s !!! !!! !..Snow collecting cloud ice !!!       t1_qs_qi = PI2*.25*av_s !!! !!! !..Evaporation of rain; ignore depositional growth of rain. !!!       t1_qr_ev = 0.78 * crg(10) !!!       t2_qr_ev = 0.308*Sc3*SQRT(av_r) * crg(11) !!! !..Sublimation/depositional growth of snow !!!       t1_qs_sd = 0.86 !!!       t2_qs_sd = 0.28*Sc3*SQRT(av_s) !!! !!! !..Melting of snow !!!       t1_qs_me = PI2*4.*C_sqrd*olfus * 0.86 !!!       t2_qs_me = PI2*4.*C_sqrd*olfus * 0.28*Sc3*SQRT(av_s) !!! !!! !..Sublimation/depositional growth of graupel !!!       t1_qg_sd = 0.86 * cgg(10) !!!       t2_qg_sd = 0.28*Sc3*SQRT(av_g) * cgg(11) !!! !!! !..Melting of graupel !!!       t1_qg_me = PI2*4.*C_cube*olfus * 0.86 * cgg(10) !!!       t2_qg_me = PI2*4.*C_cube*olfus * 0.28*Sc3*SQRT(av_g) * cgg(11) !!! !!! !..Constants for helping find lookup table indexes. !!!       nic2 = NINT(ALOG10(r_c(1))) !!!       nii2 = NINT(ALOG10(r_i(1))) !!!       nii3 = NINT(ALOG10(Nt_i(1))) !!!       nir2 = NINT(ALOG10(r_r(1))) !!!       nir3 = NINT(ALOG10(N0r_exp(1))) !!!       nis2 = NINT(ALOG10(r_s(1))) !!!       nig2 = NINT(ALOG10(r_g(1))) !!!       nig3 = NINT(ALOG10(N0g_exp(1))) !!! !!! !..Create bins of cloud water (from min diameter up to 100 microns). !!!       Dc(1) = D0c*1.0d0 !!!       dtc(1) = D0c*1.0d0 !!!       do n = 2, nbc !!!          Dc(n) = Dc(n-1) + 1.0D-6 !!!          dtc(n) = (Dc(n) - Dc(n-1)) !!!       enddo !!! !!! !..Create bins of cloud ice (from min diameter up to 5x min snow size). !!!       xDx(1) = D0i*1.0d0 !!!       xDx(nbi+1) = 5.0d0*D0s !!!       do n = 2, nbi !!!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbi) & !!!                   *DLOG(xDx(nbi+1)/xDx(1)) +DLOG(xDx(1))) !!!       enddo !!!       do n = 1, nbi !!!          Di(n) = DSQRT(xDx(n)*xDx(n+1)) !!!          dti(n) = xDx(n+1) - xDx(n) !!!       enddo !!! !!! !..Create bins of rain (from min diameter up to 5 mm). !!!       xDx(1) = D0r*1.0d0 !!!       xDx(nbr+1) = 0.005d0 !!!       do n = 2, nbr !!!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) & !!!                   *DLOG(xDx(nbr+1)/xDx(1)) +DLOG(xDx(1))) !!!       enddo !!!       do n = 1, nbr !!!          Dr(n) = DSQRT(xDx(n)*xDx(n+1)) !!!          dtr(n) = xDx(n+1) - xDx(n) !!!       enddo !!! !!! !..Create bins of snow (from min diameter up to 2 cm). !!!       xDx(1) = D0s*1.0d0 !!!       xDx(nbs+1) = 0.02d0 !!!       do n = 2, nbs !!!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) & !!!                   *DLOG(xDx(nbs+1)/xDx(1)) +DLOG(xDx(1))) !!!       enddo !!!       do n = 1, nbs !!!          Ds(n) = DSQRT(xDx(n)*xDx(n+1)) !!!          dts(n) = xDx(n+1) - xDx(n) !!!       enddo !!! !!! !..Create bins of graupel (from min diameter up to 5 cm). !!!       xDx(1) = D0g*1.0d0 !!!       xDx(nbg+1) = 0.05d0 !!!       do n = 2, nbg !!!          xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) & !!!                   *DLOG(xDx(nbg+1)/xDx(1)) +DLOG(xDx(1))) !!!       enddo !!!       do n = 1, nbg !!!          Dg(n) = DSQRT(xDx(n)*xDx(n+1)) !!!          dtg(n) = xDx(n+1) - xDx(n) !!!       enddo !!! !!! !+---+-----------------------------------------------------------------+ !!! !..Create lookup tables for most costly calculations. !!! !+---+-----------------------------------------------------------------+ !!! !!!       do m = 1, ntb_r !!!          do k = 1, ntb_r1 !!!             do j = 1, ntb_g !!!                do i = 1, ntb_g1 !!!                   tcg_racg(i,j,k,m) = 0.0d0 !!!                   tmr_racg(i,j,k,m) = 0.0d0 !!!                   tcr_gacr(i,j,k,m) = 0.0d0 !!!                   tmg_gacr(i,j,k,m) = 0.0d0 !!!                   tnr_racg(i,j,k,m) = 0.0d0 !!!                   tnr_gacr(i,j,k,m) = 0.0d0 !!!                enddo !!!             enddo !!!          enddo !!!       enddo !!! !!!       do m = 1, ntb_r !!!          do k = 1, ntb_r1 !!!             do j = 1, ntb_t !!!                do i = 1, ntb_s !!!                   tcs_racs1(i,j,k,m) = 0.0d0 !!!                   tmr_racs1(i,j,k,m) = 0.0d0 !!!                   tcs_racs2(i,j,k,m) = 0.0d0 !!!                   tmr_racs2(i,j,k,m) = 0.0d0 !!!                   tcr_sacr1(i,j,k,m) = 0.0d0 !!!                   tms_sacr1(i,j,k,m) = 0.0d0 !!!                   tcr_sacr2(i,j,k,m) = 0.0d0 !!!                   tms_sacr2(i,j,k,m) = 0.0d0 !!!                   tnr_racs1(i,j,k,m) = 0.0d0 !!!                   tnr_racs2(i,j,k,m) = 0.0d0 !!!                   tnr_sacr1(i,j,k,m) = 0.0d0 !!!                   tnr_sacr2(i,j,k,m) = 0.0d0 !!!                enddo !!!             enddo !!!          enddo !!!       enddo !!! !!!       do k = 1, 45 !!!          do j = 1, ntb_r1 !!!             do i = 1, ntb_r !!!                tpi_qrfz(i,j,k) = 0.0d0 !!!                tni_qrfz(i,j,k) = 0.0d0 !!!                tpg_qrfz(i,j,k) = 0.0d0 !!!                tnr_qrfz(i,j,k) = 0.0d0 !!!             enddo !!!          enddo !!!          do i = 1, ntb_c !!!             tpi_qcfz(i,k) = 0.0d0 !!!             tni_qcfz(i,k) = 0.0d0 !!!          enddo !!!       enddo !!! !!!       do j = 1, ntb_i1 !!!          do i = 1, ntb_i !!!             tps_iaus(i,j) = 0.0d0 !!!             tni_iaus(i,j) = 0.0d0 !!!             tpi_ide(i,j) = 0.0d0 !!!          enddo !!!       enddo !!! !!!       do j = 1, nbc !!!          do i = 1, nbr !!!             t_Efrw(i,j) = 0.0 !!!          enddo !!!          do i = 1, nbs !!!             t_Efsw(i,j) = 0.0 !!!          enddo !!!       enddo !!! !!!       do k = 1, ntb_r !!!          do j = 1, ntb_r1 !!!             do i = 1, nbr !!!                tnr_rev(i,j,k) = 0.0d0 !!!             enddo !!!          enddo !!!       enddo !!! !!! !       CALL wrf_debug(150, 'CREATING MICROPHYSICS LOOKUP TABLES ... ') !!! !       WRITE (wrf_err_message, '(a, f5.2, a, f5.2, a, f5.2, a, f5.2)') & !!! !           ' using: mu_c=',mu_c,' mu_i=',mu_i,' mu_r=',mu_r,' mu_g=',mu_g !!! !       CALL wrf_debug(150, wrf_err_message) !!! !!! !..Collision efficiency between rain/snow and cloud water. !!! !       CALL wrf_debug(200, '  creating qc collision eff tables') !!!       call table_Efrw !!!       call table_Efsw !!! !!! !..Drop evaporation. !!! !     CALL wrf_debug(200, '  creating rain evap table') !!! !     call table_dropEvap !!! !!! !..Initialize various constants for computing radar reflectivity. !!! !       xam_r = am_r !!! !       xbm_r = bm_r !!! !       xmu_r = mu_r !!! !       xam_s = am_s !!! !       xbm_s = bm_s !!! !       xmu_s = mu_s !!! !       xam_g = am_g !!! !       xbm_g = bm_g !!! !       xmu_g = mu_g !!! !       call radar_init !!! !!!       if (.not. iiwarm) then !!! !!! !..Rain collecting graupel & graupel collecting rain. !!!       ! CALL wrf_debug(200, '  creating rain collecting graupel table') !!!       call qr_acr_qg !!! !!! !..Rain collecting snow & snow collecting rain. !!!       ! CALL wrf_debug(200, '  creating rain collecting snow table') !!!       call qr_acr_qs !!! !!! !..Cloud water and rain freezing (Bigg, 1953). !!!       ! CALL wrf_debug(200, '  creating freezing of water drops table') !!!       call freezeH2O !!! !!! !..Conversion of some ice mass into snow category. !!!       ! CALL wrf_debug(200, '  creating ice converting to snow table') !!!       call qi_aut_qs !!! !!!       endif !!! !!!       ! CALL wrf_debug(150, ' ... DONE microphysical lookup tables') !!! !!!       endif !!! !!!       END SUBROUTINE thompson_init !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !..This is a wrapper routine designed to transfer values from 3D to 1D. !+---+-----------------------------------------------------------------+ SUBROUTINE mp_gt_driver ( qv , qc , qr , qi , qs , qg , ni , nr , & th , pii , p , dz , dt_in , itimestep , & RAINNC , RAINNCV , & SNOWNC , SNOWNCV , & GRAUPELNC , GRAUPELNCV , SR , & ids , ide , jds , jde , kds , kde , & ! domain dims ims , ime , jms , jme , kms , kme , & ! memory dims its , ite , jts , jte , kts , kte ) ! tile dims implicit none !..Subroutine arguments INTEGER , INTENT ( IN ) :: ids , ide , jds , jde , kds , kde , & ims , ime , jms , jme , kms , kme , & its , ite , jts , jte , kts , kte REAL , DIMENSION ( ims : ime , kms : kme , jms : jme ), INTENT ( INOUT ) :: & qv , qc , qr , qi , qs , qg , ni , nr , th REAL , DIMENSION ( ims : ime , kms : kme , jms : jme ), INTENT ( IN ) :: & pii , p , dz REAL , DIMENSION ( ims : ime , jms : jme ), INTENT ( INOUT ) :: & RAINNC , RAINNCV , SR REAL , DIMENSION ( ims : ime , jms : jme ), OPTIONAL , INTENT ( INOUT ) :: & SNOWNC , SNOWNCV , GRAUPELNC , GRAUPELNCV !     REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       & !                         refl_10cm REAL , INTENT ( IN ) :: dt_in !..Local variables INTEGER , INTENT ( IN ) :: itimestep REAL , DIMENSION ( kts : kte ) :: & qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dz1d , dBZ !       REAL, DIMENSION(its:ite, jts:jte):: pcp_ra, pcp_sn, pcp_gr, pcp_ic REAL :: dt , pptrain , pptsnow , pptgraul , pptice REAL :: qc_max , qr_max , qs_max , qi_max , qg_max , ni_max , nr_max INTEGER :: i , j , k INTEGER :: imax_qc , imax_qr , imax_qi , imax_qs , imax_qg , imax_ni , imax_nr INTEGER :: jmax_qc , jmax_qr , jmax_qi , jmax_qs , jmax_qg , jmax_ni , jmax_nr INTEGER :: kmax_qc , kmax_qr , kmax_qi , kmax_qs , kmax_qg , kmax_ni , kmax_nr INTEGER :: i_start , j_start , i_end , j_end !$OMP PARALLEL DEFAULT(PRIVATE) FIRSTPRIVATE(ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,& !$OMP kms,kme,its,ite,jts,jte,kts,kte,itimestep) & !$OMP SHARED(RAINNCV,RAINNC,SNOWNCV,SNOWNC,GRAUPELNCV,GRAUPELNC,SR,th,pii,p,dz,qv,qc,& !$OMP qi,qr,qs,qg,ni,nr,dt_in,Nt_c,TNO,rho_g,av_s,bv_s,fv_s,av_g,bv_g,EF_si,Ef_ri) ! old w/pcp_xx vars !!$OMP qi,qr,qs,qg,ni,nr,pcp_ra,pcp_sn,pcp_gr,pcp_ic,dt_in) i_start = its j_start = jts i_end = MIN ( ite , ide - 1 ) j_end = MIN ( jte , jde - 1 ) !..For idealized testing by developer. !     if ( (ide-ids+1).gt.4 .and. (jde-jds+1).lt.4 .and.                & !          ids.eq.its.and.ide.eq.ite.and.jds.eq.jts.and.jde.eq.jte) then !        i_start = its + 2 !        i_end   = ite !        j_start = jts !        j_end   = jte !     endif dt = dt_in qc_max = 0. qr_max = 0. qs_max = 0. qi_max = 0. qg_max = 0 ni_max = 0. nr_max = 0. imax_qc = 0 imax_qr = 0 imax_qi = 0 imax_qs = 0 imax_qg = 0 imax_ni = 0 imax_nr = 0 jmax_qc = 0 jmax_qr = 0 jmax_qi = 0 jmax_qs = 0 jmax_qg = 0 jmax_ni = 0 jmax_nr = 0 kmax_qc = 0 kmax_qr = 0 kmax_qi = 0 kmax_qs = 0 kmax_qg = 0 kmax_ni = 0 kmax_nr = 0 !       do i = 1, 256 !          mp_debug(i:i) = char(0) !       enddo !$omp do schedule(guided) j_loop : do j = j_start , j_end i_loop : do i = i_start , i_end pptrain = 0. pptsnow = 0. pptgraul = 0. pptice = 0. !          RAINNCV(i,j) = 0. !          IF ( PRESENT (snowncv) ) THEN !             SNOWNCV(i,j) = 0. !          ENDIF !          IF ( PRESENT (graupelncv) ) THEN !             GRAUPELNCV(i,j) = 0. !          ENDIF !          SR(i,j) = 0. do k = kts , kte t1d ( k ) = th ( i , k , j ) * pii ( i , k , j ) p1d ( k ) = p ( i , k , j ) dz1d ( k ) = dz ( i , k , j ) qv1d ( k ) = qv ( i , k , j ) qc1d ( k ) = qc ( i , k , j ) qi1d ( k ) = qi ( i , k , j ) qr1d ( k ) = qr ( i , k , j ) qs1d ( k ) = qs ( i , k , j ) qg1d ( k ) = qg ( i , k , j ) ni1d ( k ) = ni ( i , k , j ) nr1d ( k ) = nr ( i , k , j ) enddo call mp_thompson ( qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dz1d , & pptrain , pptsnow , pptgraul , pptice , & kts , kte , dt , i , j ) !          pcp_ra(i,j) = pptrain !          pcp_sn(i,j) = pptsnow !          pcp_gr(i,j) = pptgraul !          pcp_ic(i,j) = pptice !          RAINNCV(i,j) = pptrain + pptsnow + pptgraul + pptice RAINNC ( i , j ) = RAINNC ( i , j ) + pptrain + pptsnow + pptgraul + pptice IF ( PRESENT ( SNOWNC ) ) SNOWNC ( i , j ) = SNOWNC ( i , j ) + pptsnow + pptice IF ( PRESENT ( SNOWNCV ) ) SNOWNCV ( i , j ) = pptsnow + pptice IF ( PRESENT ( GRAUPELNC ) ) GRAUPELNC ( i , j ) = GRAUPELNC ( i , j ) + pptgraul IF ( PRESENT ( GRAUPELNCV ) ) GRAUPELNCV ( i , j ) = pptgraul SR ( i , j ) = ( pptsnow + pptgraul + pptice ) / ( RAINNCV ( i , j ) + 1.e-12 ) do k = kts , kte qv ( i , k , j ) = qv1d ( k ) qc ( i , k , j ) = qc1d ( k ) qi ( i , k , j ) = qi1d ( k ) qr ( i , k , j ) = qr1d ( k ) qs ( i , k , j ) = qs1d ( k ) qg ( i , k , j ) = qg1d ( k ) ni ( i , k , j ) = ni1d ( k ) nr ( i , k , j ) = nr1d ( k ) th ( i , k , j ) = t1d ( k ) / pii ( i , k , j ) !             if (qc1d(k) .gt. qc_max) then !              imax_qc = i !              jmax_qc = j !              kmax_qc = k !              qc_max = qc1d(k) !             elseif (qc1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qc ', qc1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qr1d(k) .gt. qr_max) then !              imax_qr = i !              jmax_qr = j !              kmax_qr = k !              qr_max = qr1d(k) !             elseif (qr1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qr ', qr1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (nr1d(k) .gt. nr_max) then !              imax_nr = i !              jmax_nr = j !              kmax_nr = k !              nr_max = nr1d(k) !             elseif (nr1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative nr ', nr1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qs1d(k) .gt. qs_max) then !              imax_qs = i !              jmax_qs = j !              kmax_qs = k !              qs_max = qs1d(k) !             elseif (qs1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qs ', qs1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qi1d(k) .gt. qi_max) then !              imax_qi = i !              jmax_qi = j !              kmax_qi = k !              qi_max = qi1d(k) !             elseif (qi1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qi ', qi1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (qg1d(k) .gt. qg_max) then !              imax_qg = i !              jmax_qg = j !              kmax_qg = k !              qg_max = qg1d(k) !             elseif (qg1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative qg ', qg1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif !             if (ni1d(k) .gt. ni_max) then !              imax_ni = i !              jmax_ni = j !              kmax_ni = k !              ni_max = ni1d(k) !             elseif (ni1d(k) .lt. 0.0) then !              write(mp_debug,*) 'WARNING, negative ni ', ni1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) !             endif if ( qv1d ( k ) . lt . 1.E-7 ) then if ( k . lt . kte - 2 . and . k . gt . kts + 1 ) then qv ( i , k , j ) = 0.5 * ( qv ( i , k - 1 , j ) + qv ( i , k + 1 , j )) ! note, if qv(i,k+1,j) < 0 then qv(i,k,j) could still be < 0 if ( qv1d ( k ) . lt . 1.E-7 ) then qv ( i , k , j ) = 1.E-7 endif else qv ( i , k , j ) = 1.E-7 endif !              write(mp_debug,*) 'WARNING, negative qv ', qv1d(k),        & !                         ' at i,j,k=', i,j,k ! CALL wrf_debug(150, mp_debug) endif enddo !          IF ( PRESENT (diagflag) ) THEN !          if (diagflag .and. do_radar_ref == 1) then !           call calc_refl10cm (qv1d, qc1d, qr1d, nr1d, qs1d, qg1d,       & !                       t1d, p1d, dBZ, kts, kte, i, j) !           do k = kts, kte !              refl_10cm(i,k,j) = MAX(-35., dBZ(k)) !           enddo !          endif !          ENDIF enddo i_loop enddo j_loop !$omp end do !$omp end parallel ! DEBUG - GT !       write(mp_debug,'(a,7(a,e13.6,1x,a,i3,a,i3,a,i3,a,1x))') 'MP-GT:', & !          'qc: ', qc_max, '(', imax_qc, ',', jmax_qc, ',', kmax_qc, ')', & !          'qr: ', qr_max, '(', imax_qr, ',', jmax_qr, ',', kmax_qr, ')', & !          'qi: ', qi_max, '(', imax_qi, ',', jmax_qi, ',', kmax_qi, ')', & !          'qs: ', qs_max, '(', imax_qs, ',', jmax_qs, ',', kmax_qs, ')', & !          'qg: ', qg_max, '(', imax_qg, ',', jmax_qg, ',', kmax_qg, ')', & !          'ni: ', ni_max, '(', imax_ni, ',', jmax_ni, ',', kmax_ni, ')', & !          'nr: ', nr_max, '(', imax_nr, ',', jmax_nr, ',', kmax_nr, ')' ! CALL wrf_debug(150, mp_debug) ! END DEBUG - GT !       do i = 1, 256 !          mp_debug(i:i) = char(0) !       enddo END SUBROUTINE mp_gt_driver !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ !.. This subroutine computes the moisture tendencies of water vapor, !.. cloud droplets, rain, cloud ice (pristine), snow, and graupel. !.. Previously this code was based on Reisner et al (1998), but few of !.. those pieces remain.  A complete description is now found in !.. Thompson et al. (2004, 2008). !+---+-----------------------------------------------------------------+ ! subroutine mp_thompson ( qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d , dzq , & pptrain , pptsnow , pptgraul , pptice , & kts , kte , dt , ii , jj ) implicit none !..Sub arguments INTEGER , INTENT ( IN ) :: kts , kte , ii , jj REAL , DIMENSION ( kts : kte ), INTENT ( INOUT ) :: & qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , ni1d , & nr1d , t1d , p1d REAL , DIMENSION ( kts : kte ), INTENT ( IN ) :: dzq REAL , INTENT ( INOUT ) :: pptrain , pptsnow , pptgraul , pptice REAL , INTENT ( IN ) :: dt !..Local variables REAL , DIMENSION ( kts : kte ) :: tten , qvten , qcten , qiten , & qrten , qsten , qgten , niten , nrten DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prw_vcd DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prr_wau , prr_rcw , prr_rcs , & prr_rcg , prr_sml , prr_gml , & prr_rci , prv_rev , & pnr_wau , pnr_rcs , pnr_rcg , & pnr_rci , pnr_sml , pnr_gml , & pnr_rev , pnr_rcr , pnr_rfz DOUBLE PRECISION , DIMENSION ( kts : kte ) :: pri_inu , pni_inu , pri_ihm , & pni_ihm , pri_wfz , pni_wfz , & pri_rfz , pni_rfz , pri_ide , & pni_ide , pri_rci , pni_rci , & pni_sci , pni_iau DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prs_iau , prs_sci , prs_rcs , & prs_scw , prs_sde , prs_ihm , & prs_ide DOUBLE PRECISION , DIMENSION ( kts : kte ) :: prg_scw , prg_rfz , prg_gde , & prg_gcw , prg_rci , prg_rcs , & prg_rcg , prg_ihm DOUBLE PRECISION , PARAMETER :: zeroD0 = 0.0d0 REAL , DIMENSION ( kts : kte ) :: temp , pres , qv REAL , DIMENSION ( kts : kte ) :: rc , ri , rr , rs , rg , ni , nr REAL , DIMENSION ( kts : kte ) :: rho , rhof , rhof2 REAL , DIMENSION ( kts : kte ) :: qvs , qvsi , delQvs REAL , DIMENSION ( kts : kte ) :: satw , sati , ssatw , ssati REAL , DIMENSION ( kts : kte ) :: diffu , visco , vsc2 , & tcond , lvap , ocp , lvt2 DOUBLE PRECISION , DIMENSION ( kts : kte ) :: ilamr , ilamg , N0_r , N0_g REAL , DIMENSION ( kts : kte ) :: mvd_r , mvd_c REAL , DIMENSION ( kts : kte ) :: smob , smo2 , smo1 , smo0 , & smoc , smod , smoe , smof REAL , DIMENSION ( kts : kte ) :: sed_r , sed_s , sed_g , sed_i , sed_n REAL :: rgvm , delta_tp , orho , lfus2 REAL , DIMENSION ( 4 ) :: onstep DOUBLE PRECISION :: N0_exp , N0_min , lam_exp , lamc , lamr , lamg DOUBLE PRECISION :: lami , ilami REAL :: xDc , Dc_b , Dc_g , xDi , xDr , xDs , xDg , Ds_m , Dg_m DOUBLE PRECISION :: Dr_star REAL :: zeta1 , zeta , taud , tau REAL :: stoke_r , stoke_s , stoke_g , stoke_i REAL :: vti , vtr , vts , vtg REAL , DIMENSION ( kts : kte + 1 ) :: vtik , vtnik , vtrk , vtnrk , vtsk , vtgk REAL , DIMENSION ( kts : kte ) :: vts_boost REAL :: Mrat , ils1 , ils2 , t1_vts , t2_vts , t3_vts , t4_vts , C_snow REAL :: a_ , b_ , loga_ , A1 , A2 , tf REAL :: tempc , tc0 , r_mvd1 , r_mvd2 , xkrat REAL :: xnc , xri , xni , xmi , oxmi , xrc , xrr , xnr REAL :: xsat , rate_max , sump , ratio REAL :: clap , fcd , dfcd REAL :: otemp , rvs , rvs_p , rvs_pp , gamsc , alphsc , t1_evap , t1_subl REAL :: r_frac , g_frac REAL :: Ef_rw , Ef_sw , Ef_gw , Ef_rr REAL :: dtsave , odts , odt , odzq REAL :: xslw1 , ygra1 , zans1 INTEGER :: i , k , k2 , n , nn , nstep , k_0 , kbot , IT , iexfrq INTEGER , DIMENSION ( 4 ) :: ksed1 INTEGER :: nir , nis , nig , nii , nic INTEGER :: idx_tc , idx_t , idx_s , idx_g1 , idx_g , idx_r1 , idx_r , & idx_i1 , idx_i , idx_c , idx , idx_d LOGICAL :: melti , no_micro LOGICAL , DIMENSION ( kts : kte ) :: L_qc , L_qi , L_qr , L_qs , L_qg LOGICAL :: debug_flag !+---+ debug_flag = . false . !     if (ii.eq.315 .and. jj.eq.2) debug_flag = .true. no_micro = . true . dtsave = dt odt = 1. / dt odts = 1. / dtsave iexfrq = 1 !+---+-----------------------------------------------------------------+ !.. Source/sink terms.  First 2 chars: \"pr\" represents source/sink of !.. mass while \"pn\" represents source/sink of number.  Next char is one !.. of \"v\" for water vapor, \"r\" for rain, \"i\" for cloud ice, \"w\" for !.. cloud water, \"s\" for snow, and \"g\" for graupel.  Next chars !.. represent processes: \"de\" for sublimation/deposition, \"ev\" for !.. evaporation, \"fz\" for freezing, \"ml\" for melting, \"au\" for !.. autoconversion, \"nu\" for ice nucleation, \"hm\" for Hallet/Mossop !.. secondary ice production, and \"c\" for collection followed by the !.. character for the species being collected.  ALL of these terms are !.. positive (except for deposition/sublimation terms which can switch !.. signs based on super/subsaturation) and are treated as negatives !.. where necessary in the tendency equations. !+---+-----------------------------------------------------------------+ do k = kts , kte tten ( k ) = 0. qvten ( k ) = 0. qcten ( k ) = 0. qiten ( k ) = 0. qrten ( k ) = 0. qsten ( k ) = 0. qgten ( k ) = 0. niten ( k ) = 0. nrten ( k ) = 0. prw_vcd ( k ) = 0. prv_rev ( k ) = 0. prr_wau ( k ) = 0. prr_rcw ( k ) = 0. prr_rcs ( k ) = 0. prr_rcg ( k ) = 0. prr_sml ( k ) = 0. prr_gml ( k ) = 0. prr_rci ( k ) = 0. pnr_wau ( k ) = 0. pnr_rcs ( k ) = 0. pnr_rcg ( k ) = 0. pnr_rci ( k ) = 0. pnr_sml ( k ) = 0. pnr_gml ( k ) = 0. pnr_rev ( k ) = 0. pnr_rcr ( k ) = 0. pnr_rfz ( k ) = 0. pri_inu ( k ) = 0. pni_inu ( k ) = 0. pri_ihm ( k ) = 0. pni_ihm ( k ) = 0. pri_wfz ( k ) = 0. pni_wfz ( k ) = 0. pri_rfz ( k ) = 0. pni_rfz ( k ) = 0. pri_ide ( k ) = 0. pni_ide ( k ) = 0. pri_rci ( k ) = 0. pni_rci ( k ) = 0. pni_sci ( k ) = 0. pni_iau ( k ) = 0. prs_iau ( k ) = 0. prs_sci ( k ) = 0. prs_rcs ( k ) = 0. prs_scw ( k ) = 0. prs_sde ( k ) = 0. prs_ihm ( k ) = 0. prs_ide ( k ) = 0. prg_scw ( k ) = 0. prg_rfz ( k ) = 0. prg_gde ( k ) = 0. prg_gcw ( k ) = 0. prg_rci ( k ) = 0. prg_rcs ( k ) = 0. prg_rcg ( k ) = 0. prg_ihm ( k ) = 0. enddo !+---+-----------------------------------------------------------------+ !..Put column of data into local arrays. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) qv ( k ) = MAX ( 1.E-10 , qv1d ( k )) pres ( k ) = p1d ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) if ( qc1d ( k ) . gt . R1 ) then no_micro = . false . rc ( k ) = qc1d ( k ) * rho ( k ) L_qc ( k ) = . true . else qc1d ( k ) = 0.0 rc ( k ) = R1 L_qc ( k ) = . false . endif if ( qi1d ( k ) . gt . R1 ) then no_micro = . false . ri ( k ) = qi1d ( k ) * rho ( k ) ni ( k ) = MAX ( R2 , ni1d ( k ) * rho ( k )) L_qi ( k ) = . true . lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 ni ( k ) = MIN ( 25 0.D3 , cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i ) elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 ni ( k ) = cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i endif else qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif mvd_r ( k ) = 0.0 ! must be initialized or a later test can crash where qr1d(k)<=R1 if ( qr1d ( k ) . gt . R1 ) then no_micro = . false . rr ( k ) = qr1d ( k ) * rho ( k ) nr ( k ) = MAX ( R2 , nr1d ( k ) * rho ( k )) L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if ( qs1d ( k ) . gt . R1 ) then no_micro = . false . rs ( k ) = qs1d ( k ) * rho ( k ) L_qs ( k ) = . true . else qs1d ( k ) = 0.0 rs ( k ) = R1 L_qs ( k ) = . false . endif if ( qg1d ( k ) . gt . R1 ) then no_micro = . false . rg ( k ) = qg1d ( k ) * rho ( k ) L_qg ( k ) = . true . else qg1d ( k ) = 0.0 rg ( k ) = R1 L_qg ( k ) = . false . endif enddo !+---+-----------------------------------------------------------------+ !..Derive various thermodynamic variables frequently used. !.. Saturation vapor pressure (mixing ratio) over liquid/ice comes from !.. Flatau et al. 1992; enthalpy (latent heat) of vaporization from !.. Bohren & Albrecht 1998; others from Pruppacher & Klett 1978. !+---+-----------------------------------------------------------------+ do k = kts , kte tempc = temp ( k ) - 27 3.15 rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) delQvs ( k ) = MAX ( 0.0 , rslf ( pres ( k ), 27 3.15 ) - qv ( k )) if ( tempc . le . 0.0 ) then qvsi ( k ) = rsif ( pres ( k ), temp ( k )) else qvsi ( k ) = qvs ( k ) endif satw ( k ) = qv ( k ) / qvs ( k ) sati ( k ) = qv ( k ) / qvsi ( k ) ssatw ( k ) = satw ( k ) - 1. ssati ( k ) = sati ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 if ( abs ( ssati ( k )). lt . eps ) ssati ( k ) = 0.0 if ( no_micro . and . ssati ( k ). gt . 0.0 ) no_micro = . false . diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 enddo !+---+-----------------------------------------------------------------+ !..If no existing hydrometeor species and no chance to initiate ice or !.. condense cloud water, just exit quickly! !+---+-----------------------------------------------------------------+ if ( no_micro ) return !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope, and useful moments for snow. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = MIN ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate 0th moment.  Represents snow number concentration. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 5 ) * tc0 * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 5 ) * tc0 * tc0 + sb ( 9 ) * tc0 * tc0 * tc0 smo0 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1st moment.  Useful for depositional growth and melting. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) & + sa ( 4 ) * tc0 + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) + sa ( 7 ) * tc0 * tc0 & + sa ( 8 ) * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) + sb ( 4 ) * tc0 & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) & + sb ( 7 ) * tc0 * tc0 + sb ( 8 ) * tc0 & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) smo1 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bv_s+2 (th) moment.  Useful for riming. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 13 ) & + sa ( 4 ) * tc0 * cse ( 13 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 13 ) * cse ( 13 ) + sa ( 7 ) * tc0 * tc0 * cse ( 13 ) & + sa ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 13 ) + sb ( 4 ) * tc0 * cse ( 13 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 13 ) * cse ( 13 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 13 ) + sb ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) smoe ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 16 ) & + sa ( 4 ) * tc0 * cse ( 16 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 16 ) * cse ( 16 ) + sa ( 7 ) * tc0 * tc0 * cse ( 16 ) & + sa ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 16 ) + sb ( 4 ) * tc0 * cse ( 16 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 16 ) * cse ( 16 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 16 ) + sb ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) smof ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ N0_min = gonv_max do k = kte , kts , - 1 if ( temp ( k ). lt . 27 0.65 . and . L_qr ( k ) . and . mvd_r ( k ). gt . 10 0.E-6 ) then xslw1 = 4.01 + alog10 ( mvd_r ( k )) else xslw1 = 0.01 endif ygra1 = 4.31 + alog10 ( max ( 5.E-5 , rg ( k ))) zans1 = 3.1 + ( 10 0. / ( 30 0. * xslw1 * ygra1 / ( 1 0. / xslw1 + 1. + 0.25 * ygra1 ) + 3 0. + 1 0. * ygra1 )) N0_exp = 1 0. ** ( zans1 ) N0_exp = MAX ( DBLE ( gonv_min ), MIN ( N0_exp , DBLE ( gonv_max ))) N0_min = MIN ( N0_exp , N0_min ) N0_exp = N0_min lam_exp = ( N0_exp * am_g * cgg ( 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = N0_exp / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) !+---+-----------------------------------------------------------------+ !     if( debug_flag .and. k.lt.42) then !        if (k.eq.41) write(mp_debug,*) 'DEBUG-GT:   K,   zans1,      rc,        rr,         rg,        N0_g' !        if (k.eq.41) CALL wrf_debug(0, mp_debug) !        write(mp_debug, 'a, i2, 1x, f6.3, 1x, 4(1x,e13.6,1x)')         & !                   '  GT ', k, zans1, rc(k), rr(k), rg(k), N0_g(k) !        CALL wrf_debug(0, mp_debug) !     endif !+---+-----------------------------------------------------------------+ enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !+---+-----------------------------------------------------------------+ !..Compute warm-rain process terms (except evap done later). !+---+-----------------------------------------------------------------+ do k = kts , kte !..Rain self-collection follows Seifert, 1994 and drop break-up !.. follows Verlinde and Cotton, 1993.                                        RAIN2M if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r ) then !-GT      Ef_rr = 1.0 !-GT      if (mvd_r(k) .gt. 1500.0E-6) then Ef_rr = 2.0 - EXP ( 230 0.0 * ( mvd_r ( k ) - 160 0.0E-6 )) !-GT      endif pnr_rcr ( k ) = Ef_rr * 4. * nr ( k ) * rr ( k ) endif mvd_c ( k ) = D0c if (. not . L_qc ( k )) CYCLE xDc = MAX ( D0c * 1.E6 , (( rc ( k ) / ( am_r * Nt_c )) ** obmr ) * 1.E6 ) lamc = ( Nt_c * am_r * ccg ( 2 ) * ocg1 / rc ( k )) ** obmr mvd_c ( k ) = ( 3.0 + mu_c + 0.672 ) / lamc !..Autoconversion follows Berry & Reinhardt (1974) with characteristic !.. diameters correctly computed from gamma distrib of cloud droplets. if ( rc ( k ). gt . 0.01e-3 ) then Dc_g = (( ccg ( 3 ) * ocg2 ) ** obmr / lamc ) * 1.E6 Dc_b = ( xDc * xDc * xDc * Dc_g * Dc_g * Dc_g - xDc * xDc * xDc * xDc * xDc * xDc ) & ** ( 1. / 6. ) zeta1 = 0.5 * (( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 ) & + abs ( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 )) zeta = 0.027 * rc ( k ) * zeta1 taud = 0.5 * (( 0.5 * Dc_b - 7.5 ) + abs ( 0.5 * Dc_b - 7.5 )) + R1 tau = 3.72 / ( rc ( k ) * taud ) prr_wau ( k ) = zeta / tau prr_wau ( k ) = MIN ( DBLE ( rc ( k ) * odts ), prr_wau ( k )) pnr_wau ( k ) = prr_wau ( k ) / ( am_r * mu_c * D0r * D0r * D0r ) ! RAIN2M endif !..Rain collecting cloud water.  In CE, assume Dc<<Dr and vtc=~0. if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r . and . mvd_c ( k ). gt . D0c ) then lamr = 1. / ilamr ( k ) idx = 1 + INT ( nbr * DLOG ( mvd_r ( k ) / Dr ( 1 )) / DLOG ( Dr ( nbr ) / Dr ( 1 ))) idx = MIN ( idx , nbr ) Ef_rw = t_Efrw ( idx , INT ( mvd_c ( k ) * 1.E6 )) prr_rcw ( k ) = rhof ( k ) * t1_qr_qc * Ef_rw * rc ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) prr_rcw ( k ) = MIN ( DBLE ( rc ( k ) * odts ), prr_rcw ( k )) endif enddo !+---+-----------------------------------------------------------------+ !..Compute all frozen hydrometeor species' process terms. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte vts_boost ( k ) = 1.5 !..Temperature lookup table indexes. tempc = temp ( k ) - 27 3.15 idx_tc = MAX ( 1 , MIN ( NINT ( - tempc ), 45 ) ) idx_t = INT ( ( tempc - 2.5 ) / 5. ) - 1 idx_t = MAX ( 1 , - idx_t ) idx_t = MIN ( idx_t , ntb_t ) IT = MAX ( 1 , MIN ( NINT ( - tempc ), 31 ) ) !..Cloud water lookup table index. if ( rc ( k ). gt . r_c ( 1 )) then nic = NINT ( ALOG10 ( rc ( k ))) do nn = nic - 1 , nic + 1 n = nn if ( ( rc ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rc ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 141 enddo 141 continue idx_c = INT ( rc ( k ) / 1 0. ** n ) + 10 * ( n - nic2 ) - ( n - nic2 ) idx_c = MAX ( 1 , MIN ( idx_c , ntb_c )) else idx_c = 1 endif !..Cloud ice lookup table indexes. if ( ri ( k ). gt . r_i ( 1 )) then nii = NINT ( ALOG10 ( ri ( k ))) do nn = nii - 1 , nii + 1 n = nn if ( ( ri ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( ri ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 142 enddo 142 continue idx_i = INT ( ri ( k ) / 1 0. ** n ) + 10 * ( n - nii2 ) - ( n - nii2 ) idx_i = MAX ( 1 , MIN ( idx_i , ntb_i )) else idx_i = 1 endif if ( ni ( k ). gt . Nt_i ( 1 )) then nii = NINT ( ALOG10 ( ni ( k ))) do nn = nii - 1 , nii + 1 n = nn if ( ( ni ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( ni ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 143 enddo 143 continue idx_i1 = INT ( ni ( k ) / 1 0. ** n ) + 10 * ( n - nii3 ) - ( n - nii3 ) idx_i1 = MAX ( 1 , MIN ( idx_i1 , ntb_i1 )) else idx_i1 = 1 endif !..Rain lookup table indexes. if ( rr ( k ). gt . r_r ( 1 )) then nir = NINT ( ALOG10 ( rr ( k ))) do nn = nir - 1 , nir + 1 n = nn if ( ( rr ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rr ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 144 enddo 144 continue idx_r = INT ( rr ( k ) / 1 0. ** n ) + 10 * ( n - nir2 ) - ( n - nir2 ) idx_r = MAX ( 1 , MIN ( idx_r , ntb_r )) lamr = 1. / ilamr ( k ) lam_exp = lamr * ( crg ( 3 ) * org2 * org1 ) ** bm_r N0_exp = org1 * rr ( k ) / am_r * lam_exp ** cre ( 1 ) nir = NINT ( DLOG10 ( N0_exp )) do nn = nir - 1 , nir + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . & ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) goto 145 enddo 145 continue idx_r1 = INT ( N0_exp / 1 0. ** n ) + 10 * ( n - nir3 ) - ( n - nir3 ) idx_r1 = MAX ( 1 , MIN ( idx_r1 , ntb_r1 )) else idx_r = 1 idx_r1 = ntb_r1 endif !..Snow lookup table index. if ( rs ( k ). gt . r_s ( 1 )) then nis = NINT ( ALOG10 ( rs ( k ))) do nn = nis - 1 , nis + 1 n = nn if ( ( rs ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rs ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 146 enddo 146 continue idx_s = INT ( rs ( k ) / 1 0. ** n ) + 10 * ( n - nis2 ) - ( n - nis2 ) idx_s = MAX ( 1 , MIN ( idx_s , ntb_s )) else idx_s = 1 endif !..Graupel lookup table index. if ( rg ( k ). gt . r_g ( 1 )) then nig = NINT ( ALOG10 ( rg ( k ))) do nn = nig - 1 , nig + 1 n = nn if ( ( rg ( k ) / 1 0. ** nn ). ge . 1.0 . and . & ( rg ( k ) / 1 0. ** nn ). lt . 1 0.0 ) goto 147 enddo 147 continue idx_g = INT ( rg ( k ) / 1 0. ** n ) + 10 * ( n - nig2 ) - ( n - nig2 ) idx_g = MAX ( 1 , MIN ( idx_g , ntb_g )) lamg = 1. / ilamg ( k ) lam_exp = lamg * ( cgg ( 3 ) * ogg2 * ogg1 ) ** bm_g N0_exp = ogg1 * rg ( k ) / am_g * lam_exp ** cge ( 1 ) nig = NINT ( DLOG10 ( N0_exp )) do nn = nig - 1 , nig + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . & ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) goto 148 enddo 148 continue idx_g1 = INT ( N0_exp / 1 0. ** n ) + 10 * ( n - nig3 ) - ( n - nig3 ) idx_g1 = MAX ( 1 , MIN ( idx_g1 , ntb_g1 )) else idx_g = 1 idx_g1 = ntb_g1 endif !..Deposition/sublimation prefactor (from Srivastava & Coen 1992). otemp = 1. / temp ( k ) rvs = rho ( k ) * qvsi ( k ) rvs_p = rvs * otemp * ( lsub * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lsub * otemp * oRv - 1. ) & * otemp * ( lsub * otemp * oRv - 1. ) & + ( - 2. * lsub * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lsub * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = MAX ( 1.E-9 , alphsc ) xsat = ssati ( k ) if ( abs ( xsat ). lt . 1.E-9 ) xsat = 0. t1_subl = 4. * PI2 * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) !..Snow collecting cloud water.  In CE, assume Dc<<Ds and vtc=~0. if ( L_qc ( k ) . and . mvd_c ( k ). gt . D0c ) then xDs = 0.0 if ( L_qs ( k )) xDs = smoc ( k ) / smob ( k ) if ( xDs . gt . D0s ) then idx = 1 + INT ( nbs * DLOG ( xDs / Ds ( 1 )) / DLOG ( Ds ( nbs ) / Ds ( 1 ))) idx = MIN ( idx , nbs ) Ef_sw = t_Efsw ( idx , INT ( mvd_c ( k ) * 1.E6 )) prs_scw ( k ) = rhof ( k ) * t1_qs_qc * Ef_sw * rc ( k ) * smoe ( k ) endif !..Graupel collecting cloud water.  In CE, assume Dc<<Dg and vtc=~0. if ( rg ( k ). ge . r_g ( 1 ) . and . mvd_c ( k ). gt . D0c ) then xDg = ( bm_g + mu_g + 1. ) * ilamg ( k ) vtg = rhof ( k ) * av_g * cgg ( 6 ) * ogg3 * ilamg ( k ) ** bv_g stoke_g = mvd_c ( k ) * mvd_c ( k ) * vtg * rho_w / ( 9. * visco ( k ) * xDg ) if ( xDg . gt . D0g ) then if ( stoke_g . ge . 0.4 . and . stoke_g . le . 1 0. ) then Ef_gw = 0.55 * ALOG10 ( 2.51 * stoke_g ) elseif ( stoke_g . lt . 0.4 ) then Ef_gw = 0.0 elseif ( stoke_g . gt . 10 ) then Ef_gw = 0.77 endif prg_gcw ( k ) = rhof ( k ) * t1_qg_qc * Ef_gw * rc ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 ) endif endif endif !..Rain collecting snow.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rr ( k ). ge . r_r ( 1 )) then if ( rs ( k ). ge . r_s ( 1 )) then if ( temp ( k ). lt . T_0 ) then prr_rcs ( k ) = - ( tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r )) prs_rcs ( k ) = tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prg_rcs ( k ) = tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prr_rcs ( k ) = MAX ( DBLE ( - rr ( k ) * odts ), prr_rcs ( k )) prs_rcs ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_rcs ( k )) prg_rcs ( k ) = MIN ( DBLE (( rr ( k ) + rs ( k )) * odts ), prg_rcs ( k )) pnr_rcs ( k ) = tnr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & ! RAIN2M + tnr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) else prs_rcs ( k ) = - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) prs_rcs ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_rcs ( k )) prr_rcs ( k ) = - prs_rcs ( k ) pnr_rcs ( k ) = tnr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & ! RAIN2M + tnr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) endif pnr_rcs ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rcs ( k )) endif !..Rain collecting graupel.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rg ( k ). ge . r_g ( 1 )) then if ( temp ( k ). lt . T_0 ) then prg_rcg ( k ) = tmr_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) & + tcr_gacr ( idx_g1 , idx_g , idx_r1 , idx_r ) prg_rcg ( k ) = MIN ( DBLE ( rr ( k ) * odts ), prg_rcg ( k )) prr_rcg ( k ) = - prg_rcg ( k ) pnr_rcg ( k ) = tnr_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) & ! RAIN2M + tnr_gacr ( idx_g1 , idx_g , idx_r1 , idx_r ) pnr_rcg ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rcg ( k )) else prr_rcg ( k ) = tcg_racg ( idx_g1 , idx_g , idx_r1 , idx_r ) prr_rcg ( k ) = MIN ( DBLE ( rg ( k ) * odts ), prr_rcg ( k )) prg_rcg ( k ) = - prr_rcg ( k ) endif endif endif !+---+-----------------------------------------------------------------+ !..Next IF block handles only those processes below 0C. !+---+-----------------------------------------------------------------+ if ( temp ( k ). lt . T_0 ) then vts_boost ( k ) = 1.0 rate_max = ( qv ( k ) - qvsi ( k )) * rho ( k ) * odts * 0.999 !..Freezing of water drops into graupel/cloud ice (Bigg 1953). if ( rr ( k ). gt . r_r ( 1 )) then prg_rfz ( k ) = tpg_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pri_rfz ( k ) = tpi_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pni_rfz ( k ) = tni_qrfz ( idx_r , idx_r1 , idx_tc ) * odts pnr_rfz ( k ) = tnr_qrfz ( idx_r , idx_r1 , idx_tc ) * odts ! RAIN2M pnr_rfz ( k ) = MIN ( DBLE ( nr ( k ) * odts ), pnr_rfz ( k )) elseif ( rr ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_rfz ( k ) = rr ( k ) * odts pnr_rfz ( k ) = nr ( k ) * odts ! RAIN2M pni_rfz ( k ) = pnr_rfz ( k ) endif if ( rc ( k ). gt . r_c ( 1 )) then pri_wfz ( k ) = tpi_qcfz ( idx_c , idx_tc ) * odts pri_wfz ( k ) = MIN ( DBLE ( rc ( k ) * odts ), pri_wfz ( k )) pni_wfz ( k ) = tni_qcfz ( idx_c , idx_tc ) * odts pni_wfz ( k ) = MIN ( DBLE ( Nt_c * odts ), pri_wfz ( k ) / ( 2. * xm0i ), & pni_wfz ( k )) elseif ( rc ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_wfz ( k ) = rc ( k ) * odts pni_wfz ( k ) = MIN ( DBLE ( Nt_c * odts ), pri_wfz ( k ) / ( 2. * xm0i ), & pni_wfz ( k )) endif !..Nucleate ice from deposition & condensation freezing (Cooper 1986) !.. but only if water sat and T<-12C or 25%+ ice supersaturated. if ( ( ssati ( k ). ge . 0.25 ) . or . ( ssatw ( k ). gt . eps & . and . temp ( k ). lt . 26 1.15 ) ) then xnc = MIN ( 25 0.E3 , TNO * EXP ( ATO * ( T_0 - temp ( k )))) xni = ni ( k ) + ( pni_rfz ( k ) + pni_wfz ( k )) * dtsave pni_inu ( k ) = 0.5 * ( xnc - xni + abs ( xnc - xni )) * odts pri_inu ( k ) = MIN ( DBLE ( rate_max ), xm0i * pni_inu ( k )) pni_inu ( k ) = pri_inu ( k ) / xm0i endif !..Deposition/sublimation of cloud ice (Srivastava & Coen 1992). if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = MAX ( DBLE ( D0i ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi pri_ide ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * oig1 * cig ( 5 ) * ni ( k ) * ilami if ( pri_ide ( k ) . lt . 0.0 ) then pri_ide ( k ) = MAX ( DBLE ( - ri ( k ) * odts ), pri_ide ( k ), DBLE ( rate_max )) pni_ide ( k ) = pri_ide ( k ) * oxmi pni_ide ( k ) = MAX ( DBLE ( - ni ( k ) * odts ), pni_ide ( k )) else pri_ide ( k ) = MIN ( pri_ide ( k ), DBLE ( rate_max )) prs_ide ( k ) = ( 1.0D0 - tpi_ide ( idx_i , idx_i1 )) * pri_ide ( k ) pri_ide ( k ) = tpi_ide ( idx_i , idx_i1 ) * pri_ide ( k ) endif !..Some cloud ice needs to move into the snow category.  Use lookup !.. table that resulted from explicit bin representation of distrib. if ( ( idx_i . eq . ntb_i ) . or . ( xDi . gt . 5.0 * D0s ) ) then prs_iau ( k ) = ri ( k ) * . 99 * odts pni_iau ( k ) = ni ( k ) * . 95 * odts elseif ( xDi . lt . 0.1 * D0s ) then prs_iau ( k ) = 0. pni_iau ( k ) = 0. else prs_iau ( k ) = tps_iaus ( idx_i , idx_i1 ) * odts prs_iau ( k ) = MIN ( DBLE ( ri ( k ) * . 99 * odts ), prs_iau ( k )) pni_iau ( k ) = tni_iaus ( idx_i , idx_i1 ) * odts pni_iau ( k ) = MIN ( DBLE ( ni ( k ) * . 95 * odts ), pni_iau ( k )) endif endif !..Deposition/sublimation of snow/graupel follows Srivastava & Coen !.. (1992). if ( L_qs ( k )) then !++ trude, use different c_cube for snow: c_cubes !           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.) !           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube)) C_snow = C_sqrd + ( tempc + 1 5. ) * ( C_cubes - C_sqrd ) / ( - 3 0. + 1 5. ) C_snow = MAX ( C_sqrd , MIN ( C_snow , C_cubes )) !! -- trude prs_sde ( k ) = C_snow * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) if ( prs_sde ( k ). lt . 0. ) then prs_sde ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_sde ( k ), DBLE ( rate_max )) else prs_sde ( k ) = MIN ( prs_sde ( k ), DBLE ( rate_max )) endif endif if ( L_qg ( k ) . and . ssati ( k ). lt . - eps ) then prg_gde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * N0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 )) if ( prg_gde ( k ). lt . 0. ) then prg_gde ( k ) = MAX ( DBLE ( - rg ( k ) * odts ), prg_gde ( k ), DBLE ( rate_max )) else prg_gde ( k ) = MIN ( prg_gde ( k ), DBLE ( rate_max )) endif endif !..Snow collecting cloud ice.  In CE, assume Di<<Ds and vti=~0. if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = MAX ( DBLE ( D0i ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi if ( rs ( k ). ge . r_s ( 1 )) then prs_sci ( k ) = t1_qs_qi * rhof ( k ) * Ef_si * ri ( k ) * smoe ( k ) pni_sci ( k ) = prs_sci ( k ) * oxmi endif !..Rain collecting cloud ice.  In CE, assume Di<<Dr and vti=~0. if ( rr ( k ). ge . r_r ( 1 ) . and . mvd_r ( k ). gt . 4. * xDi ) then lamr = 1. / ilamr ( k ) pri_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ri ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) pnr_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & ! RAIN2M * (( lamr + fv_r ) ** ( - cre ( 9 ))) pni_rci ( k ) = pri_rci ( k ) * oxmi prr_rci ( k ) = rhof ( k ) * t2_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 8 ))) prr_rci ( k ) = MIN ( DBLE ( rr ( k ) * odts ), prr_rci ( k )) prg_rci ( k ) = pri_rci ( k ) + prr_rci ( k ) endif endif !..Ice multiplication from rime-splinters (Hallet & Mossop 1974). if ( prg_gcw ( k ). gt . eps . and . tempc . gt . - 8.0 ) then tf = 0. if ( tempc . ge . - 5.0 . and . tempc . lt . - 3.0 ) then tf = 0.5 * ( - 3.0 - tempc ) elseif ( tempc . gt . - 8.0 . and . tempc . lt . - 5.0 ) then tf = 0.33333333 * ( 8.0 + tempc ) endif pni_ihm ( k ) = 3.5E8 * tf * prg_gcw ( k ) pri_ihm ( k ) = xm0i * pni_ihm ( k ) prs_ihm ( k ) = prs_scw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) prg_ihm ( k ) = prg_gcw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) endif !..A portion of rimed snow converts to graupel but some remains snow. !.. Interp from 5 to 75% as riming factor increases from 5.0 to 30.0 !.. 0.028 came from (.75-.05)/(30.-5.).  This remains ad-hoc and should !.. be revisited. if ( prs_scw ( k ). gt . 5.0 * prs_sde ( k ) . and . & prs_sde ( k ). gt . eps ) then r_frac = MIN ( 3 0.0D0 , prs_scw ( k ) / prs_sde ( k )) g_frac = MIN ( 0.75 , 0.05 + ( r_frac - 5. ) * . 028 ) vts_boost ( k ) = MIN ( 1.5 , 1.1 + ( r_frac - 5. ) * . 016 ) prg_scw ( k ) = g_frac * prs_scw ( k ) prs_scw ( k ) = ( 1. - g_frac ) * prs_scw ( k ) endif else !..Melt snow and graupel and enhance from collisions with liquid. !.. We also need to sublimate snow and graupel if subsaturated. if ( L_qs ( k )) then prr_sml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * ( t1_qs_me * smo1 ( k ) + t2_qs_me * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) prr_sml ( k ) = prr_sml ( k ) + 421 8. * olfus * tempc & * ( prr_rcs ( k ) + prs_scw ( k )) prr_sml ( k ) = MIN ( DBLE ( rs ( k ) * odts ), MAX ( 0.D0 , prr_sml ( k ))) pnr_sml ( k ) = smo0 ( k ) / rs ( k ) * prr_sml ( k ) * 1 0.0 ** ( - 0.75 * tempc ) ! RAIN2M pnr_sml ( k ) = MIN ( DBLE ( smo0 ( k ) * odts ), pnr_sml ( k )) if ( tempc . gt . 3.5 . or . rs ( k ). lt . 0.005E-3 ) pnr_sml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then !++ trude, use different c_cube for snow: c_cubes !           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.) !           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube)) !            prs_sde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs & prs_sde ( k ) = C_cubes * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) ! -- trude prs_sde ( k ) = MAX ( DBLE ( - rs ( k ) * odts ), prs_sde ( k )) endif endif if ( L_qg ( k )) then prr_gml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * N0_g ( k ) * ( t1_qg_me * ilamg ( k ) ** cge ( 10 ) & + t2_qg_me * rhof2 ( k ) * vsc2 ( k ) * ilamg ( k ) ** cge ( 11 )) !-GT       prr_gml(k) = prr_gml(k) + 4218.*olfus*tempc & !-GT                               * (prr_rcg(k)+prg_gcw(k)) prr_gml ( k ) = MIN ( DBLE ( rg ( k ) * odts ), MAX ( 0.D0 , prr_gml ( k ))) pnr_gml ( k ) = N0_g ( k ) * cgg ( 2 ) * ilamg ( k ) ** cge ( 2 ) / rg ( k ) & ! RAIN2M * prr_gml ( k ) * 1 0.0 ** ( - 1.5 * tempc ) if ( tempc . gt . 7.5 . or . rg ( k ). lt . 0.005E-3 ) pnr_gml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then prg_gde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * N0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 )) prg_gde ( k ) = MAX ( DBLE ( - rg ( k ) * odts ), prg_gde ( k )) endif endif !.. This change will be required if users run adaptive time step that !.. results in delta-t that is generally too long to allow cloud water !.. collection by snow/graupel above melting temperature. !.. Credit to Bjorn-Egil Nygaard for discovering. if ( dt . gt . 12 0. ) then prr_rcw ( k ) = prr_rcw ( k ) + prs_scw ( k ) + prg_gcw ( k ) prs_scw ( k ) = 0. prg_gcw ( k ) = 0. endif endif enddo endif !+---+-----------------------------------------------------------------+ !..Ensure we do not deplete more hydrometeor species than exists. !+---+-----------------------------------------------------------------+ do k = kts , kte !..If ice supersaturated, ensure sum of depos growth terms does not !.. deplete more vapor than possibly exists.  If subsaturated, limit !.. sum of sublimation terms such that vapor does not reproduce ice !.. supersat again. sump = pri_inu ( k ) + pri_ide ( k ) + prs_ide ( k ) & + prs_sde ( k ) + prg_gde ( k ) rate_max = ( qv ( k ) - qvsi ( k )) * odts * 0.999 if ( ( sump . gt . eps . and . sump . gt . rate_max ) . or . & ( sump . lt . - eps . and . sump . lt . rate_max ) ) then ratio = rate_max / sump pri_inu ( k ) = pri_inu ( k ) * ratio pri_ide ( k ) = pri_ide ( k ) * ratio pni_ide ( k ) = pni_ide ( k ) * ratio prs_ide ( k ) = prs_ide ( k ) * ratio prs_sde ( k ) = prs_sde ( k ) * ratio prg_gde ( k ) = prg_gde ( k ) * ratio endif !..Cloud water conservation. sump = - prr_wau ( k ) - pri_wfz ( k ) - prr_rcw ( k ) & - prs_scw ( k ) - prg_scw ( k ) - prg_gcw ( k ) rate_max = - rc ( k ) * odts if ( sump . lt . rate_max . and . L_qc ( k )) then ratio = rate_max / sump prr_wau ( k ) = prr_wau ( k ) * ratio pri_wfz ( k ) = pri_wfz ( k ) * ratio prr_rcw ( k ) = prr_rcw ( k ) * ratio prs_scw ( k ) = prs_scw ( k ) * ratio prg_scw ( k ) = prg_scw ( k ) * ratio prg_gcw ( k ) = prg_gcw ( k ) * ratio endif !..Cloud ice conservation. sump = pri_ide ( k ) - prs_iau ( k ) - prs_sci ( k ) & - pri_rci ( k ) rate_max = - ri ( k ) * odts if ( sump . lt . rate_max . and . L_qi ( k )) then ratio = rate_max / sump pri_ide ( k ) = pri_ide ( k ) * ratio prs_iau ( k ) = prs_iau ( k ) * ratio prs_sci ( k ) = prs_sci ( k ) * ratio pri_rci ( k ) = pri_rci ( k ) * ratio endif !..Rain conservation. sump = - prg_rfz ( k ) - pri_rfz ( k ) - prr_rci ( k ) & + prr_rcs ( k ) + prr_rcg ( k ) rate_max = - rr ( k ) * odts if ( sump . lt . rate_max . and . L_qr ( k )) then ratio = rate_max / sump prg_rfz ( k ) = prg_rfz ( k ) * ratio pri_rfz ( k ) = pri_rfz ( k ) * ratio prr_rci ( k ) = prr_rci ( k ) * ratio prr_rcs ( k ) = prr_rcs ( k ) * ratio prr_rcg ( k ) = prr_rcg ( k ) * ratio endif !..Snow conservation. sump = prs_sde ( k ) - prs_ihm ( k ) - prr_sml ( k ) & + prs_rcs ( k ) rate_max = - rs ( k ) * odts if ( sump . lt . rate_max . and . L_qs ( k )) then ratio = rate_max / sump prs_sde ( k ) = prs_sde ( k ) * ratio prs_ihm ( k ) = prs_ihm ( k ) * ratio prr_sml ( k ) = prr_sml ( k ) * ratio prs_rcs ( k ) = prs_rcs ( k ) * ratio endif !..Graupel conservation. sump = prg_gde ( k ) - prg_ihm ( k ) - prr_gml ( k ) & + prg_rcg ( k ) rate_max = - rg ( k ) * odts if ( sump . lt . rate_max . and . L_qg ( k )) then ratio = rate_max / sump prg_gde ( k ) = prg_gde ( k ) * ratio prg_ihm ( k ) = prg_ihm ( k ) * ratio prr_gml ( k ) = prr_gml ( k ) * ratio prg_rcg ( k ) = prg_rcg ( k ) * ratio endif !..Re-enforce proper mass conservation for subsequent elements in case !.. any of the above terms were altered.  Thanks P. Blossey. 2009Sep28 pri_ihm ( k ) = prs_ihm ( k ) + prg_ihm ( k ) ratio = MIN ( ABS ( prr_rcg ( k )), ABS ( prg_rcg ( k )) ) prr_rcg ( k ) = ratio * SIGN ( 1.0 , SNGL ( prr_rcg ( k ))) prg_rcg ( k ) = - prr_rcg ( k ) if ( temp ( k ). gt . T_0 ) then ratio = MIN ( ABS ( prr_rcs ( k )), ABS ( prs_rcs ( k )) ) prr_rcs ( k ) = ratio * SIGN ( 1.0 , SNGL ( prr_rcs ( k ))) prs_rcs ( k ) = - prr_rcs ( k ) endif enddo !+---+-----------------------------------------------------------------+ !..Calculate tendencies of all species but constrain the number of ice !.. to reasonable values. !+---+-----------------------------------------------------------------+ do k = kts , kte orho = 1. / rho ( k ) lfus2 = lsub - lvap ( k ) !..Water vapor tendency qvten ( k ) = qvten ( k ) + ( - pri_inu ( k ) - pri_ide ( k ) & - prs_ide ( k ) - prs_sde ( k ) - prg_gde ( k )) & * orho !..Cloud water tendency qcten ( k ) = qcten ( k ) + ( - prr_wau ( k ) - pri_wfz ( k ) & - prr_rcw ( k ) - prs_scw ( k ) - prg_scw ( k ) & - prg_gcw ( k )) & * orho !..Cloud ice mixing ratio tendency qiten ( k ) = qiten ( k ) + ( pri_inu ( k ) + pri_ihm ( k ) & + pri_wfz ( k ) + pri_rfz ( k ) + pri_ide ( k ) & - prs_iau ( k ) - prs_sci ( k ) - pri_rci ( k )) & * orho !..Cloud ice number tendency. niten ( k ) = niten ( k ) + ( pni_inu ( k ) + pni_ihm ( k ) & + pni_wfz ( k ) + pni_rfz ( k ) + pni_ide ( k ) & - pni_iau ( k ) - pni_sci ( k ) - pni_rci ( k )) & * orho !..Cloud ice mass/number balance; keep mass-wt mean size between !.. 20 and 300 microns.  Also no more than 250 xtals per liter. xri = MAX ( R1 ,( qi1d ( k ) + qiten ( k ) * dtsave ) * rho ( k )) xni = MAX ( R2 ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xri . gt . R1 ) then lami = ( am_i * cig ( 2 ) * oig1 * xni / xri ) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 xni = MIN ( 25 0.D3 , cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i ) niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 xni = cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho endif else niten ( k ) = - ni1d ( k ) * odts endif xni = MAX ( 0. ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xni . gt . 25 0.E3 ) & niten ( k ) = ( 25 0.E3 - ni1d ( k ) * rho ( k )) * odts * orho !..Rain tendency qrten ( k ) = qrten ( k ) + ( prr_wau ( k ) + prr_rcw ( k ) & + prr_sml ( k ) + prr_gml ( k ) + prr_rcs ( k ) & + prr_rcg ( k ) - prg_rfz ( k ) & - pri_rfz ( k ) - prr_rci ( k )) & * orho !..Rain number tendency nrten ( k ) = nrten ( k ) + ( pnr_wau ( k ) + pnr_sml ( k ) + pnr_gml ( k ) & - ( pnr_rfz ( k ) + pnr_rcr ( k ) + pnr_rcg ( k ) & + pnr_rcs ( k ) + pnr_rci ( k )) ) & * orho !..Rain mass/number balance; keep median volume diameter between !.. 37 microns (D0r*0.75) and 2.5 mm. xrr = MAX ( R1 ,( qr1d ( k ) + qrten ( k ) * dtsave ) * rho ( k )) xnr = MAX ( R2 ,( nr1d ( k ) + nrten ( k ) * dtsave ) * rho ( k )) if ( xrr . gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * xnr / xrr ) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho endif else qrten ( k ) = - qr1d ( k ) * odts nrten ( k ) = - nr1d ( k ) * odts endif !..Snow tendency qsten ( k ) = qsten ( k ) + ( prs_iau ( k ) + prs_sde ( k ) & + prs_sci ( k ) + prs_scw ( k ) + prs_rcs ( k ) & + prs_ide ( k ) - prs_ihm ( k ) - prr_sml ( k )) & * orho !..Graupel tendency qgten ( k ) = qgten ( k ) + ( prg_scw ( k ) + prg_rfz ( k ) & + prg_gde ( k ) + prg_rcg ( k ) + prg_gcw ( k ) & + prg_rci ( k ) + prg_rcs ( k ) - prg_ihm ( k ) & - prr_gml ( k )) & * orho !..Temperature tendency if ( temp ( k ). lt . T_0 ) then tten ( k ) = tten ( k ) & + ( lsub * ocp ( k ) * ( pri_inu ( k ) + pri_ide ( k ) & + prs_ide ( k ) + prs_sde ( k ) & + prg_gde ( k )) & + lfus2 * ocp ( k ) * ( pri_wfz ( k ) + pri_rfz ( k ) & + prg_rfz ( k ) + prs_scw ( k ) & + prg_scw ( k ) + prg_gcw ( k ) & + prg_rcs ( k ) + prs_rcs ( k ) & + prr_rci ( k ) + prg_rcg ( k )) & ) * orho * ( 1 - IFDRY ) else tten ( k ) = tten ( k ) & + ( lfus * ocp ( k ) * ( - prr_sml ( k ) - prr_gml ( k ) & - prr_rcg ( k ) - prr_rcs ( k )) & + lsub * ocp ( k ) * ( prs_sde ( k ) + prg_gde ( k )) & ) * orho * ( 1 - IFDRY ) endif enddo !+---+-----------------------------------------------------------------+ !..Update variables for TAU+1 before condensation & sedimention. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) + DT * tten ( k ) otemp = 1. / temp ( k ) tempc = temp ( k ) - 27 3.15 qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) lvt2 ( k ) = lvap ( k ) * lvap ( k ) * ocp ( k ) * oRv * otemp * otemp if (( qc1d ( k ) + qcten ( k ) * DT ) . gt . R1 ) then rc ( k ) = ( qc1d ( k ) + qcten ( k ) * DT ) * rho ( k ) L_qc ( k ) = . true . else rc ( k ) = R1 L_qc ( k ) = . false . endif if (( qi1d ( k ) + qiten ( k ) * DT ) . gt . R1 ) then ri ( k ) = ( qi1d ( k ) + qiten ( k ) * DT ) * rho ( k ) ni ( k ) = MAX ( R2 , ( ni1d ( k ) + niten ( k ) * DT ) * rho ( k )) L_qi ( k ) = . true . else ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif if (( qr1d ( k ) + qrten ( k ) * DT ) . gt . R1 ) then rr ( k ) = ( qr1d ( k ) + qrten ( k ) * DT ) * rho ( k ) nr ( k ) = MAX ( R2 , ( nr1d ( k ) + nrten ( k ) * DT ) * rho ( k )) L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if (( qs1d ( k ) + qsten ( k ) * DT ) . gt . R1 ) then rs ( k ) = ( qs1d ( k ) + qsten ( k ) * DT ) * rho ( k ) L_qs ( k ) = . true . else rs ( k ) = R1 L_qs ( k ) = . false . endif if (( qg1d ( k ) + qgten ( k ) * DT ) . gt . R1 ) then rg ( k ) = ( qg1d ( k ) + qgten ( k ) * DT ) * rho ( k ) L_qg ( k ) = . true . else rg ( k ) = R1 L_qg ( k ) = . false . endif enddo !+---+-----------------------------------------------------------------+ !..With tendency-updated mixing ratios, recalculate snow moments and !.. intercepts/slopes of graupel and rain. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = MIN ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+bv_s (th) moment.  Useful for sedimentation. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 14 ) & + sa ( 4 ) * tc0 * cse ( 14 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 14 ) * cse ( 14 ) + sa ( 7 ) * tc0 * tc0 * cse ( 14 ) & + sa ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 14 ) + sb ( 4 ) * tc0 * cse ( 14 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 14 ) * cse ( 14 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 14 ) + sb ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) smod ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ N0_min = gonv_max do k = kte , kts , - 1 if ( temp ( k ). lt . 27 0.65 . and . L_qr ( k ) . and . mvd_r ( k ). gt . 10 0.E-6 ) then xslw1 = 4.01 + alog10 ( mvd_r ( k )) else xslw1 = 0.01 endif ygra1 = 4.31 + alog10 ( max ( 5.E-5 , rg ( k ))) zans1 = 3.1 + ( 10 0. / ( 30 0. * xslw1 * ygra1 / ( 1 0. / xslw1 + 1. + 0.25 * ygra1 ) + 3 0. + 1 0. * ygra1 )) N0_exp = 1 0. ** ( zans1 ) N0_exp = MAX ( DBLE ( gonv_min ), MIN ( N0_exp , DBLE ( gonv_max ))) N0_min = MIN ( N0_exp , N0_min ) N0_exp = N0_min lam_exp = ( N0_exp * am_g * cgg ( 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = N0_exp / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !+---+-----------------------------------------------------------------+ !..Cloud water condensation and evaporation.  Newly formulated using !.. Newton-Raphson iterations (3 should suffice) as provided by B. Hall. !+---+-----------------------------------------------------------------+ do k = kts , kte if ( ( ssatw ( k ). gt . eps ) . or . ( ssatw ( k ). lt . - eps . and . & L_qc ( k )) ) then clap = ( qv ( k ) - qvs ( k )) / ( 1. + lvt2 ( k ) * qvs ( k )) do n = 1 , 3 fcd = qvs ( k ) * EXP ( lvt2 ( k ) * clap ) - qv ( k ) + clap dfcd = qvs ( k ) * lvt2 ( k ) * EXP ( lvt2 ( k ) * clap ) + 1. clap = clap - fcd / dfcd enddo xrc = rc ( k ) + clap if ( xrc . gt . 0.0 ) then prw_vcd ( k ) = clap * odt else prw_vcd ( k ) = - rc ( k ) / rho ( k ) * odts endif qcten ( k ) = qcten ( k ) + prw_vcd ( k ) qvten ( k ) = qvten ( k ) - prw_vcd ( k ) tten ( k ) = tten ( k ) + lvap ( k ) * ocp ( k ) * prw_vcd ( k ) * ( 1 - IFDRY ) rc ( k ) = MAX ( R1 , ( qc1d ( k ) + DT * qcten ( k )) * rho ( k )) qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) qvs ( k ) = rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. endif enddo !+---+-----------------------------------------------------------------+ !.. If still subsaturated, allow rain to evaporate, following !.. Srivastava & Coen (1992). !+---+-----------------------------------------------------------------+ do k = kts , kte if ( ( ssatw ( k ). lt . - eps ) . and . L_qr ( k ) & . and . (. not .( prw_vcd ( k ). gt . 0. )) ) then tempc = temp ( k ) - 27 3.15 otemp = 1. / temp ( k ) rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rhof2 ( k ) = SQRT ( rhof ( k )) diffu ( k ) = 2.11E-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0E-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2E-5 * tempc * tempc ) * 1.0E-5 endif vsc2 ( k ) = SQRT ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) rvs = rho ( k ) * qvs ( k ) rvs_p = rvs * otemp * ( lvap ( k ) * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lvap ( k ) * otemp * oRv - 1. ) & * otemp * ( lvap ( k ) * otemp * oRv - 1. ) & + ( - 2. * lvap ( k ) * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lvap ( k ) * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = MAX ( 1.E-9 , alphsc ) xsat = MIN ( - 1.E-9 , ssatw ( k )) t1_evap = 2. * PI2 * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) lamr = 1. / ilamr ( k ) !..Rapidly eliminate near zero values when low humidity (<95%) if ( qv ( k ) / qvs ( k ) . lt . 0.95 . AND . rr ( k ) / rho ( k ). le . 1.E-8 ) then prv_rev ( k ) = rr ( k ) / rho ( k ) * odts else prv_rev ( k ) = t1_evap * diffu ( k ) * ( - ssatw ( k )) * N0_r ( k ) * rvs & * ( t1_qr_ev * ilamr ( k ) ** cre ( 10 ) & + t2_qr_ev * vsc2 ( k ) * rhof2 ( k ) * (( lamr + 0.5 * fv_r ) ** ( - cre ( 11 )))) rate_max = MIN (( rr ( k ) / rho ( k ) * odts ), ( qvs ( k ) - qv ( k )) * odts ) prv_rev ( k ) = MIN ( DBLE ( rate_max ), prv_rev ( k ) / rho ( k )) endif pnr_rev ( k ) = MIN ( DBLE ( nr ( k ) * 0.99 / rho ( k ) * odts ), & ! RAIN2M prv_rev ( k ) * nr ( k ) / rr ( k )) qrten ( k ) = qrten ( k ) - prv_rev ( k ) qvten ( k ) = qvten ( k ) + prv_rev ( k ) nrten ( k ) = nrten ( k ) - pnr_rev ( k ) tten ( k ) = tten ( k ) - lvap ( k ) * ocp ( k ) * prv_rev ( k ) * ( 1 - IFDRY ) rr ( k ) = MAX ( R1 , ( qr1d ( k ) + DT * qrten ( k )) * rho ( k )) qv ( k ) = MAX ( 1.E-10 , qv1d ( k ) + DT * qvten ( k )) nr ( k ) = MAX ( R2 , ( nr1d ( k ) + DT * nrten ( k )) * rho ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = 0.622 * pres ( k ) / ( RR2 * temp ( k ) * ( qv ( k ) + 0.622 )) endif enddo !+---+-----------------------------------------------------------------+ !..Find max terminal fallspeed (distribution mass-weighted mean !.. velocity) and use it to determine if we need to split the timestep !.. (var nstep>1).  Either way, only bother to do sedimentation below !.. 1st level that contains any sedimenting particles (k=ksed1 on down). !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !+---+-----------------------------------------------------------------+ nstep = 0 onstep (:) = 1.0 ksed1 (:) = 1 do k = kte + 1 , kts , - 1 vtrk ( k ) = 0. vtnrk ( k ) = 0. vtik ( k ) = 0. vtnik ( k ) = 0. vtsk ( k ) = 0. vtgk ( k ) = 0. enddo do k = kte , kts , - 1 vtr = 0. rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) if ( rr ( k ). gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr vtr = rhof ( k ) * av_r * crg ( 6 ) * org3 * lamr ** cre ( 3 ) & * (( lamr + fv_r ) ** ( - cre ( 6 ))) vtrk ( k ) = vtr ! First below is technically correct: !         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                 & !                     *((lamr+fv_r)**(-cre(5))) ! Test: make number fall faster (but still slower than mass) ! Goal: less prominent size sorting vtr = rhof ( k ) * av_r * crg ( 7 ) / crg ( 12 ) * lamr ** cre ( 12 ) & * (( lamr + fv_r ) ** ( - cre ( 7 ))) vtnrk ( k ) = vtr else vtrk ( k ) = vtrk ( k + 1 ) vtnrk ( k ) = vtnrk ( k + 1 ) endif if ( MAX ( vtrk ( k ), vtnrk ( k )) . gt . 1.E-3 ) then ksed1 ( 1 ) = MAX ( ksed1 ( 1 ), k ) delta_tp = dzq ( k ) / ( MAX ( vtrk ( k ), vtnrk ( k ))) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 1 ) . eq . kte ) ksed1 ( 1 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 1 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then nstep = 0 do k = kte , kts , - 1 vti = 0. if ( ri ( k ). gt . R1 ) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami vti = rhof ( k ) * av_i * cig ( 3 ) * oig2 * ilami ** bv_i vtik ( k ) = vti ! First below is technically correct: !          vti = rhof(k)*av_i*cig(4)*oig1 * ilami**bv_i ! Goal: less prominent size sorting vti = rhof ( k ) * av_i * cig ( 6 ) / cig ( 7 ) * ilami ** bv_i vtnik ( k ) = vti else vtik ( k ) = vtik ( k + 1 ) vtnik ( k ) = vtnik ( k + 1 ) endif if ( vtik ( k ) . gt . 1.E-3 ) then ksed1 ( 2 ) = MAX ( ksed1 ( 2 ), k ) delta_tp = dzq ( k ) / vtik ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 2 ) . eq . kte ) ksed1 ( 2 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 2 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ nstep = 0 do k = kte , kts , - 1 vts = 0. if ( rs ( k ). gt . R1 ) then xDs = smoc ( k ) / smob ( k ) Mrat = 1. / xDs ils1 = 1. / ( Mrat * Lam0 + fv_s ) ils2 = 1. / ( Mrat * Lam1 + fv_s ) t1_vts = Kap0 * csg ( 4 ) * ils1 ** cse ( 4 ) t2_vts = Kap1 * Mrat ** mu_s * csg ( 10 ) * ils2 ** cse ( 10 ) ils1 = 1. / ( Mrat * Lam0 ) ils2 = 1. / ( Mrat * Lam1 ) t3_vts = Kap0 * csg ( 1 ) * ils1 ** cse ( 1 ) t4_vts = Kap1 * Mrat ** mu_s * csg ( 7 ) * ils2 ** cse ( 7 ) vts = rhof ( k ) * av_s * ( t1_vts + t2_vts ) / ( t3_vts + t4_vts ) if ( temp ( k ). gt . T_0 ) then vtsk ( k ) = MAX ( vts * vts_boost ( k ), vtrk ( k )) else vtsk ( k ) = vts * vts_boost ( k ) endif else vtsk ( k ) = vtsk ( k + 1 ) endif if ( vtsk ( k ) . gt . 1.E-3 ) then ksed1 ( 3 ) = MAX ( ksed1 ( 3 ), k ) delta_tp = dzq ( k ) / vtsk ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 3 ) . eq . kte ) ksed1 ( 3 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 3 ) = 1. / REAL ( nstep ) !+---+-----------------------------------------------------------------+ nstep = 0 do k = kte , kts , - 1 vtg = 0. if ( rg ( k ). gt . R1 ) then vtg = rhof ( k ) * av_g * cgg ( 6 ) * ogg3 * ilamg ( k ) ** bv_g if ( temp ( k ). gt . T_0 ) then vtgk ( k ) = MAX ( vtg , vtrk ( k )) else vtgk ( k ) = vtg endif else vtgk ( k ) = vtgk ( k + 1 ) endif if ( vtgk ( k ) . gt . 1.E-3 ) then ksed1 ( 4 ) = MAX ( ksed1 ( 4 ), k ) delta_tp = dzq ( k ) / vtgk ( k ) nstep = MAX ( nstep , INT ( DT / delta_tp + 1. )) endif enddo if ( ksed1 ( 4 ) . eq . kte ) ksed1 ( 4 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 4 ) = 1. / REAL ( nstep ) endif !+---+-----------------------------------------------------------------+ !..Sedimentation of mixing ratio is the integral of v(D)*m(D)*N(D)*dD, !.. whereas neglect m(D) term for number concentration.  Therefore, !.. cloud ice has proper differential sedimentation. !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 1 )) do n = 1 , nstep do k = kte , kts , - 1 sed_r ( k ) = vtrk ( k ) * rr ( k ) sed_n ( k ) = vtnrk ( k ) * nr ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) - sed_r ( k ) * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) - sed_n ( k ) * odzq * onstep ( 1 ) * orho rr ( k ) = MAX ( R1 , rr ( k ) - sed_r ( k ) * odzq * DT * onstep ( 1 )) nr ( k ) = MAX ( R2 , nr ( k ) - sed_n ( k ) * odzq * DT * onstep ( 1 )) do k = ksed1 ( 1 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 1 ) * orho rr ( k ) = MAX ( R1 , rr ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * DT * onstep ( 1 )) nr ( k ) = MAX ( R2 , nr ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 1 )) enddo if ( rr ( kts ). gt . R1 * 1 0. ) & pptrain = pptrain + sed_r ( kts ) * DT * onstep ( 1 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 2 )) do n = 1 , nstep do k = kte , kts , - 1 sed_i ( k ) = vtik ( k ) * ri ( k ) sed_n ( k ) = vtnik ( k ) * ni ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) - sed_i ( k ) * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) - sed_n ( k ) * odzq * onstep ( 2 ) * orho ri ( k ) = MAX ( R1 , ri ( k ) - sed_i ( k ) * odzq * DT * onstep ( 2 )) ni ( k ) = MAX ( R2 , ni ( k ) - sed_n ( k ) * odzq * DT * onstep ( 2 )) do k = ksed1 ( 2 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 2 ) * orho ri ( k ) = MAX ( R1 , ri ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * DT * onstep ( 2 )) ni ( k ) = MAX ( R2 , ni ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 2 )) enddo if ( ri ( kts ). gt . R1 * 1 0. ) & pptice = pptice + sed_i ( kts ) * DT * onstep ( 2 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 3 )) do n = 1 , nstep do k = kte , kts , - 1 sed_s ( k ) = vtsk ( k ) * rs ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) - sed_s ( k ) * odzq * onstep ( 3 ) * orho rs ( k ) = MAX ( R1 , rs ( k ) - sed_s ( k ) * odzq * DT * onstep ( 3 )) do k = ksed1 ( 3 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * onstep ( 3 ) * orho rs ( k ) = MAX ( R1 , rs ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * DT * onstep ( 3 )) enddo if ( rs ( kts ). gt . R1 * 1 0. ) & pptsnow = pptsnow + sed_s ( kts ) * DT * onstep ( 3 ) enddo !+---+-----------------------------------------------------------------+ nstep = NINT ( 1. / onstep ( 4 )) do n = 1 , nstep do k = kte , kts , - 1 sed_g ( k ) = vtgk ( k ) * rg ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) - sed_g ( k ) * odzq * onstep ( 4 ) * orho rg ( k ) = MAX ( R1 , rg ( k ) - sed_g ( k ) * odzq * DT * onstep ( 4 )) do k = ksed1 ( 4 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * onstep ( 4 ) * orho rg ( k ) = MAX ( R1 , rg ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * DT * onstep ( 4 )) enddo if ( rg ( kts ). gt . R1 * 1 0. ) & pptgraul = pptgraul + sed_g ( kts ) * DT * onstep ( 4 ) enddo !+---+-----------------------------------------------------------------+ !.. Instantly melt any cloud ice into cloud water if above 0C and !.. instantly freeze any cloud water found below HGFR. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte xri = MAX ( 0.0 , qi1d ( k ) + qiten ( k ) * DT ) if ( ( temp ( k ). gt . T_0 ) . and . ( xri . gt . 0.0 ) ) then qcten ( k ) = qcten ( k ) + xri * odt qiten ( k ) = qiten ( k ) - xri * odt niten ( k ) = - ni1d ( k ) * odt tten ( k ) = tten ( k ) - lfus * ocp ( k ) * xri * odt * ( 1 - IFDRY ) endif xrc = MAX ( 0.0 , qc1d ( k ) + qcten ( k ) * DT ) if ( ( temp ( k ). lt . HGFR ) . and . ( xrc . gt . 0.0 ) ) then lfus2 = lsub - lvap ( k ) qiten ( k ) = qiten ( k ) + xrc * odt niten ( k ) = niten ( k ) + xrc / xm0i * odt qcten ( k ) = qcten ( k ) - xrc * odt tten ( k ) = tten ( k ) + lfus2 * ocp ( k ) * xrc * odt * ( 1 - IFDRY ) endif enddo endif !+---+-----------------------------------------------------------------+ !.. All tendencies computed, apply and pass back final values to parent. !+---+-----------------------------------------------------------------+ do k = kts , kte t1d ( k ) = t1d ( k ) + tten ( k ) * DT qv1d ( k ) = MAX ( 1.E-10 , qv1d ( k ) + qvten ( k ) * DT ) qc1d ( k ) = qc1d ( k ) + qcten ( k ) * DT if ( qc1d ( k ) . le . R1 ) qc1d ( k ) = 0.0 qi1d ( k ) = qi1d ( k ) + qiten ( k ) * DT ni1d ( k ) = MAX ( R2 / rho ( k ), ni1d ( k ) + niten ( k ) * DT ) if ( qi1d ( k ) . le . R1 ) then qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 else lami = ( am_i * cig ( 2 ) * oig1 * ni1d ( k ) / qi1d ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 2 0.E-6 ) then lami = cie ( 2 ) / 2 0.E-6 elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 endif ni1d ( k ) = MIN ( cig ( 1 ) * oig2 * qi1d ( k ) / am_i * lami ** bm_i , & 25 0.D3 / rho ( k )) endif qr1d ( k ) = qr1d ( k ) + qrten ( k ) * DT nr1d ( k ) = MAX ( R2 / rho ( k ), nr1d ( k ) + nrten ( k ) * DT ) if ( qr1d ( k ) . le . R1 ) then qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 else lamr = ( am_r * crg ( 3 ) * org2 * nr1d ( k ) / qr1d ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 endif lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr1d ( k ) = crg ( 2 ) * org3 * qr1d ( k ) * lamr ** bm_r / am_r endif qs1d ( k ) = qs1d ( k ) + qsten ( k ) * DT if ( qs1d ( k ) . le . R1 ) qs1d ( k ) = 0.0 qg1d ( k ) = qg1d ( k ) + qgten ( k ) * DT if ( qg1d ( k ) . le . R1 ) qg1d ( k ) = 0.0 enddo end subroutine mp_thompson !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !..Creation of the lookup tables and support functions found below here. !+---+-----------------------------------------------------------------+ !..Rain collecting graupel (and inverse).  Explicit CE integration. !+---+-----------------------------------------------------------------+ subroutine qr_acr_qg implicit none !..Local variables INTEGER :: i , j , k , m , n , n2 INTEGER :: km , km_s , km_e DOUBLE PRECISION , DIMENSION ( nbg ) :: vg , N_g DOUBLE PRECISION , DIMENSION ( nbr ) :: vr , N_r DOUBLE PRECISION :: N0_r , N0_g , lam_exp , lamg , lamr DOUBLE PRECISION :: massg , massr , dvg , dvr , t1 , t2 , z1 , z2 , y1 , y2 logical :: lexist , lopen integer :: good good = 0 INQUIRE ( FILE = \"qr_acr_qg_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN if ( this_image () == 1 ) print * , \"ThompMP: read qr_acr_qg_mpt.dat instead of computing\" OPEN ( 63 , file = \"qr_acr_qg_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tcg_racg READ ( 63 , err = 1234 ) tmr_racg READ ( 63 , err = 1234 ) tcr_gacr READ ( 63 , err = 1234 ) tmg_gacr READ ( 63 , err = 1234 ) tnr_racg READ ( 63 , err = 1234 ) tnr_gacr good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) ENDIF ENDIF if ( good . NE . 1 ) then do n2 = 1 , nbr !        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2)) vr ( n2 ) = - 0.1021 + 4.932E3 * Dr ( n2 ) - 0.9551E6 * Dr ( n2 ) * Dr ( n2 ) & + 0.07934E9 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) & - 0.002362E12 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) enddo do n = 1 , nbg vg ( n ) = av_g * Dg ( n ) ** bv_g enddo !..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for !.. fortran indices.  J. Michalakes, 2009Oct30. ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e ) ! #else km_s = 0 km_e = ntb_r * ntb_r1 - 1 ! #endif !$omp parallel  default(shared) & !$omp private(km,i,j,k,m,n,n2,lam_exp,lamr,N0_r,N_r,lamg,N_g,N0_g,t1,t2,z1,z2,y1,y2,massr,massg,dvg,dvr) & !$omp shared(tcg_racg,tmr_racg,tcr_gacr,tmg_gacr,tnr_racg,tnr_gacr,mu_r,ef_rs,am_s) & !$omp firstprivate(crg,cre,cge,cgg,ore1,oge1,org1,org2,ogg2,ogg1,obmg,obmr) & !$omp firstprivate(km_s,km_e,Dr,Dg,dtg,dtr,vr,vg) !$omp do do km = km_s , km_e m = km / ntb_r1 + 1 k = mod ( km , ntb_r1 ) + 1 lam_exp = ( N0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) enddo do j = 1 , ntb_g do i = 1 , ntb_g1 lam_exp = ( N0g_exp ( i ) * am_g * cgg ( 1 ) / r_g ( j )) ** oge1 lamg = lam_exp * ( cgg ( 3 ) * ogg2 * ogg1 ) ** obmg N0_g = N0g_exp ( i ) / ( cgg ( 2 ) * lam_exp ) * lamg ** cge ( 2 ) do n = 1 , nbg N_g ( n ) = N0_g * Dg ( n ) ** mu_g * DEXP ( - lamg * Dg ( n )) * dtg ( n ) enddo t1 = 0.0d0 t2 = 0.0d0 z1 = 0.0d0 z2 = 0.0d0 y1 = 0.0d0 y2 = 0.0d0 do n2 = 1 , nbr massr = am_r * Dr ( n2 ) ** bm_r do n = 1 , nbg massg = am_g * Dg ( n ) ** bm_g dvg = 0.5d0 * (( vr ( n2 ) - vg ( n )) + DABS ( vr ( n2 ) - vg ( n ))) dvr = 0.5d0 * (( vg ( n ) - vr ( n2 )) + DABS ( vg ( n ) - vr ( n2 ))) t1 = t1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * massg * N_g ( n ) * N_r ( n2 ) z1 = z1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * massr * N_g ( n ) * N_r ( n2 ) y1 = y1 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvg * N_g ( n ) * N_r ( n2 ) t2 = t2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * massr * N_g ( n ) * N_r ( n2 ) y2 = y2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * N_g ( n ) * N_r ( n2 ) z2 = z2 + PI2 * . 25 * Ef_rg * ( Dg ( n ) + Dr ( n2 )) * ( Dg ( n ) + Dr ( n2 )) & * dvr * massg * N_g ( n ) * N_r ( n2 ) enddo 97 continue enddo tcg_racg ( i , j , k , m ) = t1 tmr_racg ( i , j , k , m ) = DMIN1 ( z1 , r_r ( m ) * 1.0d0 ) tcr_gacr ( i , j , k , m ) = t2 tmg_gacr ( i , j , k , m ) = z2 tnr_racg ( i , j , k , m ) = y1 tnr_gacr ( i , j , k , m ) = y2 enddo enddo enddo !$omp end do !$omp end parallel IF ( this_image () == 1 ) THEN print * , \"Writing qr_acr_qg_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"qr_acr_qg_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tcg_racg WRITE ( 63 , err = 9234 ) tmr_racg WRITE ( 63 , err = 9234 ) tcr_gacr WRITE ( 63 , err = 9234 ) tmg_gacr WRITE ( 63 , err = 9234 ) tnr_racg WRITE ( 63 , err = 9234 ) tnr_gacr CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , ( \"Error writing qr_acr_qg_mpt.dat\" ) ENDIF endif !..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30). ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_gatherv(tcg_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmg_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE) ! #endif end subroutine qr_acr_qg !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !..Rain collecting snow (and inverse).  Explicit CE integration. !+---+-----------------------------------------------------------------+ subroutine qr_acr_qs implicit none !..Local variables INTEGER :: i , j , k , m , n , n2 INTEGER :: km , km_s , km_e DOUBLE PRECISION , DIMENSION ( nbr ) :: vr , D1 , N_r DOUBLE PRECISION , DIMENSION ( nbs ) :: vs , N_s DOUBLE PRECISION :: loga_ , a_ , b_ , second , M0 , M2 , M3 , Mrat , oM3 DOUBLE PRECISION :: N0_r , lam_exp , lamr , slam1 , slam2 DOUBLE PRECISION :: dvs , dvr , masss , massr DOUBLE PRECISION :: t1 , t2 , t3 , t4 , z1 , z2 , z3 , z4 DOUBLE PRECISION :: y1 , y2 , y3 , y4 LOGICAL lexist , lopen INTEGER :: good !   LOGICAL, EXTERNAL :: wrf_dm_on_monitor !+---+ !   CALL nl_get_force_read_thompson(1,force_read_thompson) !   CALL nl_get_write_thompson_tables(1,write_thompson_tables) good = 0 INQUIRE ( FILE = \"qr_acr_qs_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN IF ( this_image () == 1 ) print * , \"ThompMP: read qr_acr_qs_mpt.dat instead of computing\" OPEN ( 63 , file = \"qr_acr_qs_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tcs_racs1 READ ( 63 , err = 1234 ) tmr_racs1 READ ( 63 , err = 1234 ) tcs_racs2 READ ( 63 , err = 1234 ) tmr_racs2 READ ( 63 , err = 1234 ) tcr_sacr1 READ ( 63 , err = 1234 ) tms_sacr1 READ ( 63 , err = 1234 ) tcr_sacr2 READ ( 63 , err = 1234 ) tms_sacr2 READ ( 63 , err = 1234 ) tnr_racs1 READ ( 63 , err = 1234 ) tnr_racs2 READ ( 63 , err = 1234 ) tnr_sacr1 READ ( 63 , err = 1234 ) tnr_sacr2 good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) ENDIF ENDIF if ( good . NE . 1 ) then if ( this_image () == 1 ) print * , \"ThompMP: computing qr_acr_qs\" !+---+ do n2 = 1 , nbr !        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2)) vr ( n2 ) = - 0.1021 + 4.932E3 * Dr ( n2 ) - 0.9551E6 * Dr ( n2 ) * Dr ( n2 ) & + 0.07934E9 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) & - 0.002362E12 * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) * Dr ( n2 ) D1 ( n2 ) = ( vr ( n2 ) / av_s ) ** ( 1. / bv_s ) enddo do n = 1 , nbs vs ( n ) = 1.5 * av_s * Ds ( n ) ** bv_s * DEXP ( - fv_s * Ds ( n )) enddo !..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for !.. fortran indices.  J. Michalakes, 2009Oct30. ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e ) ! #else km_s = 0 km_e = ntb_r * ntb_r1 - 1 ! #endif !$omp parallel default(private) & !$omp shared(tcs_racs1,tmr_racs1,tcs_racs2,tmr_racs2,tcr_sacr1,tms_sacr1)& !$omp shared(tcr_sacr2,tms_sacr2,tnr_racs1,tnr_racs2,tnr_sacr1,tnr_sacr2,mu_r,ef_rs,am_s) & !$omp private(second,a_,b_,n2,km,M2,M3,oM3,Mrat,M0,slam1,slam2,i,j,k,m,n,lam_exp,lamr,N0_r,N_r,loga_) & !$omp private(t1,t2,t3,t4,z1,z2,z3,z4,y1,y2,y3,y4,N_s,massr,masss,dvs,dvr) & !$omp firstprivate(km_s,km_e,vr,vs) & !$omp firstprivate(Dr,dtr,dts,Ds,crg,cre,cse,ore1,org2,org1,obmr,oams) !$omp do do km = km_s , km_e m = km / ntb_r1 + 1 k = mod ( km , ntb_r1 ) + 1 lam_exp = ( N0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) enddo do j = 1 , ntb_t do i = 1 , ntb_s !..From the bm_s moment, compute plus one moment.  If we are not !.. using bm_s=2, then we must transform to the pure 2nd moment !.. (variable called \"second\") and then to the bm_s+1 moment. M2 = r_s ( i ) * oams * 1.0d0 if ( bm_s . gt . 2.0 - 1.E-3 . and . bm_s . lt . 2.0 + 1.E-3 ) then loga_ = sa ( 1 ) + sa ( 2 ) * Tc ( j ) + sa ( 3 ) * bm_s & + sa ( 4 ) * Tc ( j ) * bm_s + sa ( 5 ) * Tc ( j ) * Tc ( j ) & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * Tc ( j ) * Tc ( j ) * bm_s & + sa ( 8 ) * Tc ( j ) * bm_s * bm_s + sa ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * Tc ( j ) + sb ( 3 ) * bm_s & + sb ( 4 ) * Tc ( j ) * bm_s + sb ( 5 ) * Tc ( j ) * Tc ( j ) & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * Tc ( j ) * Tc ( j ) * bm_s & + sb ( 8 ) * Tc ( j ) * bm_s * bm_s + sb ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sb ( 10 ) * bm_s * bm_s * bm_s second = ( M2 / a_ ) ** ( 1. / b_ ) else second = M2 endif loga_ = sa ( 1 ) + sa ( 2 ) * Tc ( j ) + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * Tc ( j ) * cse ( 1 ) + sa ( 5 ) * Tc ( j ) * Tc ( j ) & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * Tc ( j ) * Tc ( j ) * cse ( 1 ) & + sa ( 8 ) * Tc ( j ) * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * Tc ( j ) + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * Tc ( j ) * cse ( 1 ) & + sb ( 5 ) * Tc ( j ) * Tc ( j ) + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * Tc ( j ) * Tc ( j ) * cse ( 1 ) + sb ( 8 ) * Tc ( j ) * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * Tc ( j ) * Tc ( j ) * Tc ( j ) + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) M3 = a_ * second ** b_ oM3 = 1. / M3 Mrat = M2 * ( M2 * oM3 ) * ( M2 * oM3 ) * ( M2 * oM3 ) M0 = ( M2 * oM3 ) ** mu_s slam1 = M2 * oM3 * Lam0 slam2 = M2 * oM3 * Lam1 do n = 1 , nbs N_s ( n ) = Mrat * ( Kap0 * DEXP ( - slam1 * Ds ( n )) & + Kap1 * M0 * Ds ( n ) ** mu_s * DEXP ( - slam2 * Ds ( n ))) * dts ( n ) enddo t1 = 0.0d0 t2 = 0.0d0 t3 = 0.0d0 t4 = 0.0d0 z1 = 0.0d0 z2 = 0.0d0 z3 = 0.0d0 z4 = 0.0d0 y1 = 0.0d0 y2 = 0.0d0 y3 = 0.0d0 y4 = 0.0d0 do n2 = 1 , nbr massr = am_r * Dr ( n2 ) ** bm_r do n = 1 , nbs masss = am_s * Ds ( n ) ** bm_s dvs = 0.5d0 * (( vr ( n2 ) - vs ( n )) + DABS ( vr ( n2 ) - vs ( n ))) dvr = 0.5d0 * (( vs ( n ) - vr ( n2 )) + DABS ( vs ( n ) - vr ( n2 ))) if ( massr . gt . 1.5 * masss ) then t1 = t1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * masss * N_s ( n ) * N_r ( n2 ) z1 = z1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * massr * N_s ( n ) * N_r ( n2 ) y1 = y1 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * N_s ( n ) * N_r ( n2 ) else t3 = t3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * masss * N_s ( n ) * N_r ( n2 ) z3 = z3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * massr * N_s ( n ) * N_r ( n2 ) y3 = y3 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvs * N_s ( n ) * N_r ( n2 ) endif if ( massr . gt . 1.5 * masss ) then t2 = t2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * massr * N_s ( n ) * N_r ( n2 ) y2 = y2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * N_s ( n ) * N_r ( n2 ) z2 = z2 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * masss * N_s ( n ) * N_r ( n2 ) else t4 = t4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * massr * N_s ( n ) * N_r ( n2 ) y4 = y4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * N_s ( n ) * N_r ( n2 ) z4 = z4 + PI2 * . 25 * Ef_rs * ( Ds ( n ) + Dr ( n2 )) * ( Ds ( n ) + Dr ( n2 )) & * dvr * masss * N_s ( n ) * N_r ( n2 ) endif enddo enddo tcs_racs1 ( i , j , k , m ) = t1 tmr_racs1 ( i , j , k , m ) = DMIN1 ( z1 , r_r ( m ) * 1.0d0 ) tcs_racs2 ( i , j , k , m ) = t3 tmr_racs2 ( i , j , k , m ) = z3 tcr_sacr1 ( i , j , k , m ) = t2 tms_sacr1 ( i , j , k , m ) = z2 tcr_sacr2 ( i , j , k , m ) = t4 tms_sacr2 ( i , j , k , m ) = z4 tnr_racs1 ( i , j , k , m ) = y1 tnr_racs2 ( i , j , k , m ) = y3 tnr_sacr1 ( i , j , k , m ) = y2 tnr_sacr2 ( i , j , k , m ) = y4 enddo enddo enddo !$omp end do !$omp end parallel IF ( this_image () == 1 ) THEN print * , \"Writing qr_acr_qs_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"qr_acr_qs_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tcs_racs1 WRITE ( 63 , err = 9234 ) tmr_racs1 WRITE ( 63 , err = 9234 ) tcs_racs2 WRITE ( 63 , err = 9234 ) tmr_racs2 WRITE ( 63 , err = 9234 ) tcr_sacr1 WRITE ( 63 , err = 9234 ) tms_sacr1 WRITE ( 63 , err = 9234 ) tcr_sacr2 WRITE ( 63 , err = 9234 ) tms_sacr2 WRITE ( 63 , err = 9234 ) tnr_racs1 WRITE ( 63 , err = 9234 ) tnr_racs2 WRITE ( 63 , err = 9234 ) tnr_sacr1 WRITE ( 63 , err = 9234 ) tnr_sacr2 CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , \"Error writing qr_acr_qs_mpt.dat\" ENDIF ENDIF !..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30). ! #if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) ) ! CALL wrf_dm_gatherv(tcs_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcs_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tmr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tms_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tcr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tms_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! CALL wrf_dm_gatherv(tnr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE) ! #endif end subroutine qr_acr_qs !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !..This is a literal adaptation of Bigg (1954) probability of drops of !..a particular volume freezing.  Given this probability, simply freeze !..the proportion of drops summing their masses. !+---+-----------------------------------------------------------------+ subroutine freezeH2O implicit none !..Local variables INTEGER :: i , j , k , n , n2 DOUBLE PRECISION , DIMENSION ( nbr ) :: N_r , massr DOUBLE PRECISION , DIMENSION ( nbc ) :: N_c , massc DOUBLE PRECISION :: sum1 , sum2 , sumn1 , sumn2 , & prob , vol , Texp , orho_w , & lam_exp , lamr , N0_r , lamc , N0_c , y LOGICAL lexist , lopen INTEGER :: good !   LOGICAL, EXTERNAL :: wrf_dm_on_monitor !+---+ good = 0 ! IF ( this_image() == 1 ) THEN INQUIRE ( FILE = \"freezeH2O_mpt.dat\" , EXIST = lexist ) IF ( lexist ) THEN IF ( this_image () == 1 ) print * , \"ThompMP: read freezeH2O_mpt.dat instead of computing\" OPEN ( 63 , file = \"freezeH2O_mpt.dat\" , form = \"unformatted\" , err = 1234 ) READ ( 63 , err = 1234 ) tpi_qrfz READ ( 63 , err = 1234 ) tni_qrfz READ ( 63 , err = 1234 ) tpg_qrfz READ ( 63 , err = 1234 ) tnr_qrfz READ ( 63 , err = 1234 ) tpi_qcfz READ ( 63 , err = 1234 ) tni_qcfz good = 1 1234 CONTINUE INQUIRE ( 63 , opened = lopen ) IF ( lopen ) THEN CLOSE ( 63 ) endif ENDIF IF ( good . NE . 1 ) THEN if ( this_image () == 1 ) print * , \"ThompMP: computing freezeH2O\" !+---+ orho_w = 1. / rho_w do n2 = 1 , nbr massr ( n2 ) = am_r * Dr ( n2 ) ** bm_r enddo do n = 1 , nbc massc ( n ) = am_r * Dc ( n ) ** bm_r enddo !..Freeze water (smallest drops become cloud ice, otherwise graupel). do k = 1 , 45 !         print*, ' Freezing water for temp = ', -k ! ++ trude, add tadjust, so to chane temperature for where Bigg freezing starts. Follow approach in WRFV3.6 with IN Texp = DEXP ( DFLOAT ( k ) - t_adjust * 1.0D0 ) - 1.0D0 ! NB Trude. Check for when texp is negative..... !         Texp = DEXP( DFLOAT(k) ) - 1.0D0 ! -- trude do j = 1 , ntb_r1 do i = 1 , ntb_r lam_exp = ( N0r_exp ( j ) * am_r * crg ( 1 ) / r_r ( i )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0_r = N0r_exp ( j ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) sum1 = 0.0d0 sum2 = 0.0d0 sumn1 = 0.0d0 sumn2 = 0.0d0 do n2 = nbr , 1 , - 1 N_r ( n2 ) = N0_r * Dr ( n2 ) ** mu_r * DEXP ( - lamr * Dr ( n2 )) * dtr ( n2 ) vol = massr ( n2 ) * orho_w prob = 1.0D0 - DEXP ( - 12 0.0D0 * vol * 5.2D-4 * Texp ) !++ trude prob = MAX ( prob , 0.0d0 ) ! -- trude if ( massr ( n2 ) . lt . xm0g ) then sumn1 = sumn1 + prob * N_r ( n2 ) sum1 = sum1 + prob * N_r ( n2 ) * massr ( n2 ) else sumn2 = sumn2 + prob * N_r ( n2 ) sum2 = sum2 + prob * N_r ( n2 ) * massr ( n2 ) endif if (( sum1 + sum2 ) . ge . r_r ( i )) EXIT enddo tpi_qrfz ( i , j , k ) = sum1 tni_qrfz ( i , j , k ) = sumn1 tpg_qrfz ( i , j , k ) = sum2 tnr_qrfz ( i , j , k ) = sumn2 enddo enddo do i = 1 , ntb_c lamc = 1.0D-6 * ( Nt_c * am_r * ccg ( 2 ) * ocg1 / r_c ( i )) ** obmr N0_c = 1.0D-18 * Nt_c * ocg1 * lamc ** cce ( 1 ) sum1 = 0.0d0 sumn2 = 0.0d0 do n = nbc , 1 , - 1 y = Dc ( n ) * 1.0D6 vol = massc ( n ) * orho_w prob = 1.0D0 - DEXP ( - 12 0.0D0 * vol * 5.2D-4 * Texp ) !++ trude prob = MAX ( prob , 0.0d0 ) ! -- trude N_c ( n ) = N0_c * y ** mu_c * EXP ( - lamc * y ) * dtc ( n ) N_c ( n ) = 1.0D24 * N_c ( n ) sumn2 = sumn2 + prob * N_c ( n ) sum1 = sum1 + prob * N_c ( n ) * massc ( n ) if ( sum1 . ge . r_c ( i )) EXIT enddo tpi_qcfz ( i , k ) = sum1 tni_qcfz ( i , k ) = sumn2 enddo enddo IF ( this_image () == 1 ) THEN print * , \"Writing freezeH2O_mpt.dat in Thompson MP init\" OPEN ( 63 , file = \"freezeH2O_mpt.dat\" , form = \"unformatted\" , err = 9234 ) WRITE ( 63 , err = 9234 ) tpi_qrfz WRITE ( 63 , err = 9234 ) tni_qrfz WRITE ( 63 , err = 9234 ) tpg_qrfz WRITE ( 63 , err = 9234 ) tnr_qrfz WRITE ( 63 , err = 9234 ) tpi_qcfz WRITE ( 63 , err = 9234 ) tni_qcfz CLOSE ( 63 ) RETURN ! ----- RETURN 9234 CONTINUE print * , \"Error writing freezeH2O_mpt.dat\" ENDIF endif end subroutine freezeH2O !+---+-----------------------------------------------------------------+ !ctrlL !+---+-----------------------------------------------------------------+ !..Cloud ice converting to snow since portion greater than min snow !.. size.  Given cloud ice content (kg/m**3), number concentration !.. (#/m**3) and gamma shape parameter, mu_i, break the distrib into !.. bins and figure out the mass/number of ice with sizes larger than !.. D0s.  Also, compute incomplete gamma function for the integration !.. of ice depositional growth from diameter=0 to D0s.  Amount of !.. ice depositional growth is this portion of distrib while larger !.. diameters contribute to snow growth (as in Harrington et al. 1995). !+---+-----------------------------------------------------------------+ subroutine qi_aut_qs implicit none !..Local variables INTEGER :: i , j , n2 DOUBLE PRECISION , DIMENSION ( nbi ) :: N_i DOUBLE PRECISION :: N0_i , lami , Di_mean , t1 , t2 REAL :: xlimit_intg !+---+ do j = 1 , ntb_i1 do i = 1 , ntb_i lami = ( am_i * cig ( 2 ) * oig1 * Nt_i ( j ) / r_i ( i )) ** obmi Di_mean = ( bm_i + mu_i + 1. ) / lami N0_i = Nt_i ( j ) * oig1 * lami ** cie ( 1 ) t1 = 0.0d0 t2 = 0.0d0 if ( SNGL ( Di_mean ) . gt . 5. * D0s ) then t1 = r_i ( i ) t2 = Nt_i ( j ) tpi_ide ( i , j ) = 0.0D0 elseif ( SNGL ( Di_mean ) . lt . D0i ) then t1 = 0.0D0 t2 = 0.0D0 tpi_ide ( i , j ) = 1.0D0 else xlimit_intg = lami * D0s tpi_ide ( i , j ) = GAMMP ( mu_i + 2.0 , xlimit_intg ) * 1.0D0 do n2 = 1 , nbi N_i ( n2 ) = N0_i * Di ( n2 ) ** mu_i * DEXP ( - lami * Di ( n2 )) * dti ( n2 ) if ( Di ( n2 ). ge . D0s ) then t1 = t1 + N_i ( n2 ) * am_i * Di ( n2 ) ** bm_i t2 = t2 + N_i ( n2 ) endif enddo endif tps_iaus ( i , j ) = t1 tni_iaus ( i , j ) = t2 enddo enddo end subroutine qi_aut_qs !ctrlL !+---+-----------------------------------------------------------------+ !..Variable collision efficiency for rain collecting cloud water using !.. method of Beard and Grover, 1974 if a/A less than 0.25; otherwise !.. uses polynomials to get close match of Pruppacher & Klett Fig 14-9. !+---+-----------------------------------------------------------------+ subroutine table_Efrw implicit none !..Local variables DOUBLE PRECISION :: vtr , stokes , reynolds , Ef_rw DOUBLE PRECISION :: p , yc0 , F , G , H , z , K0 , X INTEGER :: i , j do j = 1 , nbc do i = 1 , nbr Ef_rw = 0.0 p = Dc ( j ) / Dr ( i ) if ( Dr ( i ). lt . 5 0.E-6 . or . Dc ( j ). lt . 3.E-6 ) then t_Efrw ( i , j ) = 0.0 elseif ( p . gt . 0.25 ) then X = Dc ( j ) * 1.D6 if ( Dr ( i ) . lt . 7 5.e-6 ) then Ef_rw = 0.026794 * X - 0.20604 elseif ( Dr ( i ) . lt . 12 5.e-6 ) then Ef_rw = - 0.00066842 * X * X + 0.061542 * X - 0.37089 elseif ( Dr ( i ) . lt . 17 5.e-6 ) then Ef_rw = 4.091e-06 * X * X * X * X - 0.00030908 * X * X * X & + 0.0066237 * X * X - 0.0013687 * X - 0.073022 elseif ( Dr ( i ) . lt . 25 0.e-6 ) then Ef_rw = 9.6719e-5 * X * X * X - 0.0068901 * X * X + 0.17305 * X & - 0.65988 elseif ( Dr ( i ) . lt . 35 0.e-6 ) then Ef_rw = 9.0488e-5 * X * X * X - 0.006585 * X * X + 0.16606 * X & - 0.56125 else Ef_rw = 0.00010721 * X * X * X - 0.0072962 * X * X + 0.1704 * X & - 0.46929 endif else vtr = - 0.1021 + 4.932E3 * Dr ( i ) - 0.9551E6 * Dr ( i ) * Dr ( i ) & + 0.07934E9 * Dr ( i ) * Dr ( i ) * Dr ( i ) & - 0.002362E12 * Dr ( i ) * Dr ( i ) * Dr ( i ) * Dr ( i ) stokes = Dc ( j ) * Dc ( j ) * vtr * rho_w / ( 9. * 1.718E-5 * Dr ( i )) reynolds = 9. * stokes / ( p * p * rho_w ) F = DLOG ( reynolds ) G = - 0.1007D0 - 0.358D0 * F + 0.0261D0 * F * F K0 = DEXP ( G ) z = DLOG ( stokes / ( K0 + 1.D-15 )) H = 0.1465D0 + 1.302D0 * z - 0.607D0 * z * z + 0.293D0 * z * z * z yc0 = 2.0D0 / PI2 * ATAN ( H ) Ef_rw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) endif t_Efrw ( i , j ) = MAX ( 0.0 , MIN ( SNGL ( Ef_rw ), 0.95 )) ! ++ trude if ( Ef_rw_l ) then if ( Ef_rw . ne . 0.0 ) then t_Efrw ( i , j ) = 1.0 endif endif ! -- trude enddo enddo end subroutine table_Efrw !ctrlL !+---+-----------------------------------------------------------------+ !..Variable collision efficiency for snow collecting cloud water using !.. method of Wang and Ji, 2000 except equate melted snow diameter to !.. their \"effective collision cross-section.\" !+---+-----------------------------------------------------------------+ subroutine table_Efsw implicit none !..Local variables DOUBLE PRECISION :: Ds_m , vts , vtc , stokes , reynolds , Ef_sw DOUBLE PRECISION :: p , yc0 , F , G , H , z , K0 INTEGER :: i , j do j = 1 , nbc vtc = 1.19D4 * ( 1.0D4 * Dc ( j ) * Dc ( j ) * 0.25D0 ) do i = 1 , nbs vts = av_s * Ds ( i ) ** bv_s * DEXP ( - fv_s * Ds ( i )) - vtc Ds_m = ( am_s * Ds ( i ) ** bm_s / am_r ) ** obmr p = Dc ( j ) / Ds_m if ( p . gt . 0.25 . or . Ds ( i ). lt . D0s . or . Dc ( j ). lt . 6.E-6 & . or . vts . lt . 1.E-3 ) then t_Efsw ( i , j ) = 0.0 else stokes = Dc ( j ) * Dc ( j ) * vts * rho_w / ( 9. * 1.718E-5 * Ds_m ) reynolds = 9. * stokes / ( p * p * rho_w ) F = DLOG ( reynolds ) G = - 0.1007D0 - 0.358D0 * F + 0.0261D0 * F * F K0 = DEXP ( G ) z = DLOG ( stokes / ( K0 + 1.D-15 )) H = 0.1465D0 + 1.302D0 * z - 0.607D0 * z * z + 0.293D0 * z * z * z yc0 = 2.0D0 / PI2 * ATAN ( H ) Ef_sw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) t_Efsw ( i , j ) = MAX ( 0.0 , MIN ( SNGL ( Ef_sw ), 0.95 )) ! ++ trude if ( Ef_sw_l ) then if ( Ef_sw . ne . 0.0 ) then t_Efsw ( i , j ) = 1.0 endif endif ! -- trude endif enddo enddo end subroutine table_Efsw !ctrlL !+---+-----------------------------------------------------------------+ !..Integrate rain size distribution from zero to D-star to compute the !.. number of drops smaller than D-star that evaporate in a single !.. timestep.  Drops larger than D-star dont evaporate entirely so do !.. not affect number concentration. !+---+-----------------------------------------------------------------+ subroutine table_dropEvap implicit none !..Local variables DOUBLE PRECISION :: Nt_r , N0 , lam_exp , lam REAL :: xlimit_intg INTEGER :: i , j , k do k = 1 , ntb_r do j = 1 , ntb_r1 lam_exp = ( N0r_exp ( j ) * am_r * crg ( 1 ) / r_r ( k )) ** ore1 lam = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr N0 = N0r_exp ( j ) / ( crg ( 2 ) * lam_exp ) * lam ** cre ( 2 ) Nt_r = N0 * crg ( 2 ) / lam ** cre ( 2 ) do i = 1 , nbr xlimit_intg = lam * Dr ( i ) tnr_rev ( i , j , k ) = GAMMP ( mu_r + 1.0 , xlimit_intg ) * Nt_r enddo enddo enddo end subroutine table_dropEvap ! TO APPLY TABLE ABOVE !..Rain lookup table indexes. !         Dr_star = DSQRT(-2.D0*DT * t1_evap/(2.*PI) & !                 * 0.78*4.*diffu(k)*xsat*rvs/rho_w) !         idx_d = NINT(1.0 + FLOAT(nbr) * DLOG(Dr_star/D0r)             & !               / DLOG(Dr(nbr)/D0r)) !         idx_d = MAX(1, MIN(idx_d, nbr)) ! !         nir = NINT(ALOG10(rr(k))) !         do nn = nir-1, nir+1 !            n = nn !            if ( (rr(k)/10.**nn).ge.1.0 .and. & !                 (rr(k)/10.**nn).lt.10.0) goto 154 !         enddo !154      continue !         idx_r = INT(rr(k)/10.**n) + 10*(n-nir2) - (n-nir2) !         idx_r = MAX(1, MIN(idx_r, ntb_r)) ! !         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr !         lam_exp = lamr * (crg(3)*org2*org1)**bm_r !         N0_exp = org1*rr(k)/am_r * lam_exp**cre(1) !         nir = NINT(DLOG10(N0_exp)) !         do nn = nir-1, nir+1 !            n = nn !            if ( (N0_exp/10.**nn).ge.1.0 .and. & !                 (N0_exp/10.**nn).lt.10.0) goto 155 !         enddo !155      continue !         idx_r1 = INT(N0_exp/10.**n) + 10*(n-nir3) - (n-nir3) !         idx_r1 = MAX(1, MIN(idx_r1, ntb_r1)) ! !         pnr_rev(k) = MIN(nr(k)*odts, SNGL(tnr_rev(idx_d,idx_r1,idx_r) &   ! RAIN2M !                    * odts)) ! !ctrlL !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ SUBROUTINE GCF ( GAMMCF , A , X , GLN ) !     --- RETURNS THE INCOMPLETE GAMMA FUNCTION Q(A,X) EVALUATED BY ITS !     --- CONTINUED FRACTION REPRESENTATION AS GAMMCF.  ALSO RETURNS !     --- LN(GAMMA(A)) AS GLN.  THE CONTINUED FRACTION IS EVALUATED BY !     --- A MODIFIED LENTZ METHOD. !     --- USES GAMMLN IMPLICIT NONE INTEGER , PARAMETER :: ITMAX = 100 REAL , PARAMETER :: gEPS = 3.E-7 REAL , PARAMETER :: FPMIN = 1.E-30 REAL , INTENT ( IN ) :: A , X REAL :: GAMMCF , GLN INTEGER :: I REAL :: AN , B , C , D , DEL , H GLN = GAMMLN ( A ) B = X + 1. - A C = 1. / FPMIN D = 1. / B H = D DO 11 I = 1 , ITMAX AN =- I * ( I - A ) B = B + 2. D = AN * D + B IF ( ABS ( D ). LT . FPMIN ) D = FPMIN C = B + AN / C IF ( ABS ( C ). LT . FPMIN ) C = FPMIN D = 1. / D DEL = D * C H = H * DEL IF ( ABS ( DEL - 1. ). LT . gEPS ) GOTO 1 11 CONTINUE PRINT * , 'A TOO LARGE, ITMAX TOO SMALL IN GCF' 1 GAMMCF = EXP ( - X + A * LOG ( X ) - GLN ) * H END SUBROUTINE GCF !  (C) Copr. 1986-92 Numerical Recipes Software 2.02 !+---+-----------------------------------------------------------------+ SUBROUTINE GSER ( GAMSER , A , X , GLN ) !     --- RETURNS THE INCOMPLETE GAMMA FUNCTION P(A,X) EVALUATED BY ITS !     --- ITS SERIES REPRESENTATION AS GAMSER.  ALSO RETURNS LN(GAMMA(A)) !     --- AS GLN. !     --- USES GAMMLN IMPLICIT NONE INTEGER , PARAMETER :: ITMAX = 100 REAL , PARAMETER :: gEPS = 3.E-7 REAL , INTENT ( IN ) :: A , X REAL :: GAMSER , GLN INTEGER :: N REAL :: AP , DEL , SUM GLN = GAMMLN ( A ) IF ( X . LE . 0. ) THEN IF ( X . LT . 0. ) PRINT * , 'X < 0 IN GSER' GAMSER = 0. RETURN ENDIF AP = A SUM = 1. / A DEL = SUM DO 11 N = 1 , ITMAX AP = AP + 1. DEL = DEL * X / AP SUM = SUM + DEL IF ( ABS ( DEL ). LT . ABS ( SUM ) * gEPS ) GOTO 1 11 CONTINUE PRINT * , 'A TOO LARGE, ITMAX TOO SMALL IN GSER' 1 GAMSER = SUM * EXP ( - X + A * LOG ( X ) - GLN ) END SUBROUTINE GSER !  (C) Copr. 1986-92 Numerical Recipes Software 2.02 !+---+-----------------------------------------------------------------+ REAL FUNCTION GAMMLN ( XX ) !     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0. IMPLICIT NONE REAL , INTENT ( IN ) :: XX DOUBLE PRECISION , PARAMETER :: STP = 2.5066282746310005D0 DOUBLE PRECISION , DIMENSION ( 6 ), PARAMETER :: & COF = ( / 7 6.18009172947146D0 , - 8 6.50532032941677D0 , & 2 4.01409824083091D0 , - 1.231739572450155D0 , & . 1208650973866179 D - 2 , - . 5395239384953 D - 5 / ) DOUBLE PRECISION :: SER , TMP , X , Y INTEGER :: J X = XX Y = X TMP = X + 5.5D0 TMP = ( X + 0.5D0 ) * LOG ( TMP ) - TMP SER = 1.000000000190015D0 DO 11 J = 1 , 6 Y = Y + 1.D0 SER = SER + COF ( J ) / Y 11 CONTINUE GAMMLN = TMP + LOG ( STP * SER / X ) END FUNCTION GAMMLN !  (C) Copr. 1986-92 Numerical Recipes Software 2.02 !+---+-----------------------------------------------------------------+ REAL FUNCTION GAMMP ( A , X ) !     --- COMPUTES THE INCOMPLETE GAMMA FUNCTION P(A,X) !     --- SEE ABRAMOWITZ AND STEGUN 6.5.1 !     --- USES GCF,GSER IMPLICIT NONE REAL , INTENT ( IN ) :: A , X REAL :: GAMMCF , GAMSER , GLN GAMMP = 0. IF (( X . LT . 0. ) . OR . ( A . LE . 0. )) THEN PRINT * , 'BAD ARGUMENTS IN GAMMP' RETURN ELSEIF ( X . LT . A + 1. ) THEN CALL GSER ( GAMSER , A , X , GLN ) GAMMP = GAMSER ELSE CALL GCF ( GAMMCF , A , X , GLN ) GAMMP = 1. - GAMMCF ENDIF END FUNCTION GAMMP !  (C) Copr. 1986-92 Numerical Recipes Software 2.02 !+---+-----------------------------------------------------------------+ REAL FUNCTION WGAMMA ( y ) IMPLICIT NONE REAL , INTENT ( IN ) :: y WGAMMA = EXP ( GAMMLN ( y )) END FUNCTION WGAMMA !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS ! A FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A ! FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ END MODULE module_mp_thompson !+---+-----------------------------------------------------------------+","tags":"","loc":"sourcefile/mp_thompson.f90.html"}]}