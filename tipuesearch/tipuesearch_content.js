var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine is a software library for researching ways to efficiently propagate inputs through deep, feed-forward neural networks exported from Python by the companion package nexport .  Inference-Engine's implementation language, Fortran 2018, makes it suitable for integration into high-performance computing (HPC) applications.  The first HPC application of interest is the Intermediate Complexity Atmospheric Research ( ICAR ) model.  The novel features of Inference-Engine include Exposing concurrency via An elemental inference function An elemental activation strategy Gathering network weights and biases into contiguous arrays Runtime selection of inference algorithm Item 1 ensures that the infer procedure can be invoked inside Fortran's do concurrent construct, which some compilers can offload automatically to graphics processing units (GPUs).  We envision this being useful in applications that require large numbers of independent inferences.  Item 2 exploits the special case where the number of neurons is uniform across the network layers.  The use of contiguous arrays facilitates spatial locality in memory access patterns.  Item 3 offers the possibility of adaptive inference method selection based on runtime information.  The current methods include ones based on intrinsic functions, dot_product or matmul .  Future options will explore the use of OpenMP and OpenACC for vectorization, multithreading, and/or accelerator offloading. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the examples in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"matmul_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: matmul_t Inherits type~~matmul_t~~InheritsGraph type~matmul_t matmul_t type~inference_strategy_t inference_strategy_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/matmul_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"outputs_t – Inference-Engine ","text":"type, public :: outputs_t Contents Variables outputs outputs_ pre_activation_in_ pre_activation_out_ Constructor outputs_t Components Type Visibility Attributes Name Initial procedure, public :: outputs real(kind=rkind), private, allocatable :: outputs_ (:) network outputs real(kind=rkind), private, allocatable :: pre_activation_in_ (:,:) weighted & biased hidden-layer inputs for training real(kind=rkind), private, allocatable :: pre_activation_out_ (:) weighted & biased output for training Constructor public interface outputs_t private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t )","tags":"","loc":"type/outputs_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~step_t step_t type~step_t->type~activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/sigmoid_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bias_ next weights_ Constructor neuron_t Type-Bound Procedures bias next_allocated next_pointer num_inputs weights Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer procedure, public :: num_inputs interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/step_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables neuron next Constructor layer_t Type-Bound Procedures count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target Type-Bound Procedures procedure, public :: count_layers interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) procedure, public :: hidden_biases interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: hidden_weights interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) procedure, public :: input_weights interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: neurons_per_layer interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer procedure, public :: output_biases interface private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) procedure, public :: output_weights interface private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:)","tags":"","loc":"type/layer_t.html"},{"title":"inference_strategy_t – Inference-Engine ","text":"type, public, abstract :: inference_strategy_t Inherited by type~~inference_strategy_t~~InheritedByGraph type~inference_strategy_t inference_strategy_t type~matmul_t matmul_t type~matmul_t->type~inference_strategy_t type~concurrent_dot_products_t concurrent_dot_products_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure( infer_interface ), public, deferred, nopass :: infer pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/inference_strategy_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ hidden_weights_ input_weights_ metadata_ output_biases_ output_weights_ Constructor inference_engine_t Type-Bound Procedures activation_function_name assert_conformable_with infer neurons_per_layer norm num_hidden_layers num_inputs num_outputs operator(-) skip to_json infer_from_array_of_inputs infer_from_inputs_object subtract Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) real(kind=rkind), private, allocatable :: input_weights_ (:,:) type(string_t), private :: metadata_ (size(key)) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor public interface inference_engine_t private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine generic, public :: infer => infer_from_array_of_inputs , infer_from_inputs_object private interface infer_from_array_of_inputs () Arguments None private interface infer_from_inputs_object () Arguments None procedure, public :: neurons_per_layer interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: num_hidden_layers interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: skip interface private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: infer_from_array_of_inputs interface private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) procedure, private :: infer_from_inputs_object interface private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) procedure, private :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"concurrent_dot_products_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Inherits type~~concurrent_dot_products_t~~InheritsGraph type~concurrent_dot_products_t concurrent_dot_products_t type~inference_strategy_t inference_strategy_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"type/concurrent_dot_products_t.html"},{"title":"inputs_t – Inference-Engine ","text":"type, public :: inputs_t Contents Variables inputs_ Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: inputs_ (:)","tags":"","loc":"type/inputs_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/swish_t.html"},{"title":"activation_i – Inference-Engine","text":"abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"infer_interface – Inference-Engine","text":"abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer_interface.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer.html"},{"title":"outputs_t – Inference-Engine","text":"public interface outputs_t Contents Functions construct_from_compoents Functions private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t )","tags":"","loc":"interface/outputs_t.html"},{"title":"outputs – Inference-Engine","text":"interface Calls interface~~outputs~~CallsGraph interface~outputs outputs proc~outputs outputs interface~outputs->proc~outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function outputs(self) result(output_values) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/outputs.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~~CallsGraph interface~activation_derivative activation_derivative proc~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Contents Functions construct Functions private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface Calls interface~~bias~~CallsGraph interface~bias bias proc~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~~CallsGraph interface~next_allocated next_allocated proc~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~~CallsGraph interface~next_pointer next_pointer proc~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"weights – Inference-Engine","text":"interface Calls interface~~weights~~CallsGraph interface~weights weights proc~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"assert_consistent – Inference-Engine","text":"pure subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent proc~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object->proc~assert_consistent proc~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2->proc~assert_consistent proc~num_hidden_layers num_hidden_layers proc~num_hidden_layers->proc~assert_consistent proc~num_inputs~2 num_inputs proc~num_inputs~2->proc~assert_consistent proc~norm norm proc~norm->proc~assert_consistent proc~num_outputs num_outputs proc~num_outputs->proc~assert_consistent proc~to_json to_json proc~to_json->proc~assert_consistent proc~construct_from_json construct_from_json proc~construct_from_json->proc~assert_consistent proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->proc~assert_consistent proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs->proc~assert_consistent proc~subtract subtract proc~subtract->proc~assert_consistent proc~construct_from_components construct_from_components proc~construct_from_components->proc~assert_consistent interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~to_json to_json interface~to_json->proc~to_json interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs interface~subtract subtract interface~subtract->proc~subtract interface~norm norm interface~norm->proc~norm interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~2~~CallsGraph interface~activation~2 activation proc~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Contents Functions construct Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target","tags":"","loc":"interface/layer_t.html"},{"title":"count_layers – Inference-Engine","text":"interface Calls interface~~count_layers~~CallsGraph interface~count_layers count_layers proc~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Calls interface~~count_neurons~~CallsGraph interface~count_neurons count_neurons proc~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"interface Calls interface~~hidden_biases~~CallsGraph interface~hidden_biases hidden_biases proc~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"interface Calls interface~~hidden_weights~~CallsGraph interface~hidden_weights hidden_weights proc~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:)","tags":"","loc":"interface/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"interface Calls interface~~input_weights~~CallsGraph interface~input_weights input_weights proc~input_weights input_weights interface~input_weights->proc~input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~2~~CallsGraph interface~next_allocated~2 next_allocated proc~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~2~~CallsGraph interface~next_pointer~2 next_pointer proc~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"output_biases – Inference-Engine","text":"interface Calls interface~~output_biases~~CallsGraph interface~output_biases output_biases proc~output_biases output_biases interface~output_biases->proc~output_biases assert assert proc~output_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/output_biases.html"},{"title":"output_weights – Inference-Engine","text":"interface Calls interface~~output_weights~~CallsGraph interface~output_weights output_weights proc~output_weights output_weights interface~output_weights->proc~output_weights assert assert proc~output_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/output_weights.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct_from_components construct_from_json Functions private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Calls interface~~activation_function_name~~CallsGraph interface~activation_function_name activation_function_name proc~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface Calls interface~~assert_conformable_with~~CallsGraph interface~assert_conformable_with assert_conformable_with proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with proc~assert_consistent assert_consistent proc~assert_conformable_with->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t assert assert proc~assert_conformable_with->assert proc~assert_consistent->intrinsic_array_t proc~assert_consistent->assert num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"interface Calls interface~~infer_from_array_of_inputs~~CallsGraph interface~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs proc~assert_consistent assert_consistent proc~infer_from_array_of_inputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t )","tags":"","loc":"interface/infer_from_array_of_inputs.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"interface Calls interface~~infer_from_inputs_object~~CallsGraph interface~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object proc~assert_consistent assert_consistent proc~infer_from_inputs_object->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t )","tags":"","loc":"interface/infer_from_inputs_object.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~2~~CallsGraph interface~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 proc~assert_consistent assert_consistent proc~neurons_per_layer~2->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer~2.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm proc~assert_consistent assert_consistent proc~norm->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"interface Calls interface~~num_hidden_layers~~CallsGraph interface~num_hidden_layers num_hidden_layers proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers proc~assert_consistent assert_consistent proc~num_hidden_layers->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~2~~CallsGraph interface~num_inputs~2 num_inputs proc~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 proc~assert_consistent assert_consistent proc~num_inputs~2->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs proc~assert_consistent assert_consistent proc~num_outputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"skip – Inference-Engine","text":"interface Calls interface~~skip~~CallsGraph interface~skip skip proc~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract proc~assert_consistent assert_consistent proc~subtract->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~~CallsGraph interface~to_json to_json proc~to_json to_json interface~to_json->proc~to_json proc~assert_consistent assert_consistent proc~to_json->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t separated_values separated_values proc~to_json->separated_values string_t string_t proc~to_json->string_t assert assert proc~to_json->assert file_t file_t proc~to_json->file_t proc~assert_consistent->intrinsic_array_t proc~assert_consistent->assert num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"interface/infer~2.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~3~~CallsGraph interface~activation~3 activation proc~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~2~~CallsGraph interface~activation_derivative~2 activation_derivative proc~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"netCDF_read – Inference-Engine","text":"subroutine netCDF_read(file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) Calls proc~~netcdf_read~~CallsGraph proc~netcdf_read netCDF_read nf90_strerror nf90_strerror proc~netcdf_read->nf90_strerror data_in_shape data_in_shape proc~netcdf_read->data_in_shape assert assert proc~netcdf_read->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_read~~CalledByGraph proc~netcdf_read netCDF_read program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_read.html"},{"title":"netCDF_write – Inference-Engine","text":"subroutine netCDF_write(file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Calls proc~~netcdf_write~~CallsGraph proc~netcdf_write netCDF_write nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror assert assert proc~netcdf_write->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_write~~CalledByGraph proc~netcdf_write netCDF_write program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_write.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer string_t string_t proc~write_read_query_infer->string_t file_t file_t proc~write_read_query_infer->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_query_infer Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( outputs_t ) network_outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & metadata = [ string_t ( \"XOR\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-02-18\" ), string_t ( \"step\" ), string_t ( \"false\" )], & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ] & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"number of hidden layers:\" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer:\" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ([ real ( rkind ) :: 0. , 1. ], matmul_t ()) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % outputs () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~3~~CalledByGraph proc~activation~3 activation interface~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~2~~CalledByGraph proc~activation_derivative~2 activation_derivative interface~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"construct_from_compoents – Inference-Engine","text":"module procedure construct_from_compoents module procedure construct_from_compoents() Arguments None Contents None","tags":"","loc":"proc/construct_from_compoents.html"},{"title":"outputs – Inference-Engine","text":"module procedure outputs pure module module function outputs(self) result(output_values) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~outputs~~CalledByGraph proc~outputs outputs interface~outputs outputs interface~outputs->proc~outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/outputs.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~~CalledByGraph proc~activation_derivative activation_derivative interface~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative.html"},{"title":"activation_function_name – Inference-Engine","text":"module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) Called by proc~~activation_function_name~~CalledByGraph proc~activation_function_name activation_function_name interface~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Calls proc~~assert_conformable_with~~CallsGraph proc~assert_conformable_with assert_conformable_with proc~assert_consistent assert_consistent proc~assert_conformable_with->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t assert assert proc~assert_conformable_with->assert proc~assert_consistent->intrinsic_array_t proc~assert_consistent->assert num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_conformable_with~~CalledByGraph proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_conformable_with.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components module procedure construct_from_components() Arguments None Calls proc~~construct_from_components~~CallsGraph proc~construct_from_components construct_from_components hidden_weights hidden_weights proc~construct_from_components->hidden_weights proc~assert_consistent assert_consistent proc~construct_from_components->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_components.html"},{"title":"construct_from_json – Inference-Engine","text":"module procedure construct_from_json module procedure construct_from_json() Arguments None Calls proc~~construct_from_json~~CallsGraph proc~construct_from_json construct_from_json assert assert proc~construct_from_json->assert string_t string_t proc~construct_from_json->string_t proc~assert_consistent assert_consistent proc~construct_from_json->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_json.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) Calls proc~~infer_from_array_of_inputs~~CallsGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~assert_consistent assert_consistent proc~infer_from_array_of_inputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_array_of_inputs~~CalledByGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_array_of_inputs.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) Calls proc~~infer_from_inputs_object~~CallsGraph proc~infer_from_inputs_object infer_from_inputs_object proc~assert_consistent assert_consistent proc~infer_from_inputs_object->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_inputs_object~~CalledByGraph proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_inputs_object.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~neurons_per_layer~2~~CallsGraph proc~neurons_per_layer~2 neurons_per_layer proc~assert_consistent assert_consistent proc~neurons_per_layer~2->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~neurons_per_layer~2~~CalledByGraph proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer~2.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) Calls proc~~norm~~CallsGraph proc~norm norm proc~assert_consistent assert_consistent proc~norm->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_hidden_layers~~CallsGraph proc~num_hidden_layers num_hidden_layers proc~assert_consistent assert_consistent proc~num_hidden_layers->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_hidden_layers~~CalledByGraph proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~2~~CallsGraph proc~num_inputs~2 num_inputs proc~assert_consistent assert_consistent proc~num_inputs~2->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~2~~CalledByGraph proc~num_inputs~2 num_inputs interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~2.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs proc~assert_consistent assert_consistent proc~num_outputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"skip – Inference-Engine","text":"module procedure skip elemental module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical Called by proc~~skip~~CalledByGraph proc~skip skip interface~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract proc~assert_consistent assert_consistent proc~subtract->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Calls proc~~to_json~~CallsGraph proc~to_json to_json proc~assert_consistent assert_consistent proc~to_json->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t separated_values separated_values proc~to_json->separated_values string_t string_t proc~to_json->string_t assert assert proc~to_json->assert file_t file_t proc~to_json->file_t proc~assert_consistent->intrinsic_array_t proc~assert_consistent->assert num_neurons num_neurons proc~assert_consistent->num_neurons output_count output_count proc~assert_consistent->output_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~~CalledByGraph proc~to_json to_json interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~2~~CalledByGraph proc~activation~2 activation interface~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~2.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~bias~~CalledByGraph proc~bias bias interface~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~~CallsGraph proc~construct construct neuron_lines neuron_lines proc~construct->neuron_lines assert assert proc~construct->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~~CalledByGraph proc~next_allocated next_allocated interface~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer Called by proc~~next_pointer~~CalledByGraph proc~next_pointer next_pointer interface~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~weights~~CalledByGraph proc~weights weights interface~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/weights.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~2~~CallsGraph proc~construct~2 construct layer_lines layer_lines proc~construct~2->layer_lines assert assert proc~construct~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer Called by proc~~count_layers~~CalledByGraph proc~count_layers count_layers interface~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:) Called by proc~~count_neurons~~CalledByGraph proc~count_neurons count_neurons interface~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~hidden_biases~~CallsGraph proc~hidden_biases hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_biases~~CalledByGraph proc~hidden_biases hidden_biases interface~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:) Calls proc~~hidden_weights~~CallsGraph proc~hidden_weights hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_weights~~CalledByGraph proc~hidden_weights hidden_weights interface~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~input_weights~~CallsGraph proc~input_weights input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_weights~~CalledByGraph proc~input_weights input_weights interface~input_weights input_weights interface~input_weights->proc~input_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~2~~CalledByGraph proc~next_allocated~2 next_allocated interface~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Called by proc~~next_pointer~2~~CalledByGraph proc~next_pointer~2 next_pointer interface~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer~2.html"},{"title":"output_biases – Inference-Engine","text":"module procedure output_biases module module function output_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:) Calls proc~~output_biases~~CallsGraph proc~output_biases output_biases assert assert proc~output_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~output_biases~~CalledByGraph proc~output_biases output_biases interface~output_biases output_biases interface~output_biases->proc~output_biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output_biases.html"},{"title":"output_weights – Inference-Engine","text":"module procedure output_weights module module function output_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~output_weights~~CallsGraph proc~output_weights output_weights assert assert proc~output_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~output_weights~~CalledByGraph proc~output_weights output_weights interface~output_weights output_weights interface~output_weights->proc~output_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/output_weights.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"matmul_m – Inference-Engine","text":"Perform inference using the matrix multiplication intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses activation_strategy_m inference_strategy_m outputs_m kind_parameters_m module~~matmul_m~~UsesGraph module~matmul_m matmul_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: matmul_s module~~matmul_m~~UsedByGraph module~matmul_m matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~matmul_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~matmul_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m program~read_json read_json program~read_json->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types matmul_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, extends( inference_strategy_t ) :: matmul_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/matmul_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m swish_m module~swish_m->module~differentiable_activation_strategy_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types differentiable_activation_strategy_t Derived Types type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(activation_i), public, nopass :: activation_derivative","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"outputs_m – Inference-Engine","text":"Uses kind_parameters_m module~~outputs_m~~UsesGraph module~outputs_m outputs_m module~kind_parameters_m kind_parameters_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: outputs_s module~~outputs_m~~UsedByGraph module~outputs_m outputs_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~outputs_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~outputs_m module~inference_engine_m inference_engine_m program~icar_qr_network->module~inference_engine_m module~matmul_m matmul_m program~icar_qr_network->module~matmul_m module~inference_engine_m->module~outputs_m module~inference_engine_m->module~inference_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~outputs_m program~write_read_infer->module~inference_engine_m program~write_read_infer->module~matmul_m module~inference_strategy_m->module~outputs_m module~matmul_m->module~outputs_m module~matmul_m->module~inference_strategy_m module~outputs_s outputs_s module~outputs_s->module~outputs_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~read_json read_json program~read_json->module~inference_engine_m program~read_json->module~matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces outputs_t outputs Derived Types outputs_t Interfaces public interface outputs_t private pure module function construct_from_compoents(outputs, pre_activation_in, pre_activation_out) result(new_outputs_t) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: outputs (:) real(kind=rkind), intent(in) :: pre_activation_in (:,:) real(kind=rkind), intent(in) :: pre_activation_out (:) Return Value type( outputs_t ) interface private pure module module function outputs(self) result(output_values) Implementation → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: outputs_t Components Type Visibility Attributes Name Initial procedure, public :: outputs real(kind=rkind), private, allocatable :: outputs_ (:) network outputs real(kind=rkind), private, allocatable :: pre_activation_in_ (:,:) weighted & biased hidden-layer inputs for training real(kind=rkind), private, allocatable :: pre_activation_out_ (:) weighted & biased output for training Constructor private pure,module function construct_from_compoents (outputs, pre_activation_in, pre_activation_out)","tags":"","loc":"module/outputs_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses kind_parameters_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~step_m->module~activation_strategy_m module~matmul_m matmul_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m program~icar_qr_network->module~matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~step_m module~inference_engine_s->module~matmul_m module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m module~swish_m swish_m module~inference_engine_s->module~swish_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~sigmoid_m->module~differentiable_activation_strategy_m program~read_json read_json program~read_json->module~inference_engine_m program~read_json->module~matmul_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~write_read_infer->module~step_m program~write_read_infer->module~matmul_m module~step_s step_s module~step_s->module~step_m module~swish_m->module~differentiable_activation_strategy_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_i Derived Types activation_strategy_t Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation","tags":"","loc":"module/activation_strategy_m.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative Derived Types sigmoid_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative","tags":"","loc":"module/sigmoid_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses string_m kind_parameters_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces neuron_t bias next_allocated next_pointer num_inputs weights Derived Types neuron_t Interfaces public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private pure,recursive,module function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~inputs_m inputs_m module~inputs_m->module~kind_parameters_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~kind_parameters_m module~outputs_m outputs_m module~concurrent_dot_products_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~outputs_m->module~kind_parameters_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~kind_parameters_m program~icar_qr_network->module~outputs_m module~matmul_m matmul_m program~icar_qr_network->module~matmul_m module~inference_engine_m inference_engine_m program~icar_qr_network->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m module~neuron_m->module~kind_parameters_m module~step_m step_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~outputs_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~swish_m swish_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~outputs_m program~write_read_infer->module~matmul_m program~write_read_infer->module~step_m program~write_read_infer->module~inference_engine_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_s->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~layer_m module~inference_engine_s->module~matmul_m module~inference_engine_s->module~neuron_m module~inference_engine_s->module~step_m module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~swish_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~outputs_s outputs_s module~outputs_s->module~outputs_m module~differentiable_activation_strategy_m->module~activation_strategy_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"step_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~step_m module~step_s step_s module~step_s->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation","tags":"","loc":"module/step_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses string_m neuron_m kind_parameters_m module~~layer_m~~UsesGraph module~layer_m layer_m string_m string_m module~layer_m->string_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->string_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces layer_t count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Derived Types layer_t Interfaces public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer interface private module module function output_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) interface private module module function output_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private recursive,module function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: hidden_biases procedure, public :: hidden_weights procedure, public :: input_weights procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: output_biases procedure, public :: output_weights","tags":"","loc":"module/layer_m.html"},{"title":"inference_strategy_m – Inference-Engine","text":"Uses activation_strategy_m outputs_m kind_parameters_m module~~inference_strategy_m~~UsesGraph module~inference_strategy_m inference_strategy_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~outputs_m outputs_m module~inference_strategy_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_strategy_m~~UsedByGraph module~inference_strategy_m inference_strategy_m module~matmul_m matmul_m module~matmul_m->module~inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~matmul_m module~inference_engine_s->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~matmul_m program~icar_qr_network->module~inference_engine_m module~matmul_s matmul_s module~matmul_s->module~matmul_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces infer_interface Derived Types inference_strategy_t Abstract Interfaces abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, abstract :: inference_strategy_t Type-Bound Procedures procedure(infer_interface), public, nopass :: infer","tags":"","loc":"module/inference_strategy_m.html"},{"title":"inference_engine_m – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses activation_strategy_m inputs_m inference_strategy_m string_m file_m kind_parameters_m outputs_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m string_m string_m module~inference_engine_m->string_m module~outputs_m outputs_m module~inference_engine_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m file_m file_m module~inference_engine_m->file_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~inputs_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables key Interfaces inference_engine_t activation_function_name assert_conformable_with infer_from_array_of_inputs infer_from_inputs_object neurons_per_layer norm num_hidden_layers num_inputs num_outputs skip subtract to_json Derived Types inference_engine_t Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces public interface inference_engine_t private pure module function construct_from_components(metadata, input_weights, hidden_weights, output_weights, biases, output_biases) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) Return Value type( inference_engine_t ) private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) interface private elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) real(kind=rkind), private, allocatable :: input_weights_ (:,:) type(string_t), private :: metadata_ (size(key)) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor private pure,module function construct_from_components (metadata, input_weights, hidden_weights, output_weights, biases, output_biases) private impure,elemental,module function construct_from_json (file_) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with generic, public :: infer => infer_from_array_of_inputs, infer_from_inputs_object procedure, public :: neurons_per_layer procedure, public :: norm procedure, public :: num_hidden_layers procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: skip procedure, public :: to_json procedure, private :: infer_from_array_of_inputs procedure, private :: infer_from_inputs_object procedure, private :: subtract","tags":"","loc":"module/inference_engine_m.html"},{"title":"concurrent_dot_products_m – Inference-Engine","text":"Perform inference using the dot_product intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses activation_strategy_m inference_strategy_m outputs_m kind_parameters_m module~~concurrent_dot_products_m~~UsesGraph module~concurrent_dot_products_m concurrent_dot_products_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~outputs_m outputs_m module~concurrent_dot_products_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: concurrent_dot_products_s module~~concurrent_dot_products_m~~UsedByGraph module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types concurrent_dot_products_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t ) Derived Types type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/concurrent_dot_products_m.html"},{"title":"inputs_m – Inference-Engine","text":"Uses kind_parameters_m module~~inputs_m~~UsesGraph module~inputs_m inputs_m module~kind_parameters_m kind_parameters_m module~inputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inputs_m~~UsedByGraph module~inputs_m inputs_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inputs_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~icar_qr_network icar_qr_network program~icar_qr_network->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types inputs_t Derived Types type, public :: inputs_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: inputs_ (:)","tags":"","loc":"module/inputs_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m module~~swish_m~~UsesGraph module~swish_m swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative Derived Types swish_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative","tags":"","loc":"module/swish_m.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/swish_s.html"},{"title":"outputs_s – Inference-Engine","text":"Uses Ancestors: outputs_m module~~outputs_s~~UsesGraph module~outputs_s outputs_s module~outputs_m outputs_m module~outputs_s->module~outputs_m module~kind_parameters_m kind_parameters_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_compoents outputs Module Procedures module procedure construct_from_compoents module procedure construct_from_compoents() Arguments None module procedure outputs pure module module function outputs(self) result(output_values) Interface → Arguments Type Intent Optional Attributes Name class( outputs_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/outputs_s.html"},{"title":"matmul_s – Inference-Engine","text":"Uses Ancestors: matmul_m module~~matmul_s~~UsesGraph module~matmul_s matmul_s module~matmul_m matmul_m module~matmul_s->module~matmul_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"module/matmul_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/sigmoid_s.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses assert_m neuron_m intrinsic_array_m matmul_m sigmoid_m file_m swish_m formats_m step_m iso_fortran_env layer_m Ancestors: inference_engine_m module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s intrinsic_array_m intrinsic_array_m module~inference_engine_s->intrinsic_array_m module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m iso_fortran_env iso_fortran_env module~inference_engine_s->iso_fortran_env module~layer_m layer_m module~inference_engine_s->module~layer_m assert_m assert_m module~inference_engine_s->assert_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m module~matmul_m matmul_m module~inference_engine_s->module~matmul_m file_m file_m module~inference_engine_s->file_m module~swish_m swish_m module~inference_engine_s->module~swish_m formats_m formats_m module~inference_engine_s->formats_m module~step_m step_m module~inference_engine_s->module~step_m module~inference_engine_m inference_engine_m module~inference_engine_s->module~inference_engine_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~layer_m->module~neuron_m module~layer_m->module~kind_parameters_m string_m string_m module~layer_m->string_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~matmul_m->module~kind_parameters_m module~outputs_m outputs_m module~matmul_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m->file_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->string_m module~inference_engine_m->module~outputs_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~outputs_m->module~kind_parameters_m module~inputs_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines assert_consistent Module Procedures activation_function_name assert_conformable_with construct_from_components construct_from_json infer_from_array_of_inputs infer_from_inputs_object neurons_per_layer norm num_hidden_layers num_inputs num_outputs skip subtract to_json Subroutines pure subroutine assert_consistent (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Module Procedures module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine module procedure construct_from_components module procedure construct_from_components() Arguments None module procedure construct_from_json module procedure construct_from_json() Arguments None module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs, inference_strategy) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs class( inference_strategy_t ), intent(in) :: inference_strategy Return Value type( outputs_t ) module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure skip elemental module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/inference_engine_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/step_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bias construct next_allocated next_pointer num_inputs weights Module Procedures module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure construct module procedure construct() Arguments None module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses assert_m intrinsic_array_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s assert_m assert_m module~layer_s->assert_m intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m module~layer_m layer_m module~layer_s->module~layer_m string_m string_m module~layer_m->string_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->string_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer output_biases output_weights Module Procedures module procedure construct module procedure construct() Arguments None module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer module procedure output_biases module module function output_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:) module procedure output_weights module module function output_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:)","tags":"","loc":"module/layer_s.html"},{"title":"concurrent_dot_products_s – Inference-Engine","text":"Uses assert_m activation_strategy_m step_m Ancestors: concurrent_dot_products_m module~~concurrent_dot_products_s~~UsesGraph module~concurrent_dot_products_s concurrent_dot_products_s assert_m assert_m module~concurrent_dot_products_s->assert_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~outputs_m outputs_m module~concurrent_dot_products_m->module~outputs_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~outputs_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy, skip) result(outputs) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in) :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in) :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in) :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in) :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in) :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy logical, intent(in) :: skip Return Value type( outputs_t )","tags":"","loc":"module/concurrent_dot_products_s.html"},{"title":"read_json – Inference-Engine","text":"Uses inference_engine_m matmul_m command_line_m string_m file_m program~~read_json~~UsesGraph program~read_json read_json string_m string_m program~read_json->string_m command_line_m command_line_m program~read_json->command_line_m module~inference_engine_m inference_engine_m program~read_json->module~inference_engine_m file_m file_m program~read_json->file_m module~matmul_m matmul_m program~read_json->module~matmul_m module~inference_engine_m->string_m module~inference_engine_m->file_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~outputs_m outputs_m module~inference_engine_m->module~outputs_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~inputs_m->module~kind_parameters_m module~outputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~read_json~~CallsGraph program~read_json read_json string_t string_t program~read_json->string_t file_t file_t program~read_json->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name command_line inference_engine input_file_name Variables Type Attributes Name Initial type(string_t) :: activation_name type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/read_json.html"},{"title":"netCDF_IO – Inference-Engine","text":"Uses assert_m netcdf program~~netcdf_io~~UsesGraph program~netcdf_io netCDF_IO assert_m assert_m program~netcdf_io->assert_m netcdf netcdf program~netcdf_io->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~netcdf_io~~CallsGraph program~netcdf_io netCDF_IO proc~netcdf_write netCDF_write program~netcdf_io->proc~netcdf_write proc~netcdf_read netCDF_read program~netcdf_io->proc~netcdf_read assert assert program~netcdf_io->assert proc~netcdf_write->assert nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror proc~netcdf_read->assert proc~netcdf_read->nf90_strerror data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_read data_written file_name i j nx ny Functions get_shape Subroutines netCDF_read netCDF_write Source Code netCDF_IO Variables Type Attributes Name Initial integer, allocatable :: data_read (:,:) integer, parameter :: data_written (*,*) = reshape([((i*j, i=1, nx), j=1, ny)], [ny, nx]) character(len=*), parameter :: file_name = \"netCDF_example.nc\" integer :: i integer :: j integer, parameter :: nx = 6 integer, parameter :: ny = 12 Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Subroutines subroutine netCDF_read (file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) subroutine netCDF_write (file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Source Code program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"program/netcdf_io.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses inference_engine_m matmul_m command_line_m string_m file_m step_m kind_parameters_m outputs_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer string_m string_m program~write_read_infer->string_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m command_line_m command_line_m program~write_read_infer->command_line_m module~outputs_m outputs_m program~write_read_infer->module~outputs_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m file_m file_m program~write_read_infer->file_m module~matmul_m matmul_m program~write_read_infer->module~matmul_m module~step_m step_m program~write_read_infer->module~step_m module~outputs_m->module~kind_parameters_m module~inference_engine_m->string_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~outputs_m module~inference_engine_m->file_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer string_t string_t program~write_read_infer->string_t proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer proc~write_read_query_infer->string_t file_t file_t proc~write_read_query_infer->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line file_name Subroutines write_read_query_infer Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"icar_qr_network – Inference-Engine","text":"Uses inference_engine_m matmul_m command_line_m string_m file_m kind_parameters_m outputs_m program~~icar_qr_network~~UsesGraph program~icar_qr_network icar_qr_network string_m string_m program~icar_qr_network->string_m module~kind_parameters_m kind_parameters_m program~icar_qr_network->module~kind_parameters_m command_line_m command_line_m program~icar_qr_network->command_line_m module~outputs_m outputs_m program~icar_qr_network->module~outputs_m module~inference_engine_m inference_engine_m program~icar_qr_network->module~inference_engine_m file_m file_m program~icar_qr_network->file_m module~matmul_m matmul_m program~icar_qr_network->module~matmul_m module~outputs_m->module~kind_parameters_m module~inference_engine_m->string_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~outputs_m module~inference_engine_m->file_m module~inputs_m inputs_m module~inference_engine_m->module~inputs_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~outputs_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~inputs_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~outputs_m module~inference_strategy_m->module~activation_strategy_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~icar_qr_network~~CallsGraph program~icar_qr_network icar_qr_network string_t string_t program~icar_qr_network->string_t file_t file_t program~icar_qr_network->file_t inputs inputs program~icar_qr_network->inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name command_line inference_engine input_file_name Variables Type Attributes Name Initial type(string_t) :: activation_name type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/icar_qr_network.html"},{"title":"matmul_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_m.f90~~EfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~matmul_m.f90~~AfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules matmul_m Source Code matmul_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matmul_m !! Perform inference using the matrix multiplication intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: matmul_t type , extends ( inference_strategy_t ) :: matmul_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module matmul_m","tags":"","loc":"sourcefile/matmul_m.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules swish_s Source Code swish_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules differentiable_activation_strategy_m Source Code differentiable_activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"outputs_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~outputs_m.f90~~EfferentGraph sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~outputs_m.f90~~AfferentGraph sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules outputs_m Source Code outputs_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module outputs_m use kind_parameters_m , only : rkind implicit none private public :: outputs_t type outputs_t private real ( rkind ), allocatable :: outputs_ (:) !! network outputs real ( rkind ), allocatable :: pre_activation_in_ (:,:) !! weighted & biased hidden-layer inputs for training real ( rkind ), allocatable :: pre_activation_out_ (:) !! weighted & biased output for training contains procedure outputs end type interface outputs_t pure module function construct_from_compoents ( outputs , pre_activation_in , pre_activation_out ) result ( new_outputs_t ) implicit none real ( rkind ), intent ( in ) :: outputs (:) real ( rkind ), intent ( in ) :: pre_activation_in (:,:), pre_activation_out (:) type ( outputs_t ) new_outputs_t end function end interface interface pure module function outputs ( self ) result ( output_values ) implicit none class ( outputs_t ), intent ( in ) :: self real ( rkind ), allocatable :: output_values (:) end function end interface end module outputs_m","tags":"","loc":"sourcefile/outputs_m.f90.html"},{"title":"outputs_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~outputs_s.f90~~EfferentGraph sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules outputs_s Source Code outputs_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( outputs_m ) outputs_s implicit none contains module procedure outputs output_values = self % outputs_ end procedure module procedure construct_from_compoents new_outputs_t % outputs_ = outputs new_outputs_t % pre_activation_in_ = pre_activation_in new_outputs_t % pre_activation_out_ = pre_activation_out end procedure end submodule outputs_s","tags":"","loc":"sourcefile/outputs_s.f90.html"},{"title":"matmul_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_s.f90~~EfferentGraph sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules matmul_s Source Code matmul_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matmul_m ) matmul_s implicit none contains module procedure infer real ( rkind ), allocatable , dimension (:,:) :: neuron , pre_activation_in real ( rkind ), allocatable , dimension (:) :: pre_activation_out associate ( num_layers => size ( biases , 2 )) associate ( neurons_per_layer => size ( input_weights , 1 )) allocate ( neuron ( neurons_per_layer , num_layers )) allocate ( pre_activation_in , mold = neuron ) end associate block integer , parameter :: input_layer = 1 pre_activation_in (:, input_layer ) = matmul ( input_weights (:,:), input (:)) + biases (:, input_layer ) neuron (:, input_layer ) = activation_strategy % activation ( pre_activation_in (:, input_layer )) end block block integer layer if ( skip ) then do layer = 2 , num_layers pre_activation_in (:, layer ) = matmul ( hidden_weights (:,:, layer - 1 ), neuron (:, layer - 1 )) + biases (:, layer ) neuron (:, layer ) = neuron (:, layer - 1 ) + activation_strategy % activation ( pre_activation_in (:, layer )) end do else do layer = 2 , num_layers pre_activation_in (:, layer ) = matmul ( hidden_weights (:,:, layer - 1 ), neuron (:, layer - 1 )) + biases (:, layer ) neuron (:, layer ) = activation_strategy % activation ( pre_activation_in (:, layer )) end do end if end block pre_activation_out = matmul ( output_weights (:,:), neuron (:, num_layers )) + output_biases (:) outputs = outputs_t ( activation_strategy % activation ( pre_activation_out ), pre_activation_in , pre_activation_out ) end associate end procedure end submodule matmul_s","tags":"","loc":"sourcefile/matmul_s.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m use kind_parameters_m , only : rkind implicit none private public :: activation_strategy_t public :: activation_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sigmoid_m Source Code sigmoid_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules sigmoid_s Source Code sigmoid_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules neuron_m Source Code neuron_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~kind_parameters_m.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~outputs_s.f90 outputs_s.f90 sourcefile~outputs_s.f90->sourcefile~outputs_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kind_parameters_m Source Code kind_parameters_m.f90 Source Code module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m ) inference_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use matmul_m , only : matmul_t use step_m , only : step_t use swish_m , only : swish_t use sigmoid_m , only : sigmoid_t use layer_m , only : layer_t use neuron_m , only : neuron_t use file_m , only : file_t use formats_m , only : separated_values use iso_fortran_env , only : iostat_end implicit none contains module procedure construct_from_components real ( rkind ), allocatable :: transposed (:,:,:) integer layer allocate ( transposed ( size ( hidden_weights , 2 ), size ( hidden_weights , 1 ), size ( hidden_weights , 3 ))) do concurrent ( layer = 1 : size ( hidden_weights , 3 )) transposed (:,:, layer ) = transpose ( hidden_weights (:,:, layer )) end do inference_engine % metadata_ = metadata inference_engine % input_weights_ = transpose ( input_weights ) inference_engine % hidden_weights_ = transposed inference_engine % output_weights_ = output_weights inference_engine % biases_ = biases inference_engine % output_biases_ = output_biases ! This code is repeated in both constructors and needs to be maintained consistently in both ! places.  It can't be factored into one factory method pattern because the result would need ! to be allocatable and polymorphic, which would preclude the function being pure so it ! wouldn't be possible to call it from inside this pure constructor function. select case ( inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string ()) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case default error stop \"inference_engine_t construct_from_components: unrecognized activation strategy\" end select call assert_consistent ( inference_engine ) end procedure module procedure construct_from_json type ( string_t ), allocatable :: lines (:) type ( layer_t ) hidden_layers , output_layer type ( neuron_t ) output_neuron real ( rkind ), allocatable :: hidden_weights (:,:,:) integer l lines = file_ % lines () l = 1 call assert ( adjustl ( lines ( l )% string ()) == \"{\" , \"construct_from_json: expecting '{' to start outermost object\" , lines ( l )% string ()) l = 2 inference_engine % metadata_ = [ string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"false\" )] if ( adjustl ( lines ( l )% string ()) == '\"metadata\": {' ) then block character ( len = :), allocatable :: justified_line do l = l + 1 justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == \"},\" ) exit inference_engine % metadata_ ( findloc ( key , trim ( get_key_string ( justified_line )), dim = 1 )) = get_key_value ( justified_line ) end do l = l + 1 end block end if call assert ( adjustl ( lines ( l )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( l )% string ()) l = l + 1 block integer , parameter :: lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l ) associate ( output_layer_line_number => l + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end block inference_engine % input_weights_ = transpose ( hidden_layers % input_weights ()) call assert ( hidden_layers % next_allocated (), \"inference_engine_t%from_json: next layer exists\" ) block type ( layer_t ), pointer :: next_layer real ( rkind ), allocatable :: transposed (:,:,:) integer layer next_layer => hidden_layers % next_pointer () hidden_weights = next_layer % hidden_weights () inference_engine % biases_ = hidden_layers % hidden_biases () allocate ( transposed ( size ( hidden_weights , 2 ), size ( hidden_weights , 1 ), size ( hidden_weights , 3 ))) do concurrent ( layer = 1 : size ( hidden_weights , 3 )) transposed (:,:, layer ) = transpose ( hidden_weights (:,:, layer )) end do inference_engine % hidden_weights_ = transposed end block inference_engine % output_weights_ = output_layer % output_weights () inference_engine % output_biases_ = output_layer % output_biases () select case ( inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string ()) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case default error stop \"inference_engine_t construct_from_json: unrecognized activation strategy\" end select call assert_consistent ( inference_engine ) contains pure function get_key_string ( line ) result ( unquoted_key ) character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: unquoted_key associate ( opening_key_quotes => index ( line , '\"' ), separator => index ( line , ':' )) associate ( closing_key_quotes => opening_key_quotes + index ( line ( opening_key_quotes + 1 :), '\"' )) unquoted_key = trim ( line ( opening_key_quotes + 1 : closing_key_quotes - 1 )) end associate end associate end function function get_key_value ( line ) result ( value_ ) character ( len =* ), intent ( in ) :: line type ( string_t ) value_ associate ( text_after_colon => line ( index ( line , ':' ) + 1 :)) associate ( opening_value_quotes => index ( text_after_colon , '\"' )) associate ( closing_value_quotes => opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' )) if ( any ([ opening_value_quotes , closing_value_quotes ] == 0 )) then value_ = string_t ( trim ( adjustl (( text_after_colon )))) else value_ = string_t ( text_after_colon ( opening_value_quotes + 1 : closing_value_quotes - 1 )) end if end associate end associate end associate end function end procedure construct_from_json module procedure assert_conformable_with call assert_consistent ( self ) call assert_consistent ( inference_engine ) associate ( equal_shapes => [ & shape ( self % input_weights_ ) == shape ( inference_engine % input_weights_ ), & shape ( self % hidden_weights_ ) == shape ( inference_engine % hidden_weights_ ), & shape ( self % output_weights_ ) == shape ( inference_engine % output_weights_ ), & shape ( self % biases_ ) == shape ( inference_engine % biases_ ), & shape ( self % output_biases_ ) == shape ( inference_engine % output_biases_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( same_type_as ( self % activation_strategy_ , inference_engine % activation_strategy_ ), \"assert_conformable_with: types)\" ) end procedure module procedure subtract call self % assert_conformable_with ( rhs ) difference % metadata_ = self % metadata_ difference % input_weights_ = self % input_weights_ - rhs % input_weights_ difference % hidden_weights_ = self % hidden_weights_ - rhs % hidden_weights_ difference % output_weights_ = self % output_weights_ - rhs % output_weights_ difference % biases_ = self % biases_ - rhs % biases_ difference % output_biases_ = self % output_biases_ - rhs % output_biases_ difference % activation_strategy_ = self % activation_strategy_ call assert_consistent ( difference ) end procedure module procedure norm call assert_consistent ( self ) norm_of_self = maxval ( abs ( self % input_weights_ )) + maxval ( abs ( self % hidden_weights_ )) + maxval ( abs ( self % output_weights_ )) + & maxval ( abs ( self % biases_ )) + maxval ( abs ( self % output_biases_ )) end procedure pure subroutine assert_consistent ( self ) type ( inference_engine_t ), intent ( in ) :: self call assert ( all ( self % metadata_ % is_allocated ()), \"inference_engine_t%assert_consistent: self%metadata_s%is_allocated()\" ) call assert ( allocated ( self % activation_strategy_ ), \"inference_engine_t%assert_consistent: allocated(self%activation_strategy_)\" ) associate ( allocated_components => & [ allocated ( self % input_weights_ ), allocated ( self % hidden_weights_ ), allocated ( self % output_weights_ ), & allocated ( self % biases_ ), allocated ( self % output_biases_ )] & ) call assert ( all ( allocated_components ), \"inference_engine_s(assert_consistent): fully allocated object\" , & intrinsic_array_t ( allocated_components )) end associate associate ( num_neurons => 1 + & [ ubound ( self % biases_ , 1 ) - lbound ( self % biases_ , 1 ), & ubound ( self % hidden_weights_ , 1 ) - lbound ( self % hidden_weights_ , 1 ), & ubound ( self % hidden_weights_ , 2 ) - lbound ( self % hidden_weights_ , 2 ), & ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ), & ubound ( self % output_weights_ , 2 ) - lbound ( self % output_weights_ , 2 ) & ] ) call assert ( all ( num_neurons == num_neurons ( 1 )), \"inference_engine_s(assert_consistent): num_neurons\" , & intrinsic_array_t ( num_neurons ) & ) end associate associate ( output_count => 1 + & [ ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ), & ubound ( self % output_biases_ , 1 ) - lbound ( self % output_biases_ , 1 ) & ] ) call assert ( all ( output_count == output_count ( 1 )), \"inference_engine_s(assert_consistent): output_count\" , & intrinsic_array_t ( output_count ) & ) end associate end subroutine module procedure num_outputs call assert_consistent ( self ) output_count = ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ) + 1 end procedure module procedure num_inputs call assert_consistent ( self ) input_count = ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ) + 1 end procedure module procedure neurons_per_layer call assert_consistent ( self ) neuron_count = ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ) + 1 end procedure module procedure num_hidden_layers call assert_consistent ( self ) hidden_layer_count = ubound ( self % hidden_weights_ , 3 ) - lbound ( self % hidden_weights_ , 3 ) + 1 end procedure module procedure infer_from_array_of_inputs integer layer call assert_consistent ( self ) outputs = inference_strategy % infer ( & input = input , & input_weights = self % input_weights_ , & hidden_weights = self % hidden_weights_ , & biases = self % biases_ , & output_biases = self % output_biases_ , & output_weights = self % output_weights_ , & activation_strategy = self % activation_strategy_ , & skip = self % skip () & ) end procedure module procedure infer_from_inputs_object integer layer call assert_consistent ( self ) outputs = inference_strategy % infer ( & input = inputs % inputs_ , & input_weights = self % input_weights_ , & hidden_weights = self % hidden_weights_ , & biases = self % biases_ , & output_biases = self % output_biases_ , & output_weights = self % output_weights_ , & activation_strategy = self % activation_strategy_ , & skip = self % skip () & ) end procedure module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , metadata_outer_braces = 2 call assert_consistent ( self ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => self % num_hidden_layers (), neurons_per_layer => self % neurons_per_layer (), & num_outputs => self % num_outputs (), num_inputs => self % num_inputs ()) associate ( num_lines => & outer_object_braces & + metadata_outer_braces + size ( key ) & + hidden_layer_outer_brackets + ( num_hidden_layers + 1 ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '    \"metadata\": {' ) line = line + 1 lines ( line ) = string_t ( '        \"modelName\": \"' // & self % metadata_ ( findloc ( key , \"modelName\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"modelAuthor\": \"' // & self % metadata_ ( findloc ( key , \"modelAuthor\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"compilationDate\": \"' // & self % metadata_ ( findloc ( key , \"compilationDate\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"activationFunction\": \"' // & self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"usingSkipConnections\": ' // & self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string ()) line = line + 1 lines ( line ) = string_t ( '    },' ) line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % input_weights_ ( neuron ,:) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ],\" , \"         ] \" , line /= num_hidden_layers + 1 ))) do layer = 1 , num_hidden_layers line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % hidden_weights_ (:, neuron , layer ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % output_weights_ ( neuron ,:) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % output_biases_ ( neuron ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" ) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure skip use_skip_connections = self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string () == \"true\" end procedure module procedure activation_function_name activation_name = self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 )) end procedure end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules neuron_s Source Code neuron_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"read_json: neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"read_json: neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"read_json: neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"read_json: neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules layer_s Source Code layer_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_t construct: layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer = [ neurons_per_layer , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure input_weights type ( neuron_t ), pointer :: neuron integer i associate ( num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer ()) allocate ( weights ( num_inputs , neurons_per_layer )) neuron => self % neuron weights (:, 1 ) = neuron % weights () do i = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%input_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, i ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%input_weights: constant number of inputs\" ) end do neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%input_weights: .not. neuron%next_allocated()\" ) if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer ) = neuron % weights () end associate end procedure module procedure hidden_weights type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( & num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( weights ( num_inputs , neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron weights (:, 1 , l ) = neuron % weights () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, n , l ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%hidden_weights: constant number of inputs\" , & intrinsic_array_t ([ num_inputs , neuron % num_inputs (), l , n ])) end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer , l ) = neuron % weights () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_weights: .not. layer%next_allocated()\" ) end if end do loop_over_Layers end associate end procedure module procedure output_weights type ( neuron_t ), pointer :: neuron integer n associate ( num_outputs => self % neurons_per_layer (), neurons_per_hidden_layer => self % neuron % num_inputs ()) neuron => self % neuron allocate ( weights ( num_outputs , neurons_per_hidden_layer )) weights ( 1 ,:) = neuron % weights () loop_over_output_neurons : & do n = 2 , num_outputs - 1 call assert ( neuron % next_allocated (), \"layer_t%output_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights ( n ,:) = neuron % weights () call assert ( neuron % num_inputs () == neurons_per_hidden_layer , \"layer_t%output_weights: constant number of inputs\" ) end do loop_over_output_neurons if ( num_outputs > 1 ) then call assert ( neuron % next_allocated (), \"layer_t%output_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights ( num_outputs ,:) = neuron % weights () ! avoid redundant assignment call assert (. not . self % next_allocated (), \"layer_t%output_weights: .not. layer%next_allocated()\" ) end if end associate end procedure module procedure output_biases type ( neuron_t ), pointer :: neuron integer n associate ( num_outputs => self % neurons_per_layer ()) neuron => self % neuron allocate ( biases ( num_outputs )) biases ( 1 ) = neuron % bias () loop_over_output_neurons : & do n = 2 , num_outputs - 1 call assert ( neuron % next_allocated (), \"layer_t%output_biases: neuron%next_allocated()\" ) neuron => neuron % next_pointer () biases ( n ) = neuron % bias () end do loop_over_output_neurons if ( num_outputs > 1 ) then call assert ( neuron % next_allocated (), \"layer_t%output_biases: neuron%next_allocated()\" ) neuron => neuron % next_pointer () biases ( num_outputs ) = neuron % bias () ! avoid redundant assignment call assert (. not . self % next_allocated (), \"layer_t%output_biases: .not. layer%next_allocated()\" ) end if end associate end procedure module procedure hidden_biases type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( biases ( neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron biases ( 1 , l ) = neuron % bias () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , intrinsic_array_t ([ l , n ])) neuron => neuron % next_pointer () biases ( n , l ) = neuron % bias () end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%hidden_biases: .not. neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) if ( neurons_per_layer /= 1 ) biases ( neurons_per_layer , l ) = neuron % bias () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_biases: .not. layer%next_allocated()\" ) end if end do loop_over_layers end associate end procedure hidden_biases module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"concurrent_dot_products_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_s.f90~~EfferentGraph sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules concurrent_dot_products_s Source Code concurrent_dot_products_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( concurrent_dot_products_m ) concurrent_dot_products_s use assert_m , only : assert use activation_strategy_m , only : activation_strategy_t use step_m , only : step_t implicit none contains module procedure infer integer n , layer , m integer , parameter :: input_layer = 1 real ( rkind ), allocatable :: neuron (:,:), output_values (:), pre_activation_in (:,:), pre_activation_out (:) associate ( neurons_per_layer => size ( input_weights , 1 ), num_layers => size ( biases , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) allocate ( pre_activation_in , mold = neuron ) do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , input_layer ) = dot_product ( input_weights ( n ,:), input (:)) + biases ( n , input_layer ) neuron ( n , input_layer ) = activation_strategy % activation ( pre_activation_in ( n , input_layer )) end do do layer = 2 , num_layers if ( skip ) then do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , layer ) = dot_product ( hidden_weights ( n ,:, layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer ) neuron ( n , layer ) = neuron ( n , layer - 1 ) + activation_strategy % activation ( pre_activation_in ( n , layer )) end do else do concurrent ( n = 1 : neurons_per_layer ) pre_activation_in ( n , layer ) = dot_product ( hidden_weights ( n ,:, layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer ) neuron ( n , layer ) = activation_strategy % activation ( pre_activation_in ( n , layer )) end do end if end do associate ( num_outputs => size ( output_weights , 1 )) allocate ( output_values ( num_outputs ), pre_activation_out ( num_outputs )) do concurrent ( m = 1 : num_outputs ) pre_activation_out ( m ) = dot_product ( output_weights ( m ,:), neuron (:, num_layers )) + output_biases ( m ) output_values ( m ) = activation_strategy % activation ( pre_activation_out ( m )) end do outputs = outputs_t ( output_values , pre_activation_in , pre_activation_out ) end associate end associate end procedure end submodule concurrent_dot_products_s","tags":"","loc":"sourcefile/concurrent_dot_products_s.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layer_m Source Code layer_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: count_layers procedure :: count_neurons procedure :: input_weights procedure :: hidden_weights procedure :: output_weights procedure :: output_biases procedure :: hidden_biases procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function input_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:) end function module function hidden_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:,:) end function module function output_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:) end function module function output_biases ( self ) result ( biases ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: biases (:) end function module function hidden_biases ( self ) result ( biases ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: biases (:,:) end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"inference_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_strategy_m.f90~~EfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_strategy_m.f90~~AfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_strategy_m Source Code inference_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_strategy_m use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: inference_strategy_t type , abstract :: inference_strategy_t contains procedure ( infer_interface ), nopass , deferred :: infer end type abstract interface pure function infer_interface ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) import activation_strategy_t , rkind , outputs_t implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module inference_strategy_m","tags":"","loc":"sourcefile/inference_strategy_m.f90.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Define an abstraction that supports inference operationsn on a neural network use string_m , only : string_t use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use file_m , only : file_t use kind_parameters_m , only : rkind use inputs_m , only : inputs_t use outputs_m , only : outputs_t implicit none private public :: inference_engine_t character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference private type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: input_weights_ (:,:) ! weights applied to go from the inputs to first hidden layer real ( rkind ), allocatable :: hidden_weights_ (:,:,:) ! weights applied to go from one hidden layer to the next real ( rkind ), allocatable :: output_weights_ (:,:) ! weights applied to go from the final hidden layer to the outputs real ( rkind ), allocatable :: biases_ (:,:) ! neuronal offsets for each hidden layer real ( rkind ), allocatable :: output_biases_ (:) ! neuronal offsets applied to outputs class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: to_json procedure , private :: infer_from_array_of_inputs procedure , private :: infer_from_inputs_object generic :: infer => infer_from_array_of_inputs , infer_from_inputs_object procedure :: num_inputs procedure :: num_outputs procedure :: neurons_per_layer procedure :: num_hidden_layers procedure :: norm procedure :: assert_conformable_with procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: skip procedure :: activation_function_name end type interface inference_engine_t pure module function construct_from_components ( metadata , input_weights , hidden_weights , output_weights , biases , output_biases ) & result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ), dimension (:,:) :: input_weights , output_weights , biases real ( rkind ), intent ( in ) :: hidden_weights (:,:,:), output_biases (:) type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( inference_engine_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine pure module function infer_from_array_of_inputs ( self , input , inference_strategy ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), intent ( in ) :: input (:) class ( inference_strategy_t ), intent ( in ) :: inference_strategy type ( outputs_t ) outputs end function elemental module function infer_from_inputs_object ( self , inputs , inference_strategy ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inputs_t ), intent ( in ) :: inputs class ( inference_strategy_t ), intent ( in ) :: inference_strategy type ( outputs_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function elemental module function neurons_per_layer ( self ) result ( neuron_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer neuron_count end function elemental module function num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer hidden_layer_count end function elemental module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function end interface end module inference_engine_m","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"concurrent_dot_products_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_m.f90~~EfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~outputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~concurrent_dot_products_m.f90~~AfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules concurrent_dot_products_m Source Code concurrent_dot_products_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module concurrent_dot_products_m !! Perform inference using the dot_product intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use outputs_m , only : outputs_t use kind_parameters_m , only : rkind implicit none private public :: concurrent_dot_products_t type , extends ( inference_strategy_t ) :: concurrent_dot_products_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy , skip & ) result ( outputs ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ) :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ) :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ) :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ) :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ) :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy logical , intent ( in ) :: skip type ( outputs_t ) outputs end function end interface end module concurrent_dot_products_m","tags":"","loc":"sourcefile/concurrent_dot_products_m.f90.html"},{"title":"inputs_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inputs_m.f90~~EfferentGraph sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inputs_m.f90~~AfferentGraph sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inputs_m Source Code inputs_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inputs_m use kind_parameters_m , only : rkind implicit none private public :: inputs_t type inputs_t real ( rkind ), allocatable :: inputs_ (:) end type end module inputs_m","tags":"","loc":"sourcefile/inputs_m.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules swish_m Source Code swish_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"read.f90 – Inference-Engine","text":"This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs read_json Source Code read.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_json !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use file_m , only : file_t implicit none type ( string_t ) input_file_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine type ( string_t ) activation_name input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example read -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name )) print * , \"number of inputs: \" , inference_engine % num_inputs () print * , \"number of outputs: \" , inference_engine % num_outputs () print * , \"number of hidden layers: \" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer: \" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) end program","tags":"","loc":"sourcefile/read.f90.html"},{"title":"netCDF_IO.f90 – Inference-Engine","text":"Contents Programs netCDF_IO Source Code netCDF_IO.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"sourcefile/netcdf_io.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~write-read-infer.f90->sourcefile~outputs_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs write_read_infer Source Code write-read-infer.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use step_m , only : step_t use matmul_m , only : matmul_t use file_m , only : file_t use kind_parameters_m , only : rkind use outputs_m , only : outputs_t implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example write-read-infer -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( outputs_t ) network_outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & metadata = [ string_t ( \"XOR\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-02-18\" ), string_t ( \"step\" ), string_t ( \"false\" )], & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ] & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"number of hidden layers:\" , inference_engine % num_hidden_layers () print * , \"number of neurons per layer:\" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ([ real ( rkind ) :: 0. , 1. ], matmul_t ()) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % outputs () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"},{"title":"icar-qr-network.f90 – Inference-Engine","text":"This file depends on sourcefile~~icar-qr-network.f90~~EfferentGraph sourcefile~icar-qr-network.f90 icar-qr-network.f90 sourcefile~outputs_m.f90 outputs_m.f90 sourcefile~icar-qr-network.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~icar-qr-network.f90->sourcefile~matmul_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~icar-qr-network.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~icar-qr-network.f90->sourcefile~kind_parameters_m.f90 sourcefile~outputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~outputs_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inputs_m.f90 inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inputs_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~outputs_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inputs_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs icar_qr_network Source Code icar-qr-network.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program icar_qr_network !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use file_m , only : file_t use kind_parameters_m , only : rkind use outputs_m , only : outputs_t implicit none type ( string_t ) input_file_name , activation_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example icar-qr-network -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name )) print * , \"num_inputs = \" , inference_engine % num_inputs () print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) block real ( rkind ), parameter :: inputs ( * ) = [ real ( rkind ) :: & 5.4041727707954124e-05_rkind , 1.8311046012797760e-09_rkind , 5.4236606525370767e-13_rkind , 0._rkind , 0._rkind , & 2.3016514256596565e-02_rkind , 1.0734779465337851e-07_rkind , 3.9603170742807947e-10_rkind , 2.3047807216644287e+00_rkind , & 5.3973675537109375e+02_rkind & ] type ( outputs_t ) network_outputs print * , \"inputs: \" , inputs network_outputs = inference_engine % infer ( inputs , matmul_t ()) print * , \"outputs: \" , network_outputs % outputs () end block end program","tags":"","loc":"sourcefile/icar-qr-network.f90.html"}]}