var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine is a software library that supports researching options for efficiently propagating inputs through deep, feed-forward neural networks to produce outputs.  Inference-Engine's implementation language, Fortran 2018, makes it suitable for integration into high-performance computing (HPC) applications.  Novel features include Exposing concurrency via A pure inference function and An elemental activation strategy Gathering network weights and biases into contiguous arrays Runtime selection of inference algorithm Item 1 ensures that the infer procedure can be invoked inside Fortran's do concurrent construct, which some compilers can offload automatically to graphics processing units (GPUs).  We envision this being useful in applications that require large numbers of independent inferences.  Item 2 exploits the special case where the number of neurons is uniform across the network layers.  The use of contiguous arrays facilitates spatial locality in memory access patterns.  Item 3 offers the possibility of adaptive inference method selection based on runtime information.  The current methods include ones based on intrinsic functions, dot_product or matmul .  Future options will explore the use of OpenMP and OpenACC for vectorization, multithreading, and/or accelerator offloading. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the examples in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~activation_strategy_t activation_strategy_t type~sigmoid_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/sigmoid_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to performance inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~inference_strategy_t inference_strategy_t type~inference_engine_t->type~inference_strategy_t inference_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ hidden_weights_ inference_strategy_ input_weights_ output_biases_ output_weights_ Constructor inference_engine_t Type-Bound Procedures conformable_with infer infer_from_array_of_inputs infer_from_inputs_object neurons_per_layer norm num_hidden_layers num_inputs num_outputs operator(-) read_network subtract to_json write_network Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) class( inference_strategy_t ), private, allocatable :: inference_strategy_ real(kind=rkind), private, allocatable :: input_weights_ (:,:) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor public interface inference_engine_t private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t ) private impure elemental module function from_json(file_, activation_strategy, inference_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name type( file_t ), intent(in) :: file_ class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: conformable_with interface private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical generic, public :: infer => infer_from_array_of_inputs , infer_from_inputs_object private interface infer_from_array_of_inputs () Arguments None public interface infer_from_inputs_object () Arguments None procedure, public :: infer_from_array_of_inputs interface private pure module module function infer_from_array_of_inputs(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) Return Value real(kind=rkind),allocatable, (:) procedure, public :: infer_from_inputs_object interface public elemental module module function infer_from_inputs_object(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) procedure, public :: neurons_per_layer interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: num_hidden_layers interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: read_network interface private impure elemental module module subroutine read_network(self, file_name, activation_strategy, inference_strategy) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy procedure, public :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) procedure, public :: to_json interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( file_t ) procedure, public :: write_network interface private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"type/inference_engine_t.html"},{"title":"inputs_t – Inference-Engine ","text":"type, public :: inputs_t Contents Variables inputs_ Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: inputs_ (:)","tags":"","loc":"type/inputs_t.html"},{"title":"outputs_t – Inference-Engine ","text":"type, public :: outputs_t Contents Variables outputs_ Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: outputs_ (:)","tags":"","loc":"type/outputs_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~sigmoid_t sigmoid_t type~sigmoid_t->type~activation_strategy_t type~step_t step_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure( activation_interface ), public, deferred, nopass :: activation elemental function activation_interface(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"file_t – Inference-Engine ","text":"type, public :: file_t Inherits type~~file_t~~InheritsGraph type~file_t file_t string_t string_t type~file_t->string_t lines_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lines_ Constructor file_t Type-Bound Procedures lines write_lines Components Type Visibility Attributes Name Initial type(string_t), private, allocatable :: lines_ (:) Constructor public interface file_t private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( file_t ) Type-Bound Procedures procedure, public :: lines interface private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) procedure, public :: write_lines interface private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type(string_t), intent(in), optional :: file_name","tags":"","loc":"type/file_t.html"},{"title":"concurrent_dot_products_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Inherits type~~concurrent_dot_products_t~~InheritsGraph type~concurrent_dot_products_t concurrent_dot_products_t type~inference_strategy_t inference_strategy_t type~concurrent_dot_products_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/concurrent_dot_products_t.html"},{"title":"matmul_t – Inference-Engine ","text":"type, public, extends( inference_strategy_t ) :: matmul_t Inherits type~~matmul_t~~InheritsGraph type~matmul_t matmul_t type~inference_strategy_t inference_strategy_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure, public, nopass :: infer interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/matmul_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bias_ next weights_ Constructor neuron_t Type-Bound Procedures bias next_allocated next_pointer num_inputs weights Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer procedure, public :: num_inputs interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables neuron next Constructor layer_t Type-Bound Procedures count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target Type-Bound Procedures procedure, public :: count_layers interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) procedure, public :: hidden_biases interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: hidden_weights interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) procedure, public :: input_weights interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) procedure, public :: neurons_per_layer interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"type/layer_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"type/step_t.html"},{"title":"inference_strategy_t – Inference-Engine ","text":"type, public, abstract :: inference_strategy_t Inherited by type~~inference_strategy_t~~InheritedByGraph type~inference_strategy_t inference_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~inference_strategy_t inference_strategy_ type~concurrent_dot_products_t concurrent_dot_products_t type~concurrent_dot_products_t->type~inference_strategy_t type~matmul_t matmul_t type~matmul_t->type~inference_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures infer Type-Bound Procedures procedure( infer_interface ), public, deferred, nopass :: infer pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/inference_strategy_t.html"},{"title":"activation_interface – Inference-Engine","text":"abstract interface private elemental function activation_interface(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_interface.html"},{"title":"infer_interface – Inference-Engine","text":"abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/infer_interface.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"interface Calls interface~~infer_from_inputs_object~~CallsGraph interface~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object proc~assert_consistent assert_consistent proc~infer_from_inputs_object->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public elemental module module function infer_from_inputs_object(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t )","tags":"","loc":"interface/infer_from_inputs_object.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct from_json Functions private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t ) private impure elemental module function from_json(file_, activation_strategy, inference_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name type( file_t ), intent(in) :: file_ class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"conformable_with – Inference-Engine","text":"interface Calls interface~~conformable_with~~CallsGraph interface~conformable_with conformable_with proc~conformable_with conformable_with interface~conformable_with->proc~conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical","tags":"","loc":"interface/conformable_with.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"interface Calls interface~~infer_from_array_of_inputs~~CallsGraph interface~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs proc~assert_consistent assert_consistent proc~infer_from_array_of_inputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer_from_array_of_inputs(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/infer_from_array_of_inputs.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer assert assert proc~neurons_per_layer->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"interface Calls interface~~num_hidden_layers~~CallsGraph interface~num_hidden_layers num_hidden_layers proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers assert assert proc~num_hidden_layers->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs assert assert proc~num_inputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs assert assert proc~num_outputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"read_network – Inference-Engine","text":"interface Calls interface~~read_network~~CallsGraph interface~read_network read_network proc~read_network read_network interface~read_network->proc~read_network assert assert proc~read_network->assert proc~assert_consistent assert_consistent proc~read_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine read_network(self, file_name, activation_strategy, inference_strategy) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy","tags":"","loc":"interface/read_network.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract intrinsic_array_t intrinsic_array_t proc~subtract->intrinsic_array_t assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~~CallsGraph interface~to_json to_json proc~to_json to_json interface~to_json->proc~to_json separated_values separated_values proc~to_json->separated_values assert assert proc~to_json->assert intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t string_t string_t proc~to_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( file_t )","tags":"","loc":"interface/to_json.html"},{"title":"write_network – Inference-Engine","text":"interface Calls interface~~write_network~~CallsGraph interface~write_network write_network proc~write_network write_network interface~write_network->proc~write_network assert assert proc~write_network->assert proc~assert_consistent assert_consistent proc~write_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"interface/write_network.html"},{"title":"file_t – Inference-Engine","text":"public interface file_t Contents Functions construct read_lines Functions private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( file_t )","tags":"","loc":"interface/file_t.html"},{"title":"lines – Inference-Engine","text":"interface Calls interface~~lines~~CallsGraph interface~lines lines proc~lines lines interface~lines->proc~lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/lines.html"},{"title":"write_lines – Inference-Engine","text":"interface Calls interface~~write_lines~~CallsGraph interface~write_lines write_lines proc~write_lines write_lines interface~write_lines->proc~write_lines assert assert proc~write_lines->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type(string_t), intent(in), optional :: file_name","tags":"","loc":"interface/write_lines.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/infer.html"},{"title":"assert_consistent – Inference-Engine","text":"pure subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent proc~infer_from_inputs_object infer_from_inputs_object proc~infer_from_inputs_object->proc~assert_consistent proc~read_network read_network proc~read_network->proc~assert_consistent proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~infer_from_array_of_inputs->proc~assert_consistent proc~from_json from_json proc~from_json->proc~assert_consistent proc~write_network write_network proc~write_network->proc~assert_consistent interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object interface~write_network write_network interface~write_network->proc~write_network interface~read_network read_network interface~read_network->proc~read_network interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/infer~2.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Contents Functions construct Functions private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface Calls interface~~bias~~CallsGraph interface~bias bias proc~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~~CallsGraph interface~next_allocated next_allocated proc~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~~CallsGraph interface~next_pointer next_pointer proc~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~2~~CallsGraph interface~num_inputs~2 num_inputs proc~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"weights – Inference-Engine","text":"interface Calls interface~~weights~~CallsGraph interface~weights weights proc~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Contents Functions construct Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target","tags":"","loc":"interface/layer_t.html"},{"title":"count_layers – Inference-Engine","text":"interface Calls interface~~count_layers~~CallsGraph interface~count_layers count_layers proc~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Calls interface~~count_neurons~~CallsGraph interface~count_neurons count_neurons proc~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"interface Calls interface~~hidden_biases~~CallsGraph interface~hidden_biases hidden_biases proc~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"interface Calls interface~~hidden_weights~~CallsGraph interface~hidden_weights hidden_weights proc~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:)","tags":"","loc":"interface/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"interface Calls interface~~input_weights~~CallsGraph interface~input_weights input_weights proc~input_weights input_weights interface~input_weights->proc~input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:)","tags":"","loc":"interface/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~2~~CallsGraph interface~neurons_per_layer~2 neurons_per_layer proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer~2.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~2~~CallsGraph interface~next_allocated~2 next_allocated proc~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~2~~CallsGraph interface~next_pointer~2 next_pointer proc~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~2~~CallsGraph interface~activation~2 activation proc~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"netCDF_read – Inference-Engine","text":"subroutine netCDF_read(file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) Calls proc~~netcdf_read~~CallsGraph proc~netcdf_read netCDF_read nf90_strerror nf90_strerror proc~netcdf_read->nf90_strerror assert assert proc~netcdf_read->assert data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_read~~CalledByGraph proc~netcdf_read netCDF_read program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_read.html"},{"title":"netCDF_write – Inference-Engine","text":"subroutine netCDF_write(file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Calls proc~~netcdf_write~~CallsGraph proc~netcdf_write netCDF_write nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror assert assert proc~netcdf_write->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~netcdf_write~~CalledByGraph proc~netcdf_write netCDF_write program~netcdf_io netCDF_IO program~netcdf_io->proc~netcdf_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/netcdf_write.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_query_infer Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ], & inference_strategy = matmul_t () & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file , step_t (), matmul_t ()) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () print * , \"Performing inference:\" print * , \"inference_engine%infer([0.,1.]) =\" , inference_engine % infer ([ real ( rkind ) :: 0. , 1. ]) print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable,(:) Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~~CallsGraph proc~construct construct layer_lines layer_lines proc~construct->layer_lines assert assert proc~construct->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer Called by proc~~count_layers~~CalledByGraph proc~count_layers count_layers interface~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:) Called by proc~~count_neurons~~CalledByGraph proc~count_neurons count_neurons interface~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_neurons.html"},{"title":"hidden_biases – Inference-Engine","text":"module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~hidden_biases~~CallsGraph proc~hidden_biases hidden_biases intrinsic_array_t intrinsic_array_t proc~hidden_biases->intrinsic_array_t assert assert proc~hidden_biases->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_biases~~CalledByGraph proc~hidden_biases hidden_biases interface~hidden_biases hidden_biases interface~hidden_biases->proc~hidden_biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_biases.html"},{"title":"hidden_weights – Inference-Engine","text":"module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:,:) Calls proc~~hidden_weights~~CallsGraph proc~hidden_weights hidden_weights assert assert proc~hidden_weights->assert intrinsic_array_t intrinsic_array_t proc~hidden_weights->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~hidden_weights~~CalledByGraph proc~hidden_weights hidden_weights interface~hidden_weights hidden_weights interface~hidden_weights->proc~hidden_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hidden_weights.html"},{"title":"input_weights – Inference-Engine","text":"module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable,(:,:) Calls proc~~input_weights~~CallsGraph proc~input_weights input_weights assert assert proc~input_weights->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_weights~~CalledByGraph proc~input_weights input_weights interface~input_weights input_weights interface~input_weights->proc~input_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_weights.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Called by proc~~neurons_per_layer~2~~CalledByGraph proc~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2 neurons_per_layer interface~neurons_per_layer~2->proc~neurons_per_layer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer~2.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~2~~CalledByGraph proc~next_allocated~2 next_allocated interface~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Called by proc~~next_pointer~2~~CalledByGraph proc~next_pointer~2 next_pointer interface~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer~2.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~2~~CalledByGraph proc~activation~2 activation interface~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~2.html"},{"title":"conformable_with – Inference-Engine","text":"module procedure conformable_with elemental module module function conformable_with(self, inference_engine) result(conformable) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical Called by proc~~conformable_with~~CalledByGraph proc~conformable_with conformable_with interface~conformable_with conformable_with interface~conformable_with->proc~conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/conformable_with.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json module procedure from_json() Arguments None Calls proc~~from_json~~CallsGraph proc~from_json from_json assert assert proc~from_json->assert proc~assert_consistent assert_consistent proc~from_json->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_json.html"},{"title":"infer_from_array_of_inputs – Inference-Engine","text":"module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input) result(output) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) Return Value real(kind=rkind),allocatable,(:) Calls proc~~infer_from_array_of_inputs~~CallsGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs proc~assert_consistent assert_consistent proc~infer_from_array_of_inputs->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_array_of_inputs~~CalledByGraph proc~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs infer_from_array_of_inputs interface~infer_from_array_of_inputs->proc~infer_from_array_of_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_array_of_inputs.html"},{"title":"infer_from_inputs_object – Inference-Engine","text":"module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) Calls proc~~infer_from_inputs_object~~CallsGraph proc~infer_from_inputs_object infer_from_inputs_object proc~assert_consistent assert_consistent proc~infer_from_inputs_object->proc~assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer_from_inputs_object~~CalledByGraph proc~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object infer_from_inputs_object interface~infer_from_inputs_object->proc~infer_from_inputs_object Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer_from_inputs_object.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~neurons_per_layer~~CallsGraph proc~neurons_per_layer neurons_per_layer assert assert proc~neurons_per_layer->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_hidden_layers – Inference-Engine","text":"module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_hidden_layers~~CallsGraph proc~num_hidden_layers num_hidden_layers assert assert proc~num_hidden_layers->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_hidden_layers~~CalledByGraph proc~num_hidden_layers num_hidden_layers interface~num_hidden_layers num_hidden_layers interface~num_hidden_layers->proc~num_hidden_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_hidden_layers.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~~CallsGraph proc~num_inputs num_inputs assert assert proc~num_inputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs assert assert proc~num_outputs->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"read_network – Inference-Engine","text":"module procedure read_network impure elemental module module subroutine read_network(self, file_name, activation_strategy, inference_strategy) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy Calls proc~~read_network~~CallsGraph proc~read_network read_network assert assert proc~read_network->assert proc~assert_consistent assert_consistent proc~read_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_network~~CalledByGraph proc~read_network read_network interface~read_network read_network interface~read_network->proc~read_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_network.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract intrinsic_array_t intrinsic_array_t proc~subtract->intrinsic_array_t assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( file_t ) Calls proc~~to_json~~CallsGraph proc~to_json to_json separated_values separated_values proc~to_json->separated_values assert assert proc~to_json->assert intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t string_t string_t proc~to_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~~CalledByGraph proc~to_json to_json interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json.html"},{"title":"write_network – Inference-Engine","text":"module procedure write_network impure elemental module module subroutine write_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name Calls proc~~write_network~~CallsGraph proc~write_network write_network assert assert proc~write_network->assert proc~assert_consistent assert_consistent proc~write_network->proc~assert_consistent proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_network~~CalledByGraph proc~write_network write_network interface~write_network write_network interface~write_network->proc~write_network Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_network.html"},{"title":"infer – Inference-Engine","text":"module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable,(:) Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~bias~~CalledByGraph proc~bias bias interface~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~3~~CallsGraph proc~construct~3 construct neuron_lines neuron_lines proc~construct~3->neuron_lines assert assert proc~construct~3->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~3.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~~CalledByGraph proc~next_allocated next_allocated interface~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer Called by proc~~next_pointer~~CalledByGraph proc~next_pointer next_pointer interface~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~2~~CalledByGraph proc~num_inputs~2 num_inputs interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~2.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~weights~~CalledByGraph proc~weights weights interface~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/weights.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~4.html"},{"title":"lines – Inference-Engine","text":"module procedure lines pure module module function lines(self) result(my_lines) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type(string_t),allocatable,(:) Called by proc~~lines~~CalledByGraph proc~lines lines interface~lines lines interface~lines->proc~lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lines.html"},{"title":"read_lines – Inference-Engine","text":"module procedure read_lines module procedure read_lines() Arguments None Calls proc~~read_lines~~CallsGraph proc~read_lines read_lines assert assert proc~read_lines->assert string_t string_t proc~read_lines->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_lines.html"},{"title":"write_lines – Inference-Engine","text":"module procedure write_lines impure elemental module module subroutine write_lines(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type(string_t), intent(in), optional :: file_name Calls proc~~write_lines~~CallsGraph proc~write_lines write_lines assert assert proc~write_lines->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_lines~~CalledByGraph proc~write_lines write_lines interface~write_lines write_lines interface~write_lines->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_lines.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m module~activation_strategy_m activation_strategy_m module~sigmoid_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m program~convert_to_json convert_to_json program~convert_to_json->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation Derived Types sigmoid_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation","tags":"","loc":"module/sigmoid_m.html"},{"title":"inference_engine_m – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses inference_strategy_m kind_parameters_m string_m activation_strategy_m file_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~file_m file_m module~inference_engine_m->module~file_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m string_m string_m module~inference_engine_m->string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~file_m->string_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~convert_to_json convert_to_json program~convert_to_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer_from_inputs_object inference_engine_t conformable_with infer_from_array_of_inputs neurons_per_layer norm num_hidden_layers num_inputs num_outputs read_network subtract to_json write_network Derived Types inference_engine_t inputs_t outputs_t Interfaces interface public elemental module module function infer_from_inputs_object(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) public interface inference_engine_t private pure module function construct(input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:,:) :: input_weights real(kind=rkind), intent(in) :: hidden_weights (:,:,:) real(kind=rkind), intent(in), dimension(:,:) :: output_weights real(kind=rkind), intent(in), dimension(:,:) :: biases real(kind=rkind), intent(in) :: output_biases (:) class( inference_strategy_t ), intent(in), optional :: inference_strategy class( activation_strategy_t ), intent(in), optional :: activation_strategy Return Value type( inference_engine_t ) private impure elemental module function from_json(file_, activation_strategy, inference_strategy) result(inference_engine) Arguments Type Intent Optional Attributes Name type( file_t ), intent(in) :: file_ class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy Return Value type( inference_engine_t ) interface private elemental module module function conformable_with(self, inference_engine) result(conformable) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical interface private pure module module function infer_from_array_of_inputs(self, input) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) Return Value real(kind=rkind),allocatable, (:) interface private elemental module module function neurons_per_layer(self) result(neuron_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private impure elemental module module subroutine read_network(self, file_name, activation_strategy, inference_strategy) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( file_t ) interface private impure elemental module module subroutine write_network(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name Derived Types type, public :: inference_engine_t Encapsulate the minimal information needed to performance inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) real(kind=rkind), private, allocatable :: hidden_weights_ (:,:,:) class( inference_strategy_t ), private, allocatable :: inference_strategy_ real(kind=rkind), private, allocatable :: input_weights_ (:,:) real(kind=rkind), private, allocatable :: output_biases_ (:) real(kind=rkind), private, allocatable :: output_weights_ (:,:) Constructor private pure,module function construct (input_weights, hidden_weights, output_weights, biases, output_biases, inference_strategy, activation_strategy) private impure,elemental,module function from_json (file_, activation_strategy, inference_strategy) Type-Bound Procedures procedure, public :: conformable_with generic, public :: infer => infer_from_array_of_inputs, infer_from_inputs_object procedure, public :: infer_from_array_of_inputs procedure, public :: infer_from_inputs_object procedure, public :: neurons_per_layer procedure, public :: norm procedure, public :: num_hidden_layers procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: read_network procedure, public :: subtract procedure, public :: to_json procedure, public :: write_network type, public :: inputs_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: inputs_ (:) type, public :: outputs_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: outputs_ (:)","tags":"","loc":"module/inference_engine_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses kind_parameters_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~activation_strategy_m module~inference_strategy_m inference_strategy_m module~inference_strategy_m->module~activation_strategy_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~matmul_m matmul_m module~matmul_m->module~activation_strategy_m module~matmul_m->module~inference_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~inference_strategy_m module~step_m->module~activation_strategy_m program~convert_to_json convert_to_json program~convert_to_json->module~sigmoid_m program~convert_to_json->module~matmul_m program~convert_to_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m program~write_read_infer->module~inference_engine_m program~write_read_infer->module~step_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~matmul_m module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~step_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m program~read_json->module~step_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m module~step_s step_s module~step_s->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_interface Derived Types activation_strategy_t Abstract Interfaces abstract interface private elemental function activation_interface(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_interface), public, nopass :: activation","tags":"","loc":"module/activation_strategy_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~inference_strategy_m inference_strategy_m module~inference_strategy_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~sigmoid_m sigmoid_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~activation_strategy_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~kind_parameters_m module~inference_engine_m inference_engine_m program~concurrent_inferences->module~inference_engine_m module~matmul_m matmul_m module~matmul_m->module~kind_parameters_m module~matmul_m->module~inference_strategy_m module~matmul_m->module~activation_strategy_m program~convert_to_json convert_to_json program~convert_to_json->module~kind_parameters_m program~convert_to_json->module~sigmoid_m program~convert_to_json->module~matmul_m program~convert_to_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~matmul_m program~write_read_infer->module~inference_engine_m module~step_m step_m program~write_read_infer->module~step_m module~activation_strategy_m->module~kind_parameters_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~kind_parameters_m module~concurrent_dot_products_m->module~inference_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~activation_strategy_m module~neuron_m->module~kind_parameters_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m program~construct_and_write construct_and_write program~construct_and_write->module~kind_parameters_m program~construct_and_write->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~inference_engine_s->module~matmul_m module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~neuron_m module~inference_engine_s->module~step_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~concurrent_dot_products_s->module~step_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m module~matmul_s matmul_s module~matmul_s->module~matmul_m program~read_json read_json program~read_json->module~matmul_m program~read_json->module~inference_engine_m program~read_json->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"file_m – Inference-Engine","text":"A representation of a file as an object Uses string_m module~~file_m~~UsesGraph module~file_m file_m string_m string_m module~file_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: file_s module~~file_m~~UsedByGraph module~file_m file_m program~convert_to_json convert_to_json program~convert_to_json->module~file_m module~inference_engine_m inference_engine_m program~convert_to_json->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~file_m module~inference_engine_s->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~file_m program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~file_m program~read_json->module~inference_engine_m module~inference_engine_m->module~file_m module~file_s file_s module~file_s->module~file_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces file_t lines write_lines Derived Types file_t Interfaces public interface file_t private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( file_t ) interface private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) interface private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type(string_t), intent(in), optional :: file_name Derived Types type, public :: file_t Components Type Visibility Attributes Name Initial type(string_t), private, allocatable :: lines_ (:) Constructor private pure,module function construct (lines) private impure,elemental,module function read_lines (file_name) Type-Bound Procedures procedure, public :: lines procedure, public :: write_lines","tags":"","loc":"module/file_m.html"},{"title":"concurrent_dot_products_m – Inference-Engine","text":"Perform inference using the dot_product intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses kind_parameters_m activation_strategy_m inference_strategy_m module~~concurrent_dot_products_m~~UsesGraph module~concurrent_dot_products_m concurrent_dot_products_m module~kind_parameters_m kind_parameters_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: concurrent_dot_products_s module~~concurrent_dot_products_m~~UsedByGraph module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types concurrent_dot_products_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:) Derived Types type, public, extends( inference_strategy_t ) :: concurrent_dot_products_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/concurrent_dot_products_m.html"},{"title":"matmul_m – Inference-Engine","text":"Perform inference using the matrix multiplication intrinsic function inside do concurrent constructs\nto compute matrix-vector multiplies for forward information propagation from layer to layer Uses kind_parameters_m activation_strategy_m inference_strategy_m module~~matmul_m~~UsesGraph module~matmul_m matmul_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: matmul_s module~~matmul_m~~UsedByGraph module~matmul_m matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~matmul_m program~convert_to_json convert_to_json program~convert_to_json->module~matmul_m program~write_read_infer write_read_infer program~write_read_infer->module~matmul_m program~read_json read_json program~read_json->module~matmul_m module~matmul_s matmul_s module~matmul_s->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces infer Derived Types matmul_t Interfaces interface private pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:) Derived Types type, public, extends( inference_strategy_t ) :: matmul_t Type-Bound Procedures procedure, public, nopass :: infer","tags":"","loc":"module/matmul_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses string_m kind_parameters_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces neuron_t bias next_allocated next_pointer num_inputs weights Derived Types neuron_t Interfaces public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private pure,recursive,module function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses string_m neuron_m kind_parameters_m module~~layer_m~~UsesGraph module~layer_m layer_m string_m string_m module~layer_m->string_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->string_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces layer_t count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer Derived Types layer_t Interfaces public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) interface private module module function hidden_biases(self) result(biases) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function hidden_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) interface private module module function input_weights(self) result(weights) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private recursive,module function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: hidden_biases procedure, public :: hidden_weights procedure, public :: input_weights procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"step_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m module~step_s step_s module~step_s->module~step_m program~read_json read_json program~read_json->module~step_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation","tags":"","loc":"module/step_m.html"},{"title":"inference_strategy_m – Inference-Engine","text":"Uses activation_strategy_m kind_parameters_m module~~inference_strategy_m~~UsesGraph module~inference_strategy_m inference_strategy_m module~activation_strategy_m activation_strategy_m module~inference_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_strategy_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_strategy_m~~UsedByGraph module~inference_strategy_m inference_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_m->module~inference_strategy_m module~matmul_m matmul_m module~matmul_m->module~inference_strategy_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~convert_to_json convert_to_json program~convert_to_json->module~inference_engine_m program~convert_to_json->module~matmul_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~write_read_infer->module~matmul_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m module~inference_engine_s->module~matmul_m module~concurrent_dot_products_s concurrent_dot_products_s module~concurrent_dot_products_s->module~concurrent_dot_products_m program~construct_and_write construct_and_write program~construct_and_write->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~read_json->module~matmul_m module~matmul_s matmul_s module~matmul_s->module~matmul_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces infer_interface Derived Types inference_strategy_t Abstract Interfaces abstract interface private pure function infer_interface(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:) Derived Types type, public, abstract :: inference_strategy_t Type-Bound Procedures procedure(infer_interface), public, nopass :: infer","tags":"","loc":"module/inference_strategy_m.html"},{"title":"concurrent_dot_products_s – Inference-Engine","text":"Uses assert_m step_m activation_strategy_m Ancestors: concurrent_dot_products_m module~~concurrent_dot_products_s~~UsesGraph module~concurrent_dot_products_s concurrent_dot_products_s assert_m assert_m module~concurrent_dot_products_s->assert_m module~step_m step_m module~concurrent_dot_products_s->module~step_m module~activation_strategy_m activation_strategy_m module~concurrent_dot_products_s->module~activation_strategy_m module~concurrent_dot_products_m concurrent_dot_products_m module~concurrent_dot_products_s->module~concurrent_dot_products_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~concurrent_dot_products_m->module~activation_strategy_m module~concurrent_dot_products_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~concurrent_dot_products_m->module~inference_strategy_m module~inference_strategy_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/concurrent_dot_products_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m module~activation_strategy_m activation_strategy_m module~sigmoid_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/sigmoid_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses intrinsic_array_m assert_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m module~layer_m layer_m module~layer_s->module~layer_m assert_m assert_m module~layer_s->assert_m string_m string_m module~layer_m->string_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m->string_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct count_layers count_neurons hidden_biases hidden_weights input_weights neurons_per_layer next_allocated next_pointer Module Procedures module procedure construct module procedure construct() Arguments None module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) module procedure hidden_biases module module function hidden_biases(self) result(biases) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure hidden_weights module module function hidden_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:,:) module procedure input_weights module module function input_weights(self) result(weights) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value real(kind=rkind),allocatable, (:,:) module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"module/layer_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/step_s.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses matmul_m iso_fortran_env neuron_m assert_m layer_m intrinsic_array_m step_m formats_m file_m Ancestors: inference_engine_m module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s module~matmul_m matmul_m module~inference_engine_s->module~matmul_m formats_m formats_m module~inference_engine_s->formats_m module~layer_m layer_m module~inference_engine_s->module~layer_m intrinsic_array_m intrinsic_array_m module~inference_engine_s->intrinsic_array_m module~file_m file_m module~inference_engine_s->module~file_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m assert_m assert_m module~inference_engine_s->assert_m iso_fortran_env iso_fortran_env module~inference_engine_s->iso_fortran_env module~step_m step_m module~inference_engine_s->module~step_m module~inference_engine_m inference_engine_m module~inference_engine_s->module~inference_engine_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~layer_m->module~neuron_m module~layer_m->module~kind_parameters_m string_m string_m module~layer_m->string_m module~file_m->string_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m->module~file_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->string_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines assert_consistent Module Procedures conformable_with construct from_json infer_from_array_of_inputs infer_from_inputs_object neurons_per_layer norm num_hidden_layers num_inputs num_outputs read_network subtract to_json write_network Subroutines pure subroutine assert_consistent (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Module Procedures module procedure conformable_with elemental module module function conformable_with(self, inference_engine) result(conformable) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Return Value logical module procedure construct module procedure construct() Arguments None module procedure from_json module procedure from_json() Arguments None module procedure infer_from_array_of_inputs pure module module function infer_from_array_of_inputs(self, input) result(output) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self real(kind=rkind), intent(in) :: input (:) Return Value real(kind=rkind),allocatable, (:) module procedure infer_from_inputs_object elemental module module function infer_from_inputs_object(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inputs_t ), intent(in) :: inputs Return Value type( outputs_t ) module procedure neurons_per_layer elemental module module function neurons_per_layer(self) result(neuron_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value real(kind=rkind) module procedure num_hidden_layers elemental module module function num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure read_network impure elemental module module subroutine read_network(self, file_name, activation_strategy, inference_strategy) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(out) :: self type(string_t), intent(in) :: file_name class( activation_strategy_t ), intent(in), optional :: activation_strategy class( inference_strategy_t ), intent(in), optional :: inference_strategy module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( inference_engine_t ) module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( file_t ) module procedure write_network impure elemental module module subroutine write_network(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type(string_t), intent(in) :: file_name","tags":"","loc":"module/inference_engine_s.html"},{"title":"matmul_s – Inference-Engine","text":"Uses Ancestors: matmul_m module~~matmul_s~~UsesGraph module~matmul_s matmul_s module~matmul_m matmul_m module~matmul_s->module~matmul_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures infer Module Procedures module procedure infer pure module module function infer(input, input_weights, hidden_weights, biases, output_biases, output_weights, activation_strategy) result(output) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: input (:) real(kind=rkind), intent(in), allocatable :: input_weights (:,:) weights applied to go from the inputs to first hidden layer real(kind=rkind), intent(in), allocatable :: hidden_weights (:,:,:) weights applied to go from one hidden layer to the next real(kind=rkind), intent(in), allocatable :: biases (:,:) neuronal offsets for each hidden layer real(kind=rkind), intent(in), allocatable :: output_biases (:) neuronal offsets applied to outputs real(kind=rkind), intent(in), allocatable :: output_weights (:,:) weights applied to go from the final hidden layer to the outputs class( activation_strategy_t ), intent(in) :: activation_strategy Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/matmul_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bias construct next_allocated next_pointer num_inputs weights Module Procedures module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure construct module procedure construct() Arguments None module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"file_s – Inference-Engine","text":"Uses assert_m iso_fortran_env Ancestors: file_m module~~file_s~~UsesGraph module~file_s file_s assert_m assert_m module~file_s->assert_m module~file_m file_m module~file_s->module~file_m iso_fortran_env iso_fortran_env module~file_s->iso_fortran_env string_m string_m module~file_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct lines read_lines write_lines Module Procedures module procedure construct module procedure construct() Arguments None module procedure lines pure module module function lines(self) result(my_lines) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type(string_t),allocatable, (:) module procedure read_lines module procedure read_lines() Arguments None module procedure write_lines impure elemental module module subroutine write_lines(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type(string_t), intent(in), optional :: file_name","tags":"","loc":"module/file_s.html"},{"title":"concurrent_inferences – Inference-Engine","text":"Uses string_m inference_engine_m command_line_m kind_parameters_m program~~concurrent_inferences~~UsesGraph program~concurrent_inferences concurrent_inferences string_m string_m program~concurrent_inferences->string_m command_line_m command_line_m program~concurrent_inferences->command_line_m module~kind_parameters_m kind_parameters_m program~concurrent_inferences->module~kind_parameters_m module~inference_engine_m inference_engine_m program~concurrent_inferences->module~inference_engine_m module~inference_engine_m->string_m module~inference_engine_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~file_m file_m module~inference_engine_m->module~file_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~file_m->string_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read multiple neural networks, each from a\nseparate file, into an array of inference_engine_t objects and then perform\ninference concurrently using the resulting inference_engine_t array. Calls program~~concurrent_inferences~~CallsGraph program~concurrent_inferences concurrent_inferences array_of_strings array_of_strings program~concurrent_inferences->array_of_strings inference inference program~concurrent_inferences->inference Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line expected_result false file_names i inference_engine input_array input_files test_passes tolerance true truth_table Variables Type Attributes Name Initial type(command_line_t) :: command_line real(kind=rkind), parameter :: expected_result (*) = [false, true, true, false] real(kind=rkind), parameter :: false = 0. type(string_t), allocatable :: file_names (:) integer :: i type( inference_engine_t ), allocatable :: inference_engine (:) real(kind=rkind), parameter :: input_array (*,*) = reshape([true, true, false, true, true, false, false, false], shape=[2, 4]) character(len=:), allocatable :: input_files logical, allocatable :: test_passes (:) real(kind=rkind), parameter :: tolerance = 1.E-08 real(kind=rkind), parameter :: true = 1. real(kind=rkind), allocatable :: truth_table (:)","tags":"","loc":"program/concurrent_inferences.html"},{"title":"convert_to_json – Inference-Engine","text":"Uses matmul_m assert_m command_line_m kind_parameters_m sigmoid_m string_m inference_engine_m file_m program~~convert_to_json~~UsesGraph program~convert_to_json convert_to_json module~matmul_m matmul_m program~convert_to_json->module~matmul_m module~sigmoid_m sigmoid_m program~convert_to_json->module~sigmoid_m module~file_m file_m program~convert_to_json->module~file_m module~kind_parameters_m kind_parameters_m program~convert_to_json->module~kind_parameters_m command_line_m command_line_m program~convert_to_json->command_line_m assert_m assert_m program~convert_to_json->assert_m string_m string_m program~convert_to_json->string_m module~inference_engine_m inference_engine_m program~convert_to_json->module~inference_engine_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~activation_strategy_m module~file_m->string_m module~inference_engine_m->module~file_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->string_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network in a custom file format\ninto an inference_engine_t object, convert it to a JSON format, and write the\nresulting JSON objects to a file. Calls program~~convert_to_json~~CallsGraph program~convert_to_json convert_to_json string_t string_t program~convert_to_json->string_t assert assert program~convert_to_json->assert inputs inputs program~convert_to_json->inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line inference_engine input_file_name json_output_file Variables Type Attributes Name Initial type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine character(len=:), allocatable :: input_file_name type( file_t ) :: json_output_file","tags":"","loc":"program/convert_to_json.html"},{"title":"read_json – Inference-Engine","text":"Uses matmul_m command_line_m string_m inference_engine_m step_m file_m program~~read_json~~UsesGraph program~read_json read_json module~matmul_m matmul_m program~read_json->module~matmul_m module~file_m file_m program~read_json->module~file_m string_m string_m program~read_json->string_m command_line_m command_line_m program~read_json->command_line_m module~step_m step_m program~read_json->module~step_m module~inference_engine_m inference_engine_m program~read_json->module~inference_engine_m module~kind_parameters_m kind_parameters_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~file_m->string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m->module~file_m module~inference_engine_m->string_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~read_json~~CallsGraph program~read_json read_json string_t string_t program~read_json->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line inference_engine input_file_name Variables Type Attributes Name Initial type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/read_json.html"},{"title":"construct_and_write – Inference-Engine","text":"Uses string_m inference_engine_m command_line_m kind_parameters_m program~~construct_and_write~~UsesGraph program~construct_and_write construct_and_write string_m string_m program~construct_and_write->string_m command_line_m command_line_m program~construct_and_write->command_line_m module~kind_parameters_m kind_parameters_m program~construct_and_write->module~kind_parameters_m module~inference_engine_m inference_engine_m program~construct_and_write->module~inference_engine_m module~inference_engine_m->string_m module~inference_engine_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~inference_engine_m->module~inference_strategy_m module~file_m file_m module~inference_engine_m->module~file_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~file_m->string_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to construct a neural network from arrays of weights and biases\nand how to write the resulting object to a file in the format that is readable by the\ninference_engine_t read_network type-bound procedure. Calls program~~construct_and_write~~CallsGraph program~construct_and_write construct_and_write string_t string_t program~construct_and_write->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line i identity j output_file_name xor Variables Type Attributes Name Initial type(command_line_t) :: command_line integer :: i integer, parameter :: identity (*,*,*) = reshape([((merge(1, 0, i==j), i=1, 3), j=1, 3)], shape=[3, 3, 1]) integer :: j character(len=:), allocatable :: output_file_name type( inference_engine_t ) :: xor","tags":"","loc":"program/construct_and_write.html"},{"title":"netCDF_IO – Inference-Engine","text":"Uses assert_m netcdf program~~netcdf_io~~UsesGraph program~netcdf_io netCDF_IO assert_m assert_m program~netcdf_io->assert_m netcdf netcdf program~netcdf_io->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~netcdf_io~~CallsGraph program~netcdf_io netCDF_IO proc~netcdf_write netCDF_write program~netcdf_io->proc~netcdf_write assert assert program~netcdf_io->assert proc~netcdf_read netCDF_read program~netcdf_io->proc~netcdf_read proc~netcdf_write->assert nf90_strerror nf90_strerror proc~netcdf_write->nf90_strerror proc~netcdf_read->assert proc~netcdf_read->nf90_strerror data_in_shape data_in_shape proc~netcdf_read->data_in_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_read data_written file_name i j nx ny Functions get_shape Subroutines netCDF_read netCDF_write Source Code netCDF_IO Variables Type Attributes Name Initial integer, allocatable :: data_read (:,:) integer, parameter :: data_written (*,*) = reshape([((i*j, i=1, nx), j=1, ny)], [ny, nx]) character(len=*), parameter :: file_name = \"netCDF_example.nc\" integer :: i integer :: j integer, parameter :: nx = 6 integer, parameter :: ny = 12 Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Subroutines subroutine netCDF_read (file_name_, data_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(inout), allocatable :: data_in (:,:) subroutine netCDF_write (file_name_, data_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name_ integer, intent(in) :: data_out (:,:) Source Code program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"program/netcdf_io.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses matmul_m command_line_m kind_parameters_m string_m inference_engine_m step_m file_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer module~matmul_m matmul_m program~write_read_infer->module~matmul_m module~file_m file_m program~write_read_infer->module~file_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m string_m string_m program~write_read_infer->string_m command_line_m command_line_m program~write_read_infer->command_line_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~step_m step_m program~write_read_infer->module~step_m module~matmul_m->module~kind_parameters_m module~inference_strategy_m inference_strategy_m module~matmul_m->module~inference_strategy_m module~activation_strategy_m activation_strategy_m module~matmul_m->module~activation_strategy_m module~file_m->string_m module~inference_engine_m->module~file_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->string_m module~inference_engine_m->module~inference_strategy_m module~inference_engine_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_strategy_m->module~kind_parameters_m module~inference_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer string_t string_t program~write_read_infer->string_t proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line file_name Subroutines write_read_query_infer Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"concurrent_dot_products_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_s.f90~~EfferentGraph sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules concurrent_dot_products_s Source Code concurrent_dot_products_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( concurrent_dot_products_m ) concurrent_dot_products_s use assert_m , only : assert use activation_strategy_m , only : activation_strategy_t use step_m , only : step_t implicit none contains module procedure infer integer n , layer , m integer , parameter :: input_layer = 1 real , allocatable :: neuron (:,:) associate ( neurons_per_layer => size ( input_weights , 2 ), num_layers => size ( biases , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) do concurrent ( n = 1 : neurons_per_layer ) neuron ( n , input_layer ) = activation_strategy % activation ( dot_product ( input_weights (:, n ), input (:)) + biases ( n , input_layer )) end do do layer = 2 , num_layers do concurrent ( n = 1 : neurons_per_layer ) neuron ( n , layer ) = & activation_strategy % activation ( dot_product ( hidden_weights (:, n , layer - 1 ), neuron (:, layer - 1 )) + biases ( n , layer )) end do end do associate ( num_outputs => size ( output_weights , 1 )) allocate ( output ( num_outputs )) do concurrent ( m = 1 : num_outputs ) output ( m ) = activation_strategy % activation ( dot_product ( output_weights ( m ,:), neuron (:, num_layers )) + output_biases ( m )) end do end associate end associate end procedure end submodule concurrent_dot_products_s","tags":"","loc":"sourcefile/concurrent_dot_products_s.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~sigmoid_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sigmoid_m Source Code sigmoid_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: sigmoid_t type , extends ( activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules sigmoid_s Source Code sigmoid_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Define an abstraction that supports inference operationsn on a neural network use string_m , only : string_t use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use file_m , only : file_t use kind_parameters_m , only : rkind implicit none private public :: inference_engine_t public :: inputs_t public :: outputs_t public :: infer_from_inputs_object type inputs_t real ( rkind ), allocatable :: inputs_ (:) end type type outputs_t real ( rkind ), allocatable :: outputs_ (:) end type type inference_engine_t !! Encapsulate the minimal information needed to performance inference private real ( rkind ), allocatable :: input_weights_ (:,:) ! weights applied to go from the inputs to first hidden layer real ( rkind ), allocatable :: hidden_weights_ (:,:,:) ! weights applied to go from one hidden layer to the next real ( rkind ), allocatable :: output_weights_ (:,:) ! weights applied to go from the final hidden layer to the outputs real ( rkind ), allocatable :: biases_ (:,:) ! neuronal offsets for each hidden layer real ( rkind ), allocatable :: output_biases_ (:) ! neuronal offsets applied to outputs class ( activation_strategy_t ), allocatable :: activation_strategy_ class ( inference_strategy_t ), allocatable :: inference_strategy_ contains procedure :: read_network procedure :: to_json procedure :: write_network procedure :: infer_from_array_of_inputs procedure :: infer_from_inputs_object generic :: infer => infer_from_array_of_inputs , infer_from_inputs_object procedure :: num_inputs procedure :: num_outputs procedure :: neurons_per_layer procedure :: num_hidden_layers procedure :: norm procedure :: conformable_with procedure :: subtract generic :: operator ( - ) => subtract end type interface inference_engine_t pure module function construct & ( input_weights , hidden_weights , output_weights , biases , output_biases , inference_strategy , activation_strategy ) & result ( inference_engine ) implicit none real ( rkind ), intent ( in ), dimension (:,:) :: input_weights , output_weights , biases real ( rkind ), intent ( in ) :: hidden_weights (:,:,:), output_biases (:) class ( inference_strategy_t ), intent ( in ), optional :: inference_strategy class ( activation_strategy_t ), intent ( in ), optional :: activation_strategy type ( inference_engine_t ) inference_engine end function impure elemental module function from_json ( file_ , activation_strategy , inference_strategy ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ class ( activation_strategy_t ), intent ( in ), optional :: activation_strategy class ( inference_strategy_t ), intent ( in ), optional :: inference_strategy type ( inference_engine_t ) inference_engine end function end interface interface impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function impure elemental module subroutine read_network ( self , file_name , activation_strategy , inference_strategy ) implicit none class ( inference_engine_t ), intent ( out ) :: self type ( string_t ), intent ( in ) :: file_name class ( activation_strategy_t ), intent ( in ), optional :: activation_strategy class ( inference_strategy_t ), intent ( in ), optional :: inference_strategy end subroutine impure elemental module subroutine write_network ( self , file_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ), intent ( in ) :: file_name end subroutine elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( inference_engine_t ) difference end function elemental module function conformable_with ( self , inference_engine ) result ( conformable ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine logical conformable end function pure module function infer_from_array_of_inputs ( self , input ) result ( output ) implicit none class ( inference_engine_t ), intent ( in ) :: self real ( rkind ), intent ( in ) :: input (:) real ( rkind ), allocatable :: output (:) end function elemental module function infer_from_inputs_object ( self , inputs ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inputs_t ), intent ( in ) :: inputs type ( outputs_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function elemental module function neurons_per_layer ( self ) result ( neuron_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer neuron_count end function elemental module function num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer hidden_layer_count end function end interface end module inference_engine_m","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~step_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~sigmoid_m.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~convert-to-json.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m use kind_parameters_m , only : rkind implicit none private public :: activation_strategy_t type , abstract :: activation_strategy_t contains procedure ( activation_interface ), nopass , deferred :: activation end type abstract interface elemental function activation_interface ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~kind_parameters_m.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~kind_parameters_m.f90 sourcefile~convert-to-json.f90->sourcefile~sigmoid_m.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~convert-to-json.f90->sourcefile~matmul_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~step_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kind_parameters_m Source Code kind_parameters_m.f90 Source Code module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules layer_s Source Code layer_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line call assert ( adjustl ( layer_lines ( start )% string ()) == '[' , \"layer_t construct: layer start\" , layer_lines ( start )% string ()) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer = [ neurons_per_layer , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure input_weights type ( neuron_t ), pointer :: neuron integer i associate ( num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer ()) allocate ( weights ( num_inputs , neurons_per_layer )) neuron => self % neuron weights (:, 1 ) = neuron % weights () do i = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%input_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, i ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%input_weights: constant number of inputs\" ) end do neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%input_weights: .not. neuron%next_allocated()\" ) if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer ) = neuron % weights () end associate end procedure module procedure hidden_weights type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( & num_inputs => self % neuron % num_inputs (), neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( weights ( num_inputs , neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron weights (:, 1 , l ) = neuron % weights () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () weights (:, n , l ) = neuron % weights () call assert ( neuron % num_inputs () == num_inputs , \"layer_t%hidden_weights: constant number of inputs\" , & intrinsic_array_t ([ num_inputs , neuron % num_inputs (), l , n ])) end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_weights: neuron%next_allocated()\" ) neuron => neuron % next_pointer () if ( neurons_per_layer /= 1 ) weights (:, neurons_per_layer , l ) = neuron % weights () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_weights: .not. layer%next_allocated()\" ) end if end do loop_over_Layers end associate end procedure module procedure hidden_biases type ( neuron_t ), pointer :: neuron type ( layer_t ), pointer :: layer integer n , l associate ( neurons_per_layer => self % neurons_per_layer (), num_layers => self % count_layers ()) allocate ( biases ( neurons_per_layer , num_layers )) layer => self loop_over_layers : & do l = 1 , num_layers neuron => layer % neuron biases ( 1 , l ) = neuron % bias () loop_over_neurons : & do n = 2 , neurons_per_layer - 1 call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , intrinsic_array_t ([ l , n ])) neuron => neuron % next_pointer () biases ( n , l ) = neuron % bias () end do loop_over_neurons call assert ( neuron % next_allocated (), \"layer_t%hidden_biases: neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) neuron => neuron % next_pointer () call assert (. not . neuron % next_allocated (), \"layer_t%hidden_biases: .not. neuron%next_allocated()\" , & intrinsic_array_t ([ l , neurons_per_layer ])) if ( neurons_per_layer /= 1 ) biases ( neurons_per_layer , l ) = neuron % bias () ! avoid redundant assignment if ( l /= num_layers ) then layer => layer % next else call assert (. not . layer % next_allocated (), \"layer_t%hidden_biases: .not. layer%next_allocated()\" ) end if end do loop_over_layers end associate end procedure hidden_biases module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"file_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~file_m.f90~~AfferentGraph sourcefile~file_m.f90 file_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~file_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~file_m.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~file_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~file_s.f90 file_s.f90 sourcefile~file_s.f90->sourcefile~file_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules file_m Source Code file_m.f90 Source Code module file_m !! A representation of a file as an object use string_m , only : string_t private public :: file_t type file_t private type ( string_t ), allocatable :: lines_ (:) contains procedure :: lines procedure :: write_lines end type interface file_t impure elemental module function read_lines ( file_name ) result ( file_object ) implicit none type ( string_t ), intent ( in ) :: file_name type ( file_t ) file_object end function pure module function construct ( lines ) result ( file_object ) implicit none type ( string_t ), intent ( in ), allocatable :: lines (:) type ( file_t ) file_object end function end interface interface pure module function lines ( self ) result ( my_lines ) implicit none class ( file_t ), intent ( in ) :: self type ( string_t ), allocatable :: my_lines (:) end function impure elemental module subroutine write_lines ( self , file_name ) implicit none class ( file_t ), intent ( in ) :: self type ( string_t ), intent ( in ), optional :: file_name end subroutine end interface end module file_m","tags":"","loc":"sourcefile/file_m.f90.html"},{"title":"concurrent_dot_products_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent_dot_products_m.f90~~EfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~concurrent_dot_products_m.f90~~AfferentGraph sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules concurrent_dot_products_m Source Code concurrent_dot_products_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module concurrent_dot_products_m !! Perform inference using the dot_product intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: concurrent_dot_products_t type , extends ( inference_strategy_t ) :: concurrent_dot_products_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy real ( rkind ), allocatable :: output (:) end function end interface end module concurrent_dot_products_m","tags":"","loc":"sourcefile/concurrent_dot_products_m.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~inference_engine_s.f90->sourcefile~file_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m ) inference_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use matmul_m , only : matmul_t use step_m , only : step_t use layer_m , only : layer_t use neuron_m , only : neuron_t use file_m , only : file_t use formats_m , only : separated_values use iso_fortran_env , only : iostat_end implicit none contains module procedure construct inference_engine % input_weights_ = input_weights inference_engine % hidden_weights_ = hidden_weights inference_engine % output_weights_ = output_weights inference_engine % biases_ = biases inference_engine % output_biases_ = output_biases if ( present ( activation_strategy )) then inference_engine % activation_strategy_ = activation_strategy else inference_engine % activation_strategy_ = step_t () end if if ( present ( inference_strategy )) then inference_engine % inference_strategy_ = inference_strategy else inference_engine % inference_strategy_ = matmul_t () end if end procedure module procedure conformable_with conformable = all ( & [ shape ( self % input_weights_ ) == shape ( inference_engine % input_weights_ ) , & [ shape ( self % hidden_weights_ ) == shape ( inference_engine % hidden_weights_ )], & [ shape ( self % output_weights_ ) == shape ( inference_engine % output_weights_ )], & [ shape ( self % biases_ ) == shape ( inference_engine % biases_ )], & [ shape ( self % output_biases_ ) == shape ( inference_engine % output_biases_ )] & ] & ) end procedure module procedure subtract call assert ( self % conformable_with ( rhs ), \"inference_engine_t%subtract: conformable operands\" , & intrinsic_array_t ([ shape ( self % biases_ ), shape ( rhs % biases_ )])) difference % input_weights_ = self % input_weights_ - rhs % input_weights_ difference % hidden_weights_ = self % hidden_weights_ - rhs % hidden_weights_ difference % output_weights_ = self % output_weights_ - rhs % output_weights_ difference % biases_ = self % biases_ - rhs % biases_ difference % output_biases_ = self % output_biases_ - rhs % output_biases_ end procedure module procedure norm norm_of_self = maxval ( abs ( self % input_weights_ )) + maxval ( abs ( self % hidden_weights_ )) + maxval ( abs ( self % output_weights_ )) + & maxval ( abs ( self % biases_ )) + maxval ( abs ( self % output_biases_ )) end procedure pure subroutine assert_consistent ( self ) type ( inference_engine_t ), intent ( in ) :: self call assert ( allocated ( self % inference_strategy_ ), \"inference_engine%assert_consistent: allocated(self%inference_strategy_)\" ) call assert ( allocated ( self % activation_strategy_ ), \"inference_engine%assert_consistent: allocated(self%activation_strategy_)\" ) associate ( allocated_components => & [ allocated ( self % input_weights_ ), allocated ( self % hidden_weights_ ), allocated ( self % output_weights_ ), & allocated ( self % biases_ ), allocated ( self % output_biases_ )] & ) call assert ( all ( allocated_components ), \"inference_engine_s(assert_consistent): fully allocated object\" , & intrinsic_array_t ( allocated_components )) end associate associate ( num_neurons => 1 + & [ ubound ( self % biases_ , 1 ) - lbound ( self % biases_ , 1 ), & ubound ( self % hidden_weights_ , 1 ) - lbound ( self % hidden_weights_ , 1 ), & ubound ( self % hidden_weights_ , 2 ) - lbound ( self % hidden_weights_ , 2 ), & ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ), & ubound ( self % output_weights_ , 2 ) - lbound ( self % output_weights_ , 2 ) & ] ) call assert ( all ( self % neurons_per_layer () == num_neurons ), \"inference_engine_s(assert_consistent): num_neurons\" , & intrinsic_array_t ( num_neurons ) & ) end associate associate ( output_count => 1 + & [ ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ), & ubound ( self % output_biases_ , 1 ) - lbound ( self % output_biases_ , 1 ) & ] ) call assert ( all ( self % num_outputs () == output_count ), \"inference_engine_s(assert_consistent): num_outputs\" , & intrinsic_array_t ( output_count ) & ) end associate end subroutine module procedure num_outputs call assert ( allocated ( self % output_weights_ ), \"inference_engine_t%num_outputs: allocated(self%output_weights_)\" ) output_count = ubound ( self % output_weights_ , 1 ) - lbound ( self % output_weights_ , 1 ) + 1 end procedure module procedure num_inputs call assert ( allocated ( self % input_weights_ ), \"inference_engine_t%num_inputs: allocated(self%input_weights_)\" ) input_count = ubound ( self % input_weights_ , 1 ) - lbound ( self % input_weights_ , 1 ) + 1 end procedure module procedure neurons_per_layer call assert ( allocated ( self % input_weights_ ), \"inference_engine_t%neurons_per_layer: allocated(self%input_weights_)\" ) neuron_count = ubound ( self % input_weights_ , 2 ) - lbound ( self % input_weights_ , 2 ) + 1 end procedure module procedure num_hidden_layers call assert ( allocated ( self % hidden_weights_ ), \"inference_engine_t%num_hidden_layers: allocated(self%hidden_weights_)\" ) hidden_layer_count = ubound ( self % hidden_weights_ , 3 ) - lbound ( self % hidden_weights_ , 3 ) + 1 end procedure module procedure infer_from_array_of_inputs call assert_consistent ( self ) output = self % inference_strategy_ % infer ( input , & self % input_weights_ , self % hidden_weights_ , self % biases_ , self % output_biases_ , self % output_weights_ , self % activation_strategy_ & ) end procedure module procedure infer_from_inputs_object call assert_consistent ( self ) outputs % outputs_ = self % inference_strategy_ % infer ( inputs % inputs_ , & self % input_weights_ , self % hidden_weights_ , self % biases_ , self % output_biases_ , self % output_weights_ , self % activation_strategy_ & ) end procedure module procedure write_network integer file_unit , io_status , input , layer , neuron open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'unknown' , iostat = io_status , action = 'write' ) call assert ( io_status == 0 , \"write_network: io_status==0 after 'open' statement\" , file_name % string ()) call assert_consistent ( self ) write_input_layer : & block input = 1 write ( file_unit , * ) \"[[\" , self % input_weights_ ( input ,:), trim ( merge ( \"]]\" , \"] \" , self % num_inputs () == 1 )) do input = 2 , self % num_inputs () - 1 write ( file_unit , * ) \"[\" , self % input_weights_ ( input ,:), \"]\" end do input = self % num_inputs () if ( input > 1 ) write ( file_unit , * ) \"[\" , self % input_weights_ ( self % num_inputs (), :), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % biases_ (:, 1 ), \"]\" end block write_input_layer write_hidden_layers : & do layer = 1 , self % num_hidden_layers () write ( file_unit , * ) neuron = 1 write ( file_unit , * ) \"[[\" , self % hidden_weights_ (:, neuron , layer ), trim ( merge ( \"]]\" , \"] \" , self % neurons_per_layer () == 1 )) do neuron = 2 , self % neurons_per_layer () - 1 write ( file_unit , * ) \"[\" , self % hidden_weights_ (: , neuron , layer ), \"]\" end do neuron = self % neurons_per_layer () if ( neuron > 1 ) write ( file_unit , * ) \"[\" , self % hidden_weights_ (:, neuron , layer ), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % biases_ (:, layer + 1 ), \"]\" end do write_hidden_layers write_output_layer : & block write ( file_unit , * ) neuron = 1 write ( file_unit , * ) \"[[\" , self % output_weights_ (:, neuron ), trim ( merge ( \"]]\" , \"] \" , self % neurons_per_layer () == 1 )) do neuron = 2 , self % neurons_per_layer () - 1 write ( file_unit , * ) \"[\" , self % output_weights_ (:, neuron ), \"]\" end do neuron = self % neurons_per_layer () if ( neuron > 1 ) write ( file_unit , * ) \"[\" , self % output_weights_ (:, neuron ), \"]]\" write ( file_unit , * ) write ( file_unit , * ) \"[\" , self % output_biases_ (:), \"]\" end block write_output_layer close ( file_unit ) end procedure module procedure read_network integer file_unit , io_status , num_inputs , num_hidden_layers , num_outputs character ( len = :), allocatable :: line open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) call assert ( io_status == 0 , \"read_network: io_status==0 after 'open' statement\" , file_name % string ()) call read_line_and_count_inputs ( file_unit , line , num_inputs ) call count_hidden_layers ( file_unit , len ( line ), num_hidden_layers ) call count_outputs ( file_unit , len ( line ), num_hidden_layers , num_outputs ) associate ( last_opening_bracket => index ( line , \"[\" , back = . true .), first_closing_bracket => index ( line , \"]\" )) associate ( unbracketed_line => line ( last_opening_bracket + 1 : first_closing_bracket - 1 )) associate ( neurons_per_layer => num_array_elements_in ( unbracketed_line )) call read_weights_and_biases ( file_unit , len ( line ), num_inputs , neurons_per_layer , num_hidden_layers , num_outputs , self ) end associate end associate end associate if ( present ( activation_strategy )) then self % activation_strategy_ = activation_strategy else self % activation_strategy_ = step_t () end if if ( present ( inference_strategy )) then self % inference_strategy_ = inference_strategy else self % inference_strategy_ = matmul_t () end if close ( file_unit ) call assert_consistent ( self ) contains function line_length ( file_unit ) result ( length ) integer , intent ( in ) :: file_unit integer length , io_status character ( len = 1 ) c io_status = 0 length = 1 do read ( file_unit , '(a)' , advance = 'no' , iostat = io_status ) c if ( io_status /= 0 ) exit length = length + 1 end do backspace ( file_unit ) end function subroutine read_line_and_count_inputs ( file_unit , line , input_count ) integer , intent ( in ) :: file_unit character ( len = :), intent ( out ), allocatable :: line integer , intent ( out ) :: input_count integer io_status rewind ( file_unit ) allocate ( character ( len = line_length ( file_unit )) :: line ) input_count = 0 do read ( file_unit , '(a)' , iostat = io_status ) line call assert ( io_status == 0 , \"read_line_and_count_inputs: io_status==0\" , io_status ) input_count = input_count + 1 if ( index ( line , \"]]\" , back = . true .) /= 0 ) exit end do rewind ( file_unit ) end subroutine pure function num_array_elements_in ( space_delimited_reals ) result ( array_size ) character ( len =* ), intent ( in ) :: space_delimited_reals real ( rkind ), allocatable :: array (:) integer array_size , io_status io_status = 0 array_size = 1 do while ( io_status == 0 ) if ( allocated ( array )) deallocate ( array ) allocate ( array ( array_size )) read ( space_delimited_reals , * , iostat = io_status ) array array_size = array_size + 1 end do array_size = size ( array ) - 1 end function subroutine read_weights_and_biases ( & file_unit , buffer_size , num_inputs , neurons_per_layer , num_hidden_layers , num_outputs , self & ) integer , intent ( in ) :: file_unit , buffer_size , num_inputs , neurons_per_layer , num_hidden_layers , num_outputs type ( inference_engine_t ), intent ( out ) :: self character ( len = buffer_size ) line_buffer integer input , io_status , layer , neuron integer , parameter :: input_layer = 1 rewind ( file_unit ) allocate ( self % input_weights_ ( num_inputs , neurons_per_layer )) read_input_weights : & do input = 1 , size ( self % input_weights_ , 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_input_weights: io_status==0\" , io_status ) associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % input_weights_ ( input ,:) end associate end associate end do read_input_weights allocate ( self % biases_ ( neurons_per_layer , num_hidden_layers + input_layer )) allocate ( self % hidden_weights_ ( neurons_per_layer , neurons_per_layer , num_hidden_layers )) find_input_layer_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_input_layer_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_input_layer_biases read_input_layer_biases : & associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % biases_ (:, input_layer ) end associate end associate read_input_layer_biases read_hidden_layer_weights_biases : & do layer = 1 , num_hidden_layers find_weights : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[[\" ) /= 0 ) exit end do find_weights read_weights : & do neuron = 1 , size ( self % hidden_weights_ , 2 ) if ( neuron /= 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % hidden_weights_ (:, neuron , layer ) end associate end associate end do read_weights find_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_biases read_biases : & associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % biases_ (:, input_layer + layer ) end associate end associate read_biases end do read_hidden_layer_weights_biases allocate ( self % output_weights_ ( num_outputs , neurons_per_layer )) allocate ( self % output_biases_ ( num_outputs )) find_output_weights : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_outut_layer_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[[\" ) /= 0 ) exit end do find_output_weights read_output_weights : & do neuron = 1 , size ( self % hidden_weights_ , 2 ) if ( neuron /= 1 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % output_weights_ (:, neuron ) end associate end associate end do read_output_weights find_output_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_outut_layer_weights: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_output_biases associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) read ( unbracketed_line , * ) self % output_biases_ (:) end associate end associate rewind ( file_unit ) end subroutine read_weights_and_biases subroutine count_hidden_layers ( file_unit , buffer_size , hidden_layers ) integer , intent ( in ) :: file_unit , buffer_size integer , intent ( out ) :: hidden_layers integer , parameter :: input_layer = 1 , output_layer = 1 integer layers , io_status character ( len = buffer_size ) line_buffer rewind ( file_unit ) layers = 0 io_status = 0 do while ( io_status == 0 ) read ( file_unit , '(a)' , iostat = io_status ) line_buffer if ( index ( line_buffer , \"[[\" ) /= 0 ) layers = layers + 1 end do hidden_layers = layers - ( input_layer + output_layer ) rewind ( file_unit ) end subroutine subroutine count_outputs ( file_unit , buffer_size , num_hidden_layers , output_count ) integer , intent ( in ) :: file_unit , buffer_size , num_hidden_layers integer , intent ( out ) :: output_count character ( len = buffer_size ) line_buffer integer , parameter :: input_layer = 1 , output_layer = 1 integer layer rewind ( file_unit ) layer = 0 find_end_of_hidden_layers : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"read_hidden_layers: io_status==0\" , io_status ) if ( index ( line_buffer , \"]]\" ) /= 0 ) layer = layer + 1 if ( layer == input_layer + num_hidden_layers + output_layer ) exit end do find_end_of_hidden_layers find_and_read_output_biases : & do read ( file_unit , '(a)' , iostat = io_status ) line_buffer call assert ( io_status == 0 , \"find_output_biases: io_status==0\" , io_status ) if ( index ( line_buffer , \"[\" ) /= 0 ) exit end do find_and_read_output_biases associate ( last_opening_bracket => index ( line_buffer , \"[\" , back = . true .), first_closing_bracket => index ( line_buffer , \"]\" )) associate ( unbracketed_line => line_buffer ( last_opening_bracket + 1 : first_closing_bracket - 1 )) output_count = num_array_elements_in ( unbracketed_line ) end associate end associate rewind ( file_unit ) end subroutine end procedure read_network module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , comma = 1 csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => self % num_hidden_layers (), neurons_per_layer => self % neurons_per_layer (), & num_outputs => self % num_outputs (), num_inputs => self % num_inputs ()) associate ( num_lines => & outer_object_braces + hidden_layer_outer_brackets & + ( num_hidden_layers + 1 ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % input_weights_ (:, neuron ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ],\" , \"         ] \" , line /= num_hidden_layers + 1 ))) do layer = 1 , num_hidden_layers line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % hidden_weights_ (:, neuron , layer ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) self % output_weights_ ( neuron ,:) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) deallocate ( comma_separated_values ) line = line + 1 write ( single_value , fmt = csv_format ) self % output_biases_ ( neuron ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" ) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure from_json type ( string_t ), allocatable :: lines (:) type ( layer_t ) hidden_layers type ( neuron_t ) output_neuron lines = file_ % lines () call assert ( adjustl ( lines ( 1 )% string ()) == \"{\" , \"from_json: expecting '{' for to start outermost object\" , lines ( 1 )% string ()) call assert ( adjustl ( lines ( 2 )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( 2 )% string ()) block integer , parameter :: first_layer_line = 3 , lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = first_layer_line ) associate ( output_layer_line_number => first_layer_line + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_neuron = neuron_t ( lines , start = output_layer_line_number + 1 ) end associate end block inference_engine % input_weights_ = hidden_layers % input_weights () call assert ( hidden_layers % next_allocated (), \"inference_engine_t%from_json: next layer exists\" ) block type ( layer_t ), pointer :: next_layer next_layer => hidden_layers % next_pointer () inference_engine % hidden_weights_ = next_layer % hidden_weights () end block inference_engine % biases_ = hidden_layers % hidden_biases () associate ( output_weights => output_neuron % weights ()) inference_engine % output_weights_ = reshape ( output_weights , [ 1 , size ( output_weights )]) inference_engine % output_biases_ = [ output_neuron % bias ()] end associate if ( present ( activation_strategy )) then inference_engine % activation_strategy_ = activation_strategy else inference_engine % activation_strategy_ = step_t () end if if ( present ( inference_strategy )) then inference_engine % inference_strategy_ = inference_strategy else inference_engine % inference_strategy_ = matmul_t () end if call assert_consistent ( inference_engine ) end procedure from_json end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"matmul_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_s.f90~~EfferentGraph sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules matmul_s Source Code matmul_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matmul_m ) matmul_s implicit none contains module procedure infer real ( rkind ), allocatable :: neuron (:,:) associate ( num_layers => size ( biases , 2 )) associate ( neurons_per_layer => size ( input_weights , 2 )) allocate ( neuron ( neurons_per_layer , num_layers )) end associate block integer , parameter :: input_layer = 1 neuron (:, input_layer ) = & activation_strategy % activation ( matmul ( transpose ( input_weights (:,:)), input (:)) + biases (:, input_layer )) end block block integer layer do layer = 2 , num_layers neuron (:, layer ) = & activation_strategy % activation ( matmul ( transpose ( hidden_weights (:,:, layer - 1 )), neuron (:, layer - 1 )) + biases (:, layer )) end do end block output = activation_strategy % activation ( matmul ( output_weights (:,:), neuron (:, num_layers )) + output_biases (:)) end associate end procedure end submodule matmul_s","tags":"","loc":"sourcefile/matmul_s.f90.html"},{"title":"matmul_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~matmul_m.f90~~EfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~matmul_m.f90~~AfferentGraph sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules matmul_m Source Code matmul_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matmul_m !! Perform inference using the matrix multiplication intrinsic function inside `do concurrent` constructs !! to compute matrix-vector multiplies for forward information propagation from layer to layer use inference_strategy_m , only : inference_strategy_t use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: matmul_t type , extends ( inference_strategy_t ) :: matmul_t contains procedure , nopass :: infer end type interface pure module function infer ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer real ( rkind ), intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs class ( activation_strategy_t ), intent ( in ) :: activation_strategy real ( rkind ), allocatable :: output (:) end function end interface end module matmul_m","tags":"","loc":"sourcefile/matmul_m.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules neuron_m Source Code neuron_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules neuron_s Source Code neuron_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"read_json: neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"read_json: neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"read_json: neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"read_json: neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"file_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~file_s.f90~~EfferentGraph sourcefile~file_s.f90 file_s.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~file_s.f90->sourcefile~file_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules file_s Source Code file_s.f90 Source Code submodule ( file_m ) file_s use iso_fortran_env , only : iostat_end , iostat_eor , output_unit use assert_m , only : assert implicit none contains module procedure construct file_object % lines_ = lines end procedure module procedure write_lines integer file_unit , io_status , l call assert ( allocated ( self % lines_ ), \"file_t%write_lines: allocated(self%lines_)\" ) if ( present ( file_name )) then open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'unknown' , iostat = io_status , action = 'write' ) call assert ( io_status == 0 , \"write_lines: io_status==0 after 'open' statement\" , file_name % string ()) else file_unit = output_unit end if do l = 1 , size ( self % lines_ ) write ( file_unit , * ) self % lines_ ( l )% string () end do if ( present ( file_name )) close ( file_unit ) end procedure module procedure read_lines integer io_status , file_unit , line_num character ( len = :), allocatable :: line integer , parameter :: max_message_length = 128 character ( len = max_message_length ) error_message integer , allocatable :: lengths (:) open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) call assert ( io_status == 0 , \"read_lines: io_status==0 after 'open' statement\" , file_name % string ()) lengths = line_lengths ( file_unit ) associate ( num_lines => size ( lengths )) allocate ( file_object % lines_ ( num_lines )) do line_num = 1 , num_lines allocate ( character ( len = lengths ( line_num )) :: line ) read ( file_unit , '(a)' , iostat = io_status , iomsg = error_message ) line call assert ( io_status == 0 , \"read_lines: io_status==0 after line read\" , error_message ) file_object % lines_ ( line_num ) = string_t ( line ) deallocate ( line ) end do end associate close ( file_unit ) contains function line_count ( file_unit ) result ( num_lines ) integer , intent ( in ) :: file_unit integer num_lines rewind ( file_unit ) num_lines = 0 do read ( file_unit , * , iostat = io_status ) if ( io_status == iostat_end ) exit num_lines = num_lines + 1 end do rewind ( file_unit ) end function function line_lengths ( file_unit ) result ( lengths ) integer , intent ( in ) :: file_unit integer , allocatable :: lengths (:) integer io_status character ( len = 1 ) c associate ( num_lines => line_count ( file_unit )) allocate ( lengths ( num_lines ), source = 0 ) rewind ( file_unit ) do line_num = 1 , num_lines do read ( file_unit , '(a)' , advance = 'no' , iostat = io_status , iomsg = error_message ) c if ( io_status == iostat_eor . or . io_status == iostat_end ) exit lengths ( line_num ) = lengths ( line_num ) + 1 end do end do rewind ( file_unit ) end associate end function end procedure module procedure lines my_lines = self % lines_ end procedure end submodule file_s","tags":"","loc":"sourcefile/file_s.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layer_m Source Code layer_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: count_layers procedure :: count_neurons procedure :: input_weights procedure :: hidden_weights procedure :: hidden_biases procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function input_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:) end function module function hidden_weights ( self ) result ( weights ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: weights (:,:,:) end function module function hidden_biases ( self ) result ( biases ) implicit none class ( layer_t ), intent ( in ), target :: self real ( rkind ), allocatable :: biases (:,:) end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~step_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"inference_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_strategy_m.f90~~EfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_strategy_m.f90~~AfferentGraph sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~concurrent_dot_products_m.f90 concurrent_dot_products_m.f90 sourcefile~concurrent_dot_products_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90->sourcefile~matmul_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~matmul_s.f90 matmul_s.f90 sourcefile~matmul_s.f90->sourcefile~matmul_m.f90 sourcefile~concurrent_dot_products_s.f90 concurrent_dot_products_s.f90 sourcefile~concurrent_dot_products_s.f90->sourcefile~concurrent_dot_products_m.f90 sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~convert-to-json.f90->sourcefile~matmul_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_strategy_m Source Code inference_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_strategy_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind implicit none private public :: inference_strategy_t type , abstract :: inference_strategy_t contains procedure ( infer_interface ), nopass , deferred :: infer end type abstract interface pure function infer_interface ( & input , input_weights , hidden_weights , biases , output_biases , output_weights , activation_strategy & ) result ( output ) import activation_strategy_t , rkind implicit none real ( rkind ), intent ( in ) :: input (:) real ( rkind ), intent ( in ), allocatable :: input_weights (:,:) !! weights applied to go from the inputs to first hidden layer real ( rkind ), intent ( in ), allocatable :: hidden_weights (:,:,:) !! weights applied to go from one hidden layer to the next real ( rkind ), intent ( in ), allocatable :: output_weights (:,:) !! weights applied to go from the final hidden layer to the outputs real ( rkind ), intent ( in ), allocatable :: output_biases (:) !! neuronal offsets applied to outputs real ( rkind ), intent ( in ), allocatable :: biases (:,:) !! neuronal offsets for each hidden layer class ( activation_strategy_t ), intent ( in ) :: activation_strategy real ( rkind ), allocatable :: output (:) end function end interface end module inference_strategy_m","tags":"","loc":"sourcefile/inference_strategy_m.f90.html"},{"title":"concurrent-inference.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent-inference.f90~~EfferentGraph sourcefile~concurrent-inference.f90 concurrent-inference.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inference.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~concurrent-inference.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs concurrent_inferences Source Code concurrent-inference.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program concurrent_inferences !! This program demonstrates how to read multiple neural networks, each from a !! separate file, into an array of inference_engine_t objects and then perform !! inference concurrently using the resulting inference_engine_t array. use string_m , only : string_t , array_of_strings use inference_engine_m , only : inference_engine_t use command_line_m , only : command_line_t use kind_parameters_m , only : rkind implicit none logical , allocatable :: test_passes (:) type ( inference_engine_t ), allocatable :: inference_engine (:) type ( command_line_t ) command_line type ( string_t ), allocatable :: file_names (:) character ( len = :), allocatable :: input_files real ( rkind ), allocatable :: truth_table (:) real ( rkind ), parameter :: tolerance = 1.E-08 , false = 0. , true = 1. real ( rkind ), parameter :: input_array ( * , * ) = reshape ([ true , true , false , true , true , false , false , false ], shape = [ 2 , 4 ]) real ( rkind ), parameter :: expected_result ( * ) = [ false , true , true , false ] integer i input_files = command_line % flag_value ( \"--input-files\" ) if ( len ( input_files ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example concurrent-inference -- --input-files \"<space-delimited-list-of-files>\"' end if print * , \"Defining an array of inference_engine_t objects by reading the following files: \" , input_files file_names = array_of_strings ( input_files , delimiter = \" \" ) associate ( num_engines => size ( file_names )) allocate ( inference_engine ( num_engines )) do i = 1 , num_engines call inference_engine ( i )% read_network ( file_names ( i )) end do allocate ( truth_table ( num_engines )) do concurrent ( i = 1 : num_engines ) associate ( inference => inference_engine ( i )% infer ( input_array (:, i ))) truth_table ( i ) = inference ( 1 ) end associate end do associate ( test_passed => abs ( truth_table - expected_result ) < tolerance ) print * , test_passed end associate end associate end program","tags":"","loc":"sourcefile/concurrent-inference.f90.html"},{"title":"convert-to-json.f90 – Inference-Engine","text":"This file depends on sourcefile~~convert-to-json.f90~~EfferentGraph sourcefile~convert-to-json.f90 convert-to-json.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~convert-to-json.f90->sourcefile~matmul_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~convert-to-json.f90->sourcefile~file_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~convert-to-json.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~convert-to-json.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~convert-to-json.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs convert_to_json Source Code convert-to-json.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program convert_to_json !! This program demonstrates how to read a neural network in a custom file format !! into an inference_engine_t object, convert it to a JSON format, and write the !! resulting JSON objects to a file. use assert_m , only : assert use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use sigmoid_m , only : sigmoid_t use matmul_m , only : matmul_t use kind_parameters_m , only : rkind use file_m , only : file_t implicit none type ( inference_engine_t ) inference_engine type ( command_line_t ) command_line character ( len = :), allocatable :: input_file_name type ( file_t ) json_output_file input_file_name = command_line % flag_value ( \"--input-file\" ) if ( len ( input_file_name ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example convert-to-json -- --input-file \"<file-name>\"' end if print * , \"Defining an inference_engine_t object by reading the file '\" // input_file_name // \"'\" call inference_engine % read_network ( string_t ( input_file_name ), sigmoid_t (), matmul_t ()) print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () associate ( num_inputs => inference_engine % num_inputs ()) print * , \"num_inputs = \" , num_inputs block real ( rkind ), parameter :: inputs ( * ) = & [ real ( rkind ) :: 0.0079 , 1.4429e-12 , 0.0000e+00 , 0.0000e+00 , 0.0000e+00 , 4.4941e-04 , 0.0000e+00 , 0. , 28 2.2671 , 7154 1.9766 ] call assert ( num_inputs == size ( inputs ), \"main: num_inputs==size(inputs)\" , num_inputs ) print * , inference_engine % infer ( inputs ) end block end associate print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = inference_engine % to_json () associate ( output_file_name => string_t ( input_file_name // \".json\" )) print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"'.\" call json_output_file % write_lines ( output_file_name ) end associate end program","tags":"","loc":"sourcefile/convert-to-json.f90.html"},{"title":"read.f90 – Inference-Engine","text":"This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~read.f90->sourcefile~matmul_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~read.f90->sourcefile~file_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~read.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs read_json Source Code read.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_json !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use step_m , only : step_t use file_m , only : file_t implicit none type ( string_t ) input_file_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example read -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name ), step_t (), matmul_t ()) print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () end program","tags":"","loc":"sourcefile/read.f90.html"},{"title":"construct-and-write.f90 – Inference-Engine","text":"This file depends on sourcefile~~construct-and-write.f90~~EfferentGraph sourcefile~construct-and-write.f90 construct-and-write.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~construct-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~construct-and-write.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs construct_and_write Source Code construct-and-write.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program construct_and_write !! This program demonstrates how to construct a neural network from arrays of weights and biases !! and how to write the resulting object to a file in the format that is readable by the !! inference_engine_t read_network type-bound procedure. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use kind_parameters_m , only : rkind implicit none type ( inference_engine_t ) xor type ( command_line_t ) command_line character ( len = :), allocatable :: output_file_name integer i , j integer , parameter :: identity ( * , * , * ) = reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , 3 ), j = 1 , 3 )], shape = [ 3 , 3 , 1 ]) output_file_name = command_line % flag_value ( \"--output-file\" ) if ( len ( output_file_name ) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example construct-and-write -- --output-file \"<file-name>\"' end if xor = inference_engine_t ( & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ 2 , 3 ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ 1 , 3 ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ 3 , 2 ]), & output_biases = [ real ( rkind ) :: 0. ] & ) print * , \"Writing an inference_engine_t object to the file '\" // output_file_name // \"'\" call xor % write_network ( string_t ( output_file_name )) end program","tags":"","loc":"sourcefile/construct-and-write.f90.html"},{"title":"netCDF_IO.f90 – Inference-Engine","text":"Contents Programs netCDF_IO Source Code netCDF_IO.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program netCDF_IO use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert implicit none integer i , j integer , parameter :: ny = 12 , nx = 6 integer , parameter :: data_written ( * , * ) = reshape ([(( i * j , i = 1 , nx ), j = 1 , ny )], [ ny , nx ]) integer , allocatable :: data_read (:,:) character ( len =* ), parameter :: file_name = \"netCDF_example.nc\" call netCDF_write ( file_name , data_written ) call netCDF_read ( file_name , data_read ) call assert ( all ( data_written == data_read ) , \"netCDF_IO: all(data_written == data_read)\" ) print * , \"-----> netCDF file '\" // file_name // \"' written and read without error <-----\" contains subroutine netCDF_write ( file_name_ , data_out ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( in ) :: data_out (:,:) integer ncid , varid , x_dimid , y_dimid associate ( nf_status => nf90_create ( file_name_ , nf90_clobber , ncid )) ! create or ovewrite file call assert ( nf_status == nf90_noerr , \"nf90_create(file_name, nf90_clobber, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"x\" , size ( data_out , 2 ), x_dimid )) ! define x dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"x\",size(data_out,2),x_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_dim ( ncid , \"y\" , size ( data_out , 1 ), y_dimid )) ! define y dimension & get its ID call assert ( nf_status == nf90_noerr , 'nf90_def_dim(ncid,\"y\",size(data_out,2),y_dimid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_def_var ( ncid , \"data\" , nf90_int , [ y_dimid , x_dimid ], varid )) !define integer 'data' variable & get ID call assert ( nf_status == nf90_noerr , 'nf90_def_var(ncid,\"data\",nf90_int,[y_dimid,x_dimid],varid) succeds' , & trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_enddef ( ncid )) ! exit define mode: tell netCDF we are done defining metadata call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_enddef(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_put_var ( ncid , varid , data_out )) ! write all data to file call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_put_var(ncid, varid, data_out)' , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_close ( ncid )) ! close file to free associated netCDF resources and flush buffers call assert ( nf_status == nf90_noerr , 'nff90_noerr == nf90_close(ncid)' , trim ( nf90_strerror ( nf_status ))) end associate end subroutine subroutine netCDF_read ( file_name_ , data_in ) character ( len =* ), intent ( in ) :: file_name_ integer , intent ( inout ), allocatable :: data_in (:,:) integer ncid , varid , data_in_rank associate ( nf_status => nf90_open ( file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(file_name_, NF90_NOWRITE, ncid) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate associate ( nf_status => nf90_inq_varid ( ncid , \"data\" , varid )) ! Get data variable's ID call assert ( nf_status == nf90_noerr , 'nf90_inq_varid(ncid, \"data\", varid) succeeds' , trim ( nf90_strerror ( nf_status ))) end associate associate ( data_in_shape => get_shape ( ncid , \"data\" )) allocate ( data_in ( data_in_shape ( 1 ), data_in_shape ( 2 ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , data_in )) ! Read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, data_in) succeeds\" , trim ( nf90_strerror ( nf_status ))) end associate end subroutine function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inq_varid(ncid, varname, varid) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // trim ( varid_string ) // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, ndims = var_rank) (\" // & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_variable(ncid, varid, dimids = dimIds(:var_rank))\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"nf90_noerr == nf90_inquire_dimension(ncid, dimIds(i), len = dimlen)\" , & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function end program netCDF_IO","tags":"","loc":"sourcefile/netcdf_io.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~write-read-infer.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90 matmul_m.f90 sourcefile~write-read-infer.f90->sourcefile~matmul_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_strategy_m.f90 inference_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~matmul_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~matmul_m.f90->sourcefile~inference_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs write_read_infer Source Code write-read-infer.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use matmul_m , only : matmul_t use step_m , only : step_t use file_m , only : file_t use kind_parameters_m , only : rkind implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example write-read-infer -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name integer i , j integer , parameter :: num_inputs = 2 , num_outputs = 1 , num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = inference_engine_t ( & input_weights = real ( reshape ([ 1 , 0 , 1 , 1 , 0 , 1 ], [ num_inputs , num_neurons ]), rkind ), & hidden_weights = real ( identity , rkind ), & output_weights = real ( reshape ([ 1 , - 2 , 1 ], [ num_outputs , num_neurons ]), rkind ), & biases = reshape ([ real ( rkind ) :: 0. , - 1.99 , 0. , 0. , 0. , 0. ], [ num_neurons , num_hidden_layers ]), & output_biases = [ real ( rkind ) :: 0. ], & inference_strategy = matmul_t () & ) print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file , step_t (), matmul_t ()) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"num_outputs = \" , inference_engine % num_outputs () print * , \"num_hidden_layers = \" , inference_engine % num_hidden_layers () print * , \"neurons_per_layer = \" , inference_engine % neurons_per_layer () print * , \"Performing inference:\" print * , \"inference_engine%infer([0.,1.]) =\" , inference_engine % infer ([ real ( rkind ) :: 0. , 1. ]) print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"}]}