var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine supports research in concurrent, large-batch inference and training of deep, feed-forward neural networks. Inference-Engine targets high-performance computing (HPC) applications with performance-critical inference and training needs.  The initial target application is in situ training of a cloud microphysics model proxy for the Intermediate Complexity Atmospheric Research ( ICAR ) model.  Such a proxy must support concurrent inference at every grid point at every time step of an ICAR run.  For validation purposes, Inference-Engine also supports the export and import of neural networks to and from Python by the companion package nexport . The features of Inference-Engine that make it suitable for use in HPC applications include Implementation in Fortran 2018. Exposing concurrency via Elemental , implicitly pure inference procedures, An elemental and implicitly pure activation strategy, and A pure training subroutine, Gathering network weights and biases into contiguous arrays for efficient memory access patterns, and User-controlled mini-batch size facilitating in situ training at application runtime. Making Inference-Engine's infer functions and train subroutines pure facilitates invoking those procedures inside Fortran do concurrent constructs, which some compilers can offload automatically to graphics processing units (GPUs).  The use of contiguous arrays facilitates spatial locality in memory access patterns.  User control of mini-batch size facilitates in-situ training at application runtime. The available optimizers for training neural networks are\n1. Stochastic gradient descent\n2. Adam (recommended) Prerequisite Building Inference-Engine requires a Fortran 2018 compiler.  With gfortran , the required minimum compiler version is 13. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the codes in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Configuring a Training Run To see the format for a JSON configuration file that defines the hyperparameters and a new network configuration for a training run, execute the provided training-configuration output example program: % ./build/run-fpm.sh run --example print-training-configuration Project is up to date { \"hyperparameters\" : { \"mini-batches\" : 10 , \"learning rate\" : 1.50000000 , \"optimizer\" : \"adam\" } , \"network configuration\" : { \"skip connections\" : false , \"nodes per layer\" : [ 2 , 72 , 2 ], \"activation function\" : \"sigmoid\" } } As of this writing, the JSON file format is fragile.  Because an Intel ifx compiler bug prevents using our preferred JSON interface, rojff , Inference-Engine currently uses a very restricted JSON subset written and read by the sourcery utility's string_t type-bound procedures.  For this to work, it is important to keep input files as close as possible to the exact form shown above.  In particular, do not split, combine or reorder lines. Adding or removing whitespace should be ok. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Berkeley Lab","tags":"home","loc":"index.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/sigmoid_t.html"},{"title":"input_output_pair_t – Inference-Engine ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor public        interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) Type-Bound Procedures procedure, public :: expected_outputs interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, public :: inputs interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"type/input_output_pair_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public        interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer procedure, public :: num_inputs interface private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"tensor_t – Inference-Engine ","text":"type, public :: tensor_t Inherited by type~~tensor_t~~InheritedByGraph type~tensor_t tensor_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: values_ (:) Constructor public        interface tensor_t private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) Type-Bound Procedures procedure, public :: num_components interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer procedure, public :: values interface private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"type/tensor_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~exchange_t exchange_t type~exchange_t->type~activation_strategy_t activation_strategy_ type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~step_t step_t type~step_t->type~activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred :: function_name elemental function function_name_i(self) result(string) Prototype Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"relu_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: relu_t Inherits type~~relu_t~~InheritsGraph type~relu_t relu_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~relu_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/relu_t.html"},{"title":"ubounds_t – Inference-Engine ","text":"type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical generic, public :: operator(==) => equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/ubounds_t.html"},{"title":"mini_batch_t – Inference-Engine ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor public        interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) Type-Bound Procedures procedure, public :: input_output_pairs interface private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"type/mini_batch_t.html"},{"title":"trainable_engine_t – Inference-Engine ","text":"type, public :: trainable_engine_t Encapsulate the information needed to perform training Inherits type~~trainable_engine_t~~InheritsGraph type~trainable_engine_t trainable_engine_t string_t string_t type~trainable_engine_t->string_t metadata_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor public        interface trainable_engine_t private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) Type-Bound Procedures procedure, public :: assert_consistent interface private pure module subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self procedure, public :: infer interface private elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: num_inputs interface private elemental module function num_inputs(self) result(n_in) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_layers interface private elemental module function num_layers(self) result(n_layers) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module function num_outputs(self) result(n_out) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: to_inference_engine interface private module function to_inference_engine(self) result(inference_engine) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) procedure, public :: train interface private pure module subroutine train(self, mini_batches, cost, adam, learning_rate) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"type/trainable_engine_t.html"},{"title":"network_configuration_t – Inference-Engine ","text":"type, public :: network_configuration_t Inherited by type~~network_configuration_t~~InheritedByGraph type~network_configuration_t network_configuration_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Type-Bound Procedures procedure, public :: activation_name interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: skip_connections interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/network_configuration_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/step_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred :: function_name elemental function function_name_i(self) result(string) Prototype Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"hyperparameters_t – Inference-Engine ","text":"type, public :: hyperparameters_t Inherited by type~~hyperparameters_t~~InheritedByGraph type~hyperparameters_t hyperparameters_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor public        interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Type-Bound Procedures procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/hyperparameters_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/swish_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public        interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target Type-Bound Procedures procedure, public :: count_inputs interface private module function count_inputs(layer) result(num_inputs) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer procedure, public :: count_layers interface private module function count_layers(layer) result(num_layers) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module function count_neurons(layer) result(neurons_per_layer) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) procedure, public :: inference_engine interface private module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) procedure, public :: neurons_per_layer interface private module function neurons_per_layer(self) result(num_neurons) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module function next_allocated(self) result(next_is_allocated) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module function next_pointer(self) result(next_ptr) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer","tags":"","loc":"type/layer_t.html"},{"title":"difference_t – Inference-Engine ","text":"type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm interface private elemental module function norm(self) result(norm_of_self) Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"type/difference_t.html"},{"title":"exchange_t – Inference-Engine ","text":"type, public :: exchange_t Inherits type~~exchange_t~~InheritsGraph type~exchange_t exchange_t string_t string_t type~exchange_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~exchange_t->type~activation_strategy_t activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) real(kind=rkind), public, allocatable :: weights_ (:,:,:)","tags":"","loc":"type/exchange_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor public        interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module function activation_function_name(self) result(activation_name) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module subroutine assert_conformable_with(self, inference_engine) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine procedure, public :: infer interface public elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(node_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) procedure, public :: num_inputs interface private elemental module function num_inputs(self) result(input_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module function num_outputs(self) result(output_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private  interface subtract () Arguments None procedure, public :: skip interface private pure module function skip(self) result(use_skip_connections) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_exchange interface private pure module function to_exchange(self) result(exchange) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) procedure, public :: to_json interface private impure elemental module function to_json(self) result(json_file) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: subtract interface private elemental module function subtract(self, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"training_configuration_t – Inference-Engine ","text":"type, public, extends(file_t) :: training_configuration_t Inherits type~~training_configuration_t~~InheritsGraph type~training_configuration_t training_configuration_t file_t file_t type~training_configuration_t->file_t type~hyperparameters_t hyperparameters_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ type~network_configuration_t network_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor public        interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Type-Bound Procedures procedure, public :: differentiable_activation_strategy interface private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: skip_connections interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/training_configuration_t.html"},{"title":"activation_i – Inference-Engine","text":"interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"function_name_i – Inference-Engine","text":"interface public elemental function function_name_i(self) result(string) Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name_i.html"},{"title":"activation – Inference-Engine","text":"interface Called by interface~~activation~~CalledByGraph interface~activation sigmoid_m::sigmoid_t%activation proc~activation_derivative~2 swish_s::activation_derivative proc~activation_derivative~2->interface~activation proc~activation~2 swish_s::activation proc~activation~2->interface~activation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Called by interface~~activation_derivative~~CalledByGraph interface~activation_derivative sigmoid_m::sigmoid_t%activation_derivative proc~activation_derivative~2 swish_s::activation_derivative proc~activation_derivative~2->interface~activation_derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"y – Inference-Engine","text":"public impure elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~~CallsGraph proc~y thompson_tensors_m::y assert assert proc~y->assert interface~values tensor_m::tensor_t%values proc~y->interface~values proc~rsif module_mp_thompson::RSIF proc~y->proc~rsif proc~rslf module_mp_thompson::RSLF proc~y->proc~rslf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~~CalledByGraph proc~y thompson_tensors_m::y program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y.html"},{"title":"RSIF – Inference-Engine","text":"public  function RSIF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rsif~~CalledByGraph proc~rsif module_mp_thompson::RSIF proc~y thompson_tensors_m::y proc~y->proc~rsif program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF","tags":"","loc":"proc/rsif.html"},{"title":"RSLF – Inference-Engine","text":"public  function RSLF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rslf~~CalledByGraph proc~rslf module_mp_thompson::RSLF proc~y thompson_tensors_m::y proc~y->proc~rslf program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF","tags":"","loc":"proc/rslf.html"},{"title":"input_output_pair_t – Inference-Engine","text":"public interface input_output_pair_t Functions private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"shuffle – Inference-Engine","text":"interface Called by interface~~shuffle~~CalledByGraph interface~shuffle input_output_pair_m::shuffle program~learn_addition learn_addition program~learn_addition->interface~shuffle program~learn_exponentiation learn_exponentiation program~learn_exponentiation->interface~shuffle program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->interface~shuffle program~learn_multiplication learn_multiplication program~learn_multiplication->interface~shuffle program~learn_power_series learn_power_series program~learn_power_series->interface~shuffle program~train_and_write train_and_write program~train_and_write->interface~shuffle program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->interface~shuffle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"interface/shuffle.html"},{"title":"expected_outputs – Inference-Engine","text":"interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/inputs.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Functions private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"interface private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"weights – Inference-Engine","text":"interface private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~~CalledByGraph proc~e learn_microphysics_procedures::e proc~perturbed_identity_network learn_microphysics_procedures::perturbed_identity_network proc~perturbed_identity_network->proc~e program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~~CallsGraph proc~perturbed_identity_network learn_microphysics_procedures::perturbed_identity_network proc~e learn_microphysics_procedures::e proc~perturbed_identity_network->proc~e string_t string_t proc~perturbed_identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~~CalledByGraph proc~perturbed_identity_network learn_microphysics_procedures::perturbed_identity_network program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~~CallsGraph proc~open_plot_file_for_appending learn_microphysics_procedures::open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending->file_t lines lines proc~open_plot_file_for_appending->lines string string proc~open_plot_file_for_appending->string string_t string_t proc~open_plot_file_for_appending->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_plot_file_for_appending~~CalledByGraph proc~open_plot_file_for_appending learn_microphysics_procedures::open_plot_file_for_appending program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~open_plot_file_for_appending Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/open_plot_file_for_appending.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~~CallsGraph proc~output learn_microphysics_procedures::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output->interface~to_json~3 write_lines write_lines proc~output->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~~CalledByGraph proc~output learn_microphysics_procedures::output program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~output Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~~CalledByGraph proc~print_diagnostics learn_microphysics_procedures::print_diagnostics program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~print_diagnostics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/print_diagnostics.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~2~~CallsGraph proc~y~2 exponentiation_m::y assert assert proc~y~2->assert interface~values tensor_m::tensor_t%values proc~y~2->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~2~~CalledByGraph proc~y~2 exponentiation_m::y program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~2.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~2~~CalledByGraph proc~e~2 learn_exponentiation::e proc~perturbed_identity_network~2 learn_exponentiation::perturbed_identity_network proc~perturbed_identity_network~2->proc~e~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~2.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~2~~CallsGraph proc~perturbed_identity_network~2 learn_exponentiation::perturbed_identity_network proc~e~2 learn_exponentiation::e proc~perturbed_identity_network~2->proc~e~2 string_t string_t proc~perturbed_identity_network~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~2~~CalledByGraph proc~perturbed_identity_network~2 learn_exponentiation::perturbed_identity_network program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~2.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~2~~CallsGraph proc~output~2 learn_exponentiation::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~2->interface~to_json~3 write_lines write_lines proc~output~2->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~2~~CalledByGraph proc~output~2 learn_exponentiation::output program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~2.html"},{"title":"tensor_t – Inference-Engine","text":"public interface tensor_t Functions private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"interface/tensor_t.html"},{"title":"num_components – Inference-Engine","text":"interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_components.html"},{"title":"values – Inference-Engine","text":"interface Called by interface~~values~~CalledByGraph interface~values tensor_m::tensor_t%values proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~values proc~y thompson_tensors_m::y proc~y->interface~values proc~y~2 exponentiation_m::y proc~y~2->interface~values proc~y~3 power_series::y proc~y~3->interface~values proc~y~4 saturated_mixing_ratio_m::y proc~y~4->interface~values proc~y~5 addition_m::y proc~y~5->interface~values proc~y~6 multiply_inputs::y proc~y~6->interface~values program~learn_addition learn_addition program~learn_addition->proc~y~5 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y~2 program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y~6 program~learn_power_series learn_power_series program~learn_power_series->proc~y~3 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/values.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~3~~CallsGraph proc~y~3 power_series::y assert assert proc~y~3->assert interface~values tensor_m::tensor_t%values proc~y~3->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~3~~CalledByGraph proc~y~3 power_series::y program~learn_power_series learn_power_series program~learn_power_series->proc~y~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~3.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~3~~CalledByGraph proc~e~3 learn_power_series::e proc~perturbed_identity_network~3 learn_power_series::perturbed_identity_network proc~perturbed_identity_network~3->proc~e~3 program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~3.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~3~~CallsGraph proc~perturbed_identity_network~3 learn_power_series::perturbed_identity_network proc~e~3 learn_power_series::e proc~perturbed_identity_network~3->proc~e~3 string_t string_t proc~perturbed_identity_network~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~3~~CalledByGraph proc~perturbed_identity_network~3 learn_power_series::perturbed_identity_network program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~3.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~3~~CallsGraph proc~output~3 learn_power_series::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~3->interface~to_json~3 write_lines write_lines proc~output~3->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~3~~CalledByGraph proc~output~3 learn_power_series::output program~learn_power_series learn_power_series program~learn_power_series->proc~output~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~3.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~2.html"},{"title":"equals – Inference-Engine","text":"public elemental function equals(lhs, rhs) result(lhs_equals_rhs) Type Bound ubounds_t Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~2.html"},{"title":"mini_batch_t – Inference-Engine","text":"public interface mini_batch_t Functions private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"interface/mini_batch_t.html"},{"title":"input_output_pairs – Inference-Engine","text":"interface private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/input_output_pairs.html"},{"title":"identity_network – Inference-Engine","text":"function identity_network() result(inference_engine) Arguments None Return Value type( inference_engine_t ) Calls proc~~identity_network~~CallsGraph proc~identity_network write_read_infer::identity_network string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~identity_network~~CalledByGraph proc~identity_network write_read_infer::identity_network proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->proc~identity_network program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/identity_network.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_infer::write_read_query_infer file_t file_t proc~write_read_query_infer->file_t interface~activation_function_name inference_engine_m_::inference_engine_t%activation_function_name proc~write_read_query_infer->interface~activation_function_name interface~infer~2 inference_engine_m_::inference_engine_t%infer proc~write_read_query_infer->interface~infer~2 interface~nodes_per_layer~2 inference_engine_m_::inference_engine_t%nodes_per_layer proc~write_read_query_infer->interface~nodes_per_layer~2 interface~num_inputs~3 inference_engine_m_::inference_engine_t%num_inputs proc~write_read_query_infer->interface~num_inputs~3 interface~num_outputs~2 inference_engine_m_::inference_engine_t%num_outputs proc~write_read_query_infer->interface~num_outputs~2 interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~write_read_query_infer->interface~to_json~3 interface~values tensor_m::tensor_t%values proc~write_read_query_infer->interface~values proc~identity_network write_read_infer::identity_network proc~write_read_query_infer->proc~identity_network string string proc~write_read_query_infer->string write_lines write_lines proc~write_read_query_infer->write_lines string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_infer::write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"trainable_engine_t – Inference-Engine","text":"public interface trainable_engine_t Functions private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t )","tags":"","loc":"interface/trainable_engine_t.html"},{"title":"assert_consistent – Inference-Engine","text":"interface private pure module subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent.html"},{"title":"infer – Inference-Engine","text":"interface private elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer.html"},{"title":"num_inputs – Inference-Engine","text":"interface private elemental module function num_inputs(self) result(n_in) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"interface private elemental module function num_layers(self) result(n_layers) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_layers.html"},{"title":"num_outputs – Inference-Engine","text":"interface private elemental module function num_outputs(self) result(n_out) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"to_inference_engine – Inference-Engine","text":"interface private module function to_inference_engine(self) result(inference_engine) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t )","tags":"","loc":"interface/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"interface private pure module subroutine train(self, mini_batches, cost, adam, learning_rate) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"interface/train.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~4~~CallsGraph proc~perturbed_identity_network~4 train_and_write::perturbed_identity_network string_t string_t proc~perturbed_identity_network~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~4~~CalledByGraph proc~perturbed_identity_network~4 train_and_write::perturbed_identity_network program~train_and_write train_and_write program~train_and_write->proc~perturbed_identity_network~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~4.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~4~~CallsGraph proc~output~4 train_and_write::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~4->interface~to_json~3 write_lines write_lines proc~output~4->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~4~~CalledByGraph proc~output~4 train_and_write::output program~train_and_write train_and_write program~train_and_write->proc~output~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~4.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~4~~CallsGraph proc~y~4 saturated_mixing_ratio_m::y assert assert proc~y~4->assert interface~values tensor_m::tensor_t%values proc~y~4->interface~values proc~saturated_mixing_ratio saturated_mixing_ratio_m::saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~4~~CalledByGraph proc~y~4 saturated_mixing_ratio_m::y program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~4.html"},{"title":"saturated_mixing_ratio – Inference-Engine","text":"private pure function saturated_mixing_ratio(T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real Called by proc~~saturated_mixing_ratio~~CalledByGraph proc~saturated_mixing_ratio saturated_mixing_ratio_m::saturated_mixing_ratio proc~y~4 saturated_mixing_ratio_m::y proc~y~4->proc~saturated_mixing_ratio program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/saturated_mixing_ratio.html"},{"title":"network_configuration_t – Inference-Engine","text":"public interface network_configuration_t Functions private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t )","tags":"","loc":"interface/network_configuration_t.html"},{"title":"activation_name – Inference-Engine","text":"interface Called by interface~~activation_name~~CalledByGraph interface~activation_name network_configuration_m::network_configuration_t%activation_name proc~differentiable_activation_strategy training_configuration_s::differentiable_activation_strategy proc~differentiable_activation_strategy->interface~activation_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_name.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Called by interface~~nodes_per_layer~~CalledByGraph interface~nodes_per_layer network_configuration_m::network_configuration_t%nodes_per_layer proc~nodes_per_layer training_configuration_s::nodes_per_layer proc~nodes_per_layer->interface~nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer.html"},{"title":"skip_connections – Inference-Engine","text":"interface Called by interface~~skip_connections~~CalledByGraph interface~skip_connections network_configuration_m::network_configuration_t%skip_connections proc~skip_connections training_configuration_s::skip_connections proc~skip_connections->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~3.html"},{"title":"hyperparameters_t – Inference-Engine","text":"public interface hyperparameters_t Functions private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t )","tags":"","loc":"interface/hyperparameters_t.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~2.html"},{"title":"learning_rate – Inference-Engine","text":"interface Called by interface~~learning_rate~~CalledByGraph interface~learning_rate hyperparameters_m::hyperparameters_t%learning_rate proc~learning_rate~2 training_configuration_s::learning_rate proc~learning_rate~2->interface~learning_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"interface Called by interface~~mini_batches~~CalledByGraph interface~mini_batches hyperparameters_m::hyperparameters_t%mini_batches proc~mini_batches~2 training_configuration_s::mini_batches proc~mini_batches~2->interface~mini_batches Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches.html"},{"title":"optimizer_name – Inference-Engine","text":"interface Called by interface~~optimizer_name~~CalledByGraph interface~optimizer_name hyperparameters_m::hyperparameters_t%optimizer_name proc~optimizer_name~2 training_configuration_s::optimizer_name proc~optimizer_name~2->interface~optimizer_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~2~~CalledByGraph interface~to_json~2 hyperparameters_m::hyperparameters_t%to_json proc~from_components~2 training_configuration_s::from_components proc~from_components~2->interface~to_json~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~2.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~4.html"},{"title":"activation_derivative – Inference-Engine","text":"interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~4.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~5~~CallsGraph proc~y~5 addition_m::y assert assert proc~y~5->assert interface~values tensor_m::tensor_t%values proc~y~5->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~5~~CalledByGraph proc~y~5 addition_m::y program~learn_addition learn_addition program~learn_addition->proc~y~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~5.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~4~~CalledByGraph proc~e~4 learn_addition::e proc~perturbed_identity_network~5 learn_addition::perturbed_identity_network proc~perturbed_identity_network~5->proc~e~4 program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~4.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~5~~CallsGraph proc~perturbed_identity_network~5 learn_addition::perturbed_identity_network proc~e~4 learn_addition::e proc~perturbed_identity_network~5->proc~e~4 string_t string_t proc~perturbed_identity_network~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~5~~CalledByGraph proc~perturbed_identity_network~5 learn_addition::perturbed_identity_network program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~5.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~5~~CallsGraph proc~output~5 learn_addition::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~5->interface~to_json~3 write_lines write_lines proc~output~5->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~5~~CalledByGraph proc~output~5 learn_addition::output program~learn_addition learn_addition program~learn_addition->proc~output~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~5.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target","tags":"","loc":"interface/layer_t.html"},{"title":"count_inputs – Inference-Engine","text":"interface private module function count_inputs(layer) result(num_inputs) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer","tags":"","loc":"interface/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"interface private module function count_layers(layer) result(num_layers) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface private module function count_neurons(layer) result(neurons_per_layer) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"interface private module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface private module function neurons_per_layer(self) result(num_neurons) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface private module function next_allocated(self) result(next_is_allocated) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface private module function next_pointer(self) result(next_ptr) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"infer – Inference-Engine","text":"interface Called by interface~~infer~2~~CalledByGraph interface~infer~2 inference_engine_m_::inference_engine_t%infer proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~infer~2 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer~2.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Functions private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Called by interface~~activation_function_name~~CalledByGraph interface~activation_function_name inference_engine_m_::inference_engine_t%activation_function_name proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~activation_function_name program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_function_name(self) result(activation_name) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface private elemental module subroutine assert_conformable_with(self, inference_engine) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Called by interface~~nodes_per_layer~2~~CalledByGraph interface~nodes_per_layer~2 inference_engine_m_::inference_engine_t%nodes_per_layer proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~nodes_per_layer~2 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(node_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~2.html"},{"title":"norm – Inference-Engine","text":"interface private elemental module function norm(self) result(norm_of_self) Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_inputs – Inference-Engine","text":"interface Called by interface~~num_inputs~3~~CalledByGraph interface~num_inputs~3 inference_engine_m_::inference_engine_t%num_inputs proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~num_inputs~3 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_inputs(self) result(input_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~3.html"},{"title":"num_outputs – Inference-Engine","text":"interface Called by interface~~num_outputs~2~~CalledByGraph interface~num_outputs~2 inference_engine_m_::inference_engine_t%num_outputs proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~num_outputs~2 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_outputs(self) result(output_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs~2.html"},{"title":"skip – Inference-Engine","text":"interface private pure module function skip(self) result(use_skip_connections) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface private elemental module function subtract(self, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_exchange – Inference-Engine","text":"interface private pure module function to_exchange(self) result(exchange) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t )","tags":"","loc":"interface/to_exchange.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~3~~CalledByGraph interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output learn_microphysics_procedures::output proc~output->interface~to_json~3 proc~output~2 learn_exponentiation::output proc~output~2->interface~to_json~3 proc~output~3 learn_power_series::output proc~output~3->interface~to_json~3 proc~output~4 train_and_write::output proc~output~4->interface~to_json~3 proc~output~5 learn_addition::output proc~output~5->interface~to_json~3 proc~output~6 train_saturated_mixture_ratio::output proc~output~6->interface~to_json~3 proc~output~7 learn_multiplication::output proc~output~7->interface~to_json~3 proc~write_read_query_infer write_read_infer::write_read_query_infer proc~write_read_query_infer->interface~to_json~3 program~learn_addition learn_addition program~learn_addition->proc~output~5 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output~2 program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~output program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output~7 program~learn_power_series learn_power_series program~learn_power_series->proc~output~3 program~train_and_write train_and_write program~train_and_write->proc~output~4 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~6 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private impure elemental module function to_json(self) result(json_file) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json~3.html"},{"title":"training_configuration_t – Inference-Engine","text":"public interface training_configuration_t Functions private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t )","tags":"","loc":"interface/training_configuration_t.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"interface private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable","tags":"","loc":"interface/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~3.html"},{"title":"learning_rate – Inference-Engine","text":"interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~3.html"},{"title":"optimizer_name – Inference-Engine","text":"interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name~2.html"},{"title":"skip_connections – Inference-Engine","text":"interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~4~~CalledByGraph interface~to_json~4 training_configuration_m::training_configuration_t%to_json program~print_training_configuration print_training_configuration program~print_training_configuration->interface~to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~4.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~5~~CalledByGraph proc~e~5 train_saturated_mixture_ratio::e proc~perturbed_identity_network~6 train_saturated_mixture_ratio::perturbed_identity_network proc~perturbed_identity_network~6->proc~e~5 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~5.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~6~~CallsGraph proc~perturbed_identity_network~6 train_saturated_mixture_ratio::perturbed_identity_network proc~e~5 train_saturated_mixture_ratio::e proc~perturbed_identity_network~6->proc~e~5 string_t string_t proc~perturbed_identity_network~6->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~6~~CalledByGraph proc~perturbed_identity_network~6 train_saturated_mixture_ratio::perturbed_identity_network program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~6.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~2~~CallsGraph proc~open_plot_file_for_appending~2 train_saturated_mixture_ratio::open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending~2->file_t lines lines proc~open_plot_file_for_appending~2->lines string string proc~open_plot_file_for_appending~2->string string_t string_t proc~open_plot_file_for_appending~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_plot_file_for_appending~2~~CalledByGraph proc~open_plot_file_for_appending~2 train_saturated_mixture_ratio::open_plot_file_for_appending program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/open_plot_file_for_appending~2.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~6~~CallsGraph proc~output~6 train_saturated_mixture_ratio::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~6->interface~to_json~3 write_lines write_lines proc~output~6->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~6~~CalledByGraph proc~output~6 train_saturated_mixture_ratio::output program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~6.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~2~~CalledByGraph proc~print_diagnostics~2 train_saturated_mixture_ratio::print_diagnostics program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~print_diagnostics~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/print_diagnostics~2.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~6~~CallsGraph proc~y~6 multiply_inputs::y assert assert proc~y~6->assert interface~values tensor_m::tensor_t%values proc~y~6->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~6~~CalledByGraph proc~y~6 multiply_inputs::y program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~6.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~6~~CalledByGraph proc~e~6 learn_multiplication::e proc~perturbed_identity_network~7 learn_multiplication::perturbed_identity_network proc~perturbed_identity_network~7->proc~e~6 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~6.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~7~~CallsGraph proc~perturbed_identity_network~7 learn_multiplication::perturbed_identity_network proc~e~6 learn_multiplication::e proc~perturbed_identity_network~7->proc~e~6 string_t string_t proc~perturbed_identity_network~7->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~7~~CalledByGraph proc~perturbed_identity_network~7 learn_multiplication::perturbed_identity_network program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~7.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~7~~CallsGraph proc~output~7 learn_multiplication::output interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~7->interface~to_json~3 write_lines write_lines proc~output~7->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~7~~CalledByGraph proc~output~7 learn_multiplication::output program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~7.html"},{"title":"construct – Inference-Engine","text":"module procedure construct elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"proc/construct.html"},{"title":"expected_outputs – Inference-Engine","text":"module procedure expected_outputs elemental module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"module procedure inputs elemental module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/inputs.html"},{"title":"shuffle – Inference-Engine","text":"module procedure shuffle module subroutine shuffle(pairs) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"proc/shuffle.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name relu_s::function_name string_t string_t proc~function_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Calls proc~~activation~2~~CallsGraph proc~activation~2 swish_s::activation interface~activation sigmoid_m::sigmoid_t%activation proc~activation~2->interface~activation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Calls proc~~activation_derivative~2~~CallsGraph proc~activation_derivative~2 swish_s::activation_derivative interface~activation sigmoid_m::sigmoid_t%activation proc~activation_derivative~2->interface~activation interface~activation_derivative sigmoid_m::sigmoid_t%activation_derivative proc~activation_derivative~2->interface~activation_derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~2~~CallsGraph proc~function_name~2 swish_s::function_name string_t string_t proc~function_name~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~2.html"},{"title":"construct – Inference-Engine","text":"module procedure construct pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"proc/construct~2.html"},{"title":"input_output_pairs – Inference-Engine","text":"module procedure input_output_pairs pure module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"proc/input_output_pairs.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~~CallsGraph proc~equals hyperparameters_s::equals assert assert proc~equals->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t )","tags":"","loc":"proc/from_components.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Calls proc~~from_json~~CallsGraph proc~from_json hyperparameters_s::from_json assert assert proc~from_json->assert get_json_key get_json_key proc~from_json->get_json_key get_json_value get_json_value proc~from_json->get_json_value string_t string_t proc~from_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"proc/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/mini_batches.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) Calls proc~~optimizer_name~~CallsGraph proc~optimizer_name hyperparameters_s::optimizer_name string_t string_t proc~optimizer_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/optimizer_name.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~~CallsGraph proc~to_json hyperparameters_s::to_json string_t string_t proc~to_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"proc/construct_from_components.html"},{"title":"num_components – Inference-Engine","text":"module procedure num_components pure module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_components.html"},{"title":"values – Inference-Engine","text":"module procedure values pure module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"proc/values.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct pure recursive module function construct(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Calls proc~~construct~3~~CallsGraph proc~construct~3 neuron_s::construct assert assert proc~construct~3->assert string string proc~construct~3->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct~3.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer","tags":"","loc":"proc/next_pointer.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_inputs.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"proc/weights.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation~3.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~3~~CallsGraph proc~function_name~3 step_s::function_name string_t string_t proc~function_name~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~3.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation~4.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~4~~CallsGraph proc~function_name~4 sigmoid_s::function_name string_t string_t proc~function_name~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~4.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"module procedure differentiable_activation_strategy module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable Calls proc~~differentiable_activation_strategy~~CallsGraph proc~differentiable_activation_strategy training_configuration_s::differentiable_activation_strategy interface~activation_name network_configuration_m::network_configuration_t%activation_name proc~differentiable_activation_strategy->interface~activation_name string string proc~differentiable_activation_strategy->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~3.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) Calls proc~~from_components~2~~CallsGraph proc~from_components~2 training_configuration_s::from_components file_t file_t proc~from_components~2->file_t interface~to_json~2 hyperparameters_m::hyperparameters_t%to_json proc~from_components~2->interface~to_json~2 string_t string_t proc~from_components~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_components~2.html"},{"title":"from_file – Inference-Engine","text":"module procedure from_file module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Calls proc~~from_file~~CallsGraph proc~from_file training_configuration_s::from_file assert assert proc~from_file->assert lines lines proc~from_file->lines string string proc~from_file->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_file.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) Calls proc~~learning_rate~2~~CallsGraph proc~learning_rate~2 training_configuration_s::learning_rate interface~learning_rate hyperparameters_m::hyperparameters_t%learning_rate proc~learning_rate~2->interface~learning_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer Calls proc~~mini_batches~2~~CallsGraph proc~mini_batches~2 training_configuration_s::mini_batches interface~mini_batches hyperparameters_m::hyperparameters_t%mini_batches proc~mini_batches~2->interface~mini_batches Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mini_batches~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~nodes_per_layer~~CallsGraph proc~nodes_per_layer training_configuration_s::nodes_per_layer interface~nodes_per_layer network_configuration_m::network_configuration_t%nodes_per_layer proc~nodes_per_layer->interface~nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nodes_per_layer.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) Calls proc~~optimizer_name~2~~CallsGraph proc~optimizer_name~2 training_configuration_s::optimizer_name interface~optimizer_name hyperparameters_m::hyperparameters_t%optimizer_name proc~optimizer_name~2->interface~optimizer_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/optimizer_name~2.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical Calls proc~~skip_connections~~CallsGraph proc~skip_connections training_configuration_s::skip_connections interface~skip_connections network_configuration_m::network_configuration_t%skip_connections proc~skip_connections->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~2~~CallsGraph proc~to_json~2 training_configuration_s::to_json lines lines proc~to_json~2->lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~2.html"},{"title":"activation_name – Inference-Engine","text":"module procedure activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"proc/activation_name.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~4~~CallsGraph proc~equals~4 network_configuration_s::equals assert assert proc~equals~4->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals~4.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t )","tags":"","loc":"proc/from_components~3.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Calls proc~~from_json~2~~CallsGraph proc~from_json~2 network_configuration_s::from_json assert assert proc~from_json~2->assert get_json_key get_json_key proc~from_json~2->get_json_key get_json_value get_json_value proc~from_json~2->get_json_value string_t string_t proc~from_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:)","tags":"","loc":"proc/nodes_per_layer~2.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~3~~CallsGraph proc~to_json~3 network_configuration_s::to_json string_t string_t proc~to_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~3.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~activation_strategy_m activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~hyperparameters_m hyperparameters_m module~hyperparameters_m->module~kind_parameters_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~layer_m->module~inference_engine_m_ module~neuron_m neuron_m module~layer_m->module~neuron_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~neuron_m->module~kind_parameters_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_s relu_s module~relu_s->module~kind_parameters_m module~relu_s->module~relu_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~differentiable_activation_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m sourcery_string_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~sigmoid_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/sigmoid_m.html"},{"title":"thompson_tensors_m – Inference-Engine","text":"This module supports the program in the file example/learn-microphysics-procedures.f90. Uses assert_m inference_engine_m module_mp_thompson module~~thompson_tensors_m~~UsesGraph module~thompson_tensors_m thompson_tensors_m assert_m assert_m module~thompson_tensors_m->assert_m module~inference_engine_m inference_engine_m module~thompson_tensors_m->module~inference_engine_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~thompson_tensors_m~~UsedByGraph module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public impure elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/thompson_tensors_m.html"},{"title":"module_mp_thompson – Inference-Engine","text":"Used by module~~module_mp_thompson~~UsedByGraph module~module_mp_thompson module_mp_thompson module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~module_mp_thompson program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function RSIF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real public  function RSLF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real","tags":"","loc":"module/module_mp_thompson.html"},{"title":"input_output_pair_m – Inference-Engine","text":"Uses kind_parameters_m tensor_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~mini_batch_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) interface public module subroutine shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor private\n\n                    elemental, module\n                    function construct (inputs, expected_outputs) Type-Bound Procedures procedure, public :: expected_outputs procedure, public :: inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses kind_parameters_m sourcery_string_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~neuron_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~neuron_s neuron_s module~neuron_s->module~neuron_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer interface private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private\n\n                    pure, recursive, module\n                    function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"exponentiation_m – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~exponentiation_m~~UsesGraph module~exponentiation_m exponentiation_m assert_m assert_m module~exponentiation_m->assert_m module~inference_engine_m inference_engine_m module~exponentiation_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~exponentiation_m~~UsedByGraph module~exponentiation_m exponentiation_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~exponentiation_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/exponentiation_m.html"},{"title":"inference_engine_m – Inference-Engine","text":"Specify the user-facing modules, derived types, and type parameters Uses kind_parameters_m swish_m inference_engine_m_ mini_batch_m sigmoid_m trainable_engine_m tensor_m step_m relu_m training_configuration_m ubounds_m differentiable_activation_strategy_m hyperparameters_m activation_strategy_m input_output_pair_m network_configuration_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/inference_engine_m.html"},{"title":"tensor_m – Inference-Engine","text":"Uses kind_parameters_m module~~tensor_m~~UsesGraph module~tensor_m tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: tensor_s module~~tensor_m~~UsedByGraph module~tensor_m tensor_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~tensor_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m_->module~tensor_m module~input_output_pair_m->module~tensor_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~mini_batch_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~mini_batch_m->module~input_output_pair_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tensor_t private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer interface private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:) Derived Types type, public :: tensor_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: values_ (:) Constructor private\n\n                    pure, module\n                    function construct_from_components (values) Type-Bound Procedures procedure, public :: num_components procedure, public :: values","tags":"","loc":"module/tensor_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses kind_parameters_m sourcery_string_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~step_m step_m module~inference_engine_m->module~step_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~step_m->module~activation_strategy_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~relu_m->module~differentiable_activation_strategy_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~step_m module~swish_m->module~differentiable_activation_strategy_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~training_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~relu_s relu_s module~relu_s->module~relu_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) abstract interface public elemental function function_name_i(self) result(string) Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public :: activation_strategy_t Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation procedure( function_name_i ), public, deferred :: function_name","tags":"","loc":"module/activation_strategy_m.html"},{"title":"power_series – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~power_series~~UsesGraph module~power_series power_series assert_m assert_m module~power_series->assert_m module~inference_engine_m inference_engine_m module~power_series->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~power_series~~UsedByGraph module~power_series power_series program~learn_power_series learn_power_series program~learn_power_series->module~power_series Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/power_series.html"},{"title":"relu_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m sourcery_string_m module~~relu_m~~UsesGraph module~relu_m relu_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~relu_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~relu_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: relu_s module~~relu_m~~UsedByGraph module~relu_m relu_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~relu_m module~relu_s relu_s module~relu_s->module~relu_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: relu_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/relu_m.html"},{"title":"ubounds_m – Inference-Engine","text":"This module serves only to support array bounds checking in the main program below Used by module~~ubounds_m~~UsedByGraph module~ubounds_m ubounds_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~ubounds_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals generic, public :: operator(==) => equals Functions public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"module/ubounds_m.html"},{"title":"mini_batch_m – Inference-Engine","text":"Uses kind_parameters_m input_output_pair_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~trainable_engine_m->module~mini_batch_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) interface private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor private\n\n                    pure, module\n                    function construct (input_output_pairs) Type-Bound Procedures procedure, public :: input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"trainable_engine_m – Inference-Engine","text":"Define an abstraction that supports training a neural network Uses kind_parameters_m inference_engine_m_ mini_batch_m tensor_m sourcery_string_m training_configuration_m differentiable_activation_strategy_m module~~trainable_engine_m~~UsesGraph module~trainable_engine_m trainable_engine_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~tensor_m tensor_m module~trainable_engine_m->module~tensor_m module~training_configuration_m training_configuration_m module~trainable_engine_m->module~training_configuration_m sourcery_string_m sourcery_string_m module~trainable_engine_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->sourcery_string_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~network_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~trainable_engine_m~~UsedByGraph module~trainable_engine_m trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~trainable_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Interfaces public        interface trainable_engine_t private pure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) interface private pure module subroutine assert_consistent(self) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self interface private elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private elemental module function num_inputs(self) result(n_in) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_layers(self) result(n_layers) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_outputs(self) result(n_out) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private module function to_inference_engine(self) result(inference_engine) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) interface private pure module subroutine train(self, mini_batches, cost, adam, learning_rate) Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate Derived Types type, public :: trainable_engine_t Encapsulate the information needed to perform training Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor private\n\n                    pure, module\n                    function construct_from_inference_engine (inference_engine) private\n\n                    pure, module\n                    function construct_from_padded_arrays (nodes, weights, biases, differentiable_activation_strategy, metadata) private\n\n                    module\n                    function perturbed_identity_network (training_configuration, perturbation_magnitude, metadata) Type-Bound Procedures procedure, public :: assert_consistent procedure, public :: infer procedure, public :: num_inputs procedure, public :: num_layers procedure, public :: num_outputs procedure, public :: to_inference_engine procedure, public :: train","tags":"","loc":"module/trainable_engine_m.html"},{"title":"saturated_mixing_ratio_m – Inference-Engine","text":"This module supports the program in the file example/learn-saturated-mixing-ratio.f90.\nThe saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function\nin the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90.\nICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. Uses assert_m inference_engine_m module~~saturated_mixing_ratio_m~~UsesGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m assert_m assert_m module~saturated_mixing_ratio_m->assert_m module~inference_engine_m inference_engine_m module~saturated_mixing_ratio_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~saturated_mixing_ratio_m~~UsedByGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 real, private, parameter :: freezing_threshold = 273.15 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) private pure function saturated_mixing_ratio (T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real","tags":"","loc":"module/saturated_mixing_ratio_m.html"},{"title":"network_configuration_m – Inference-Engine","text":"Uses sourcery_string_m module~~network_configuration_m~~UsesGraph module~network_configuration_m network_configuration_m sourcery_string_m sourcery_string_m module~network_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: network_configuration_s module~~network_configuration_m~~UsedByGraph module~network_configuration_m network_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~network_configuration_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~network_configuration_s network_configuration_s module~network_configuration_s->module~network_configuration_m module~training_configuration_m->module~network_configuration_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: network_configuration_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor private\n\n                    pure, module\n                    function from_components (skip_connections, nodes_per_layer, activation_name) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: activation_name procedure, public :: equals procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/network_configuration_m.html"},{"title":"step_m – Inference-Engine","text":"Uses kind_parameters_m activation_strategy_m sourcery_string_m module~~step_m~~UsesGraph module~step_m step_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~step_m->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~step_m module~step_s step_s module~step_s->module~step_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public :: function_name","tags":"","loc":"module/step_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~training_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~relu_s relu_s module~relu_s->module~relu_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation procedure( activation_i ), public, deferred, nopass :: activation_derivative procedure( function_name_i ), public, deferred :: function_name","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"hyperparameters_m – Inference-Engine","text":"Uses kind_parameters_m sourcery_string_m module~~hyperparameters_m~~UsesGraph module~hyperparameters_m hyperparameters_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~hyperparameters_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: hyperparameters_s module~~hyperparameters_m~~UsedByGraph module~hyperparameters_m hyperparameters_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m->module~hyperparameters_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: hyperparameters_t Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor private\n\n                    pure, module\n                    function from_components (mini_batches, learning_rate, optimizer) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: to_json","tags":"","loc":"module/hyperparameters_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m sourcery_string_m module~~swish_m~~UsesGraph module~swish_m swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~swish_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/swish_m.html"},{"title":"addition_m – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~addition_m~~UsesGraph module~addition_m addition_m assert_m assert_m module~addition_m->assert_m module~inference_engine_m inference_engine_m module~addition_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~addition_m~~UsedByGraph module~addition_m addition_m program~learn_addition learn_addition program~learn_addition->module~addition_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/addition_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses kind_parameters_m inference_engine_m_ neuron_m sourcery_string_m module~~layer_m~~UsesGraph module~layer_m layer_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m sourcery_string_m sourcery_string_m module~layer_m->sourcery_string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->sourcery_string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~neuron_m->module~kind_parameters_m module~neuron_m->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target interface private module function count_inputs(layer) result(num_inputs) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer interface private module function count_layers(layer) result(num_layers) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module function count_neurons(layer) result(neurons_per_layer) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) interface private module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) interface private module function neurons_per_layer(self) result(num_neurons) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module function next_allocated(self) result(next_is_allocated) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module function next_pointer(self) result(next_ptr) Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private\n\n                    recursive, module\n                    function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_inputs procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: inference_engine procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"inference_engine_m_ – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses kind_parameters_m sourcery_file_m tensor_m sourcery_string_m differentiable_activation_strategy_m activation_strategy_m module~~inference_engine_m_~~UsesGraph module~inference_engine_m_ inference_engine_m_ module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m sourcery_string_m sourcery_string_m module~inference_engine_m_->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~inference_engine_m_~~UsedByGraph module~inference_engine_m_ inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces interface public elemental module function infer(self, inputs) result(outputs) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) public        interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) interface private elemental module function activation_function_name(self) result(activation_name) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module subroutine assert_conformable_with(self, inference_engine) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private pure module function nodes_per_layer(self) result(node_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function norm(self) result(norm_of_self) Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function num_inputs(self) result(input_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_outputs(self) result(output_count) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private pure module function skip(self) result(use_skip_connections) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module function subtract(self, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) interface private pure module function to_exchange(self) result(exchange) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) interface private impure elemental module function to_json(self) result(json_file) Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm type, public :: exchange_t Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) real(kind=rkind), public, allocatable :: weights_ (:,:,:) type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor private\n\n                    impure, elemental, module\n                    function construct_from_json (file_) private\n\n                    pure, module\n                    function construct_from_padded_arrays (metadata, weights, biases, nodes) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with procedure, public :: infer procedure, public :: nodes_per_layer procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: skip procedure, public :: to_exchange procedure, public :: to_json procedure, private :: subtract","tags":"","loc":"module/inference_engine_m_.html"},{"title":"training_configuration_m – Inference-Engine","text":"Uses kind_parameters_m sourcery_file_m sourcery_string_m differentiable_activation_strategy_m hyperparameters_m network_configuration_m module~~training_configuration_m~~UsesGraph module~training_configuration_m training_configuration_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~training_configuration_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~training_configuration_m->module~kind_parameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m sourcery_file_m sourcery_file_m module~training_configuration_m->sourcery_file_m sourcery_string_m sourcery_string_m module~training_configuration_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~network_configuration_m->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: training_configuration_s module~~training_configuration_m~~UsedByGraph module~training_configuration_m training_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~training_configuration_s->module~inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) interface private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical interface private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public, extends(file_t) :: training_configuration_t Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor private\n\n                    module\n                    function from_components (hyperparameters, network_configuration) private\n\n                    module\n                    function from_file (file_object) Type-Bound Procedures procedure, public :: differentiable_activation_strategy procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/training_configuration_m.html"},{"title":"multiply_inputs – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~multiply_inputs~~UsesGraph module~multiply_inputs multiply_inputs assert_m assert_m module~multiply_inputs->assert_m module~inference_engine_m inference_engine_m module~multiply_inputs->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~multiply_inputs~~UsedByGraph module~multiply_inputs multiply_inputs program~learn_multiplication learn_multiplication program~learn_multiplication->module~multiply_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/multiply_inputs.html"},{"title":"input_output_pair_s – Inference-Engine","text":"Uses assert_m Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s assert_m assert_m module~input_output_pair_s->assert_m module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html construct elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html expected_outputs elemental module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html inputs elemental module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html shuffle module subroutine shuffle(pairs) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"module/input_output_pair_s.html"},{"title":"relu_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: relu_m module~~relu_s~~UsesGraph module~relu_s relu_s module~kind_parameters_m kind_parameters_m module~relu_s->module~kind_parameters_m module~relu_m relu_m module~relu_s->module~relu_m module~relu_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m sourcery_string_m sourcery_string_m module~relu_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=rkind), private, parameter :: one = 1._rkind real(kind=rkind), private, parameter :: zero = 0._rkind Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/relu_s.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~sigmoid_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/swish_s.html"},{"title":"mini_batch_s – Inference-Engine","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html construct pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html input_output_pairs pure module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"hyperparameters_s – Inference-Engine","text":"Uses assert_m Ancestors: hyperparameters_m module~~hyperparameters_s~~UsesGraph module~hyperparameters_s hyperparameters_s assert_m assert_m module~hyperparameters_s->assert_m module~hyperparameters_m hyperparameters_m module~hyperparameters_s->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~hyperparameters_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: learning_rate_key = \"learning rate\" character(len=*), private, parameter :: mini_batches_key = \"mini-batches\" character(len=*), private, parameter :: optimizer_key = \"optimizer\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html from_components pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html from_json pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/hyperparameters_s.html"},{"title":"tensor_s – Inference-Engine","text":"Uses Ancestors: tensor_m module~~tensor_s~~UsesGraph module~tensor_s tensor_s module~tensor_m tensor_m module~tensor_s->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html construct_from_components pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html num_components pure module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html values pure module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"module/tensor_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~neuron_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html bias module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html construct pure recursive module function construct(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html num_inputs pure module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html weights module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m sourcery_string_m sourcery_string_m module~step_m->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/step_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/step_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/step_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~sigmoid_m->sourcery_string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/sigmoid_s.html"},{"title":"training_configuration_s – Inference-Engine","text":"Uses assert_m inference_engine_m Ancestors: training_configuration_m module~~training_configuration_s~~UsesGraph module~training_configuration_s training_configuration_s assert_m assert_m module~training_configuration_s->assert_m module~inference_engine_m inference_engine_m module~training_configuration_s->module~inference_engine_m module~training_configuration_m training_configuration_m module~training_configuration_s->module~training_configuration_m module~inference_engine_m->module~training_configuration_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m sourcery_file_m sourcery_file_m module~training_configuration_m->sourcery_file_m sourcery_string_m sourcery_string_m module~training_configuration_m->sourcery_string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: footer = \"}\" character(len=*), private, parameter :: header = \"{\" character(len=*), private, parameter :: separator = \",\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html differentiable_activation_strategy module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html equals elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html from_components module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html from_file module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html to_json pure module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/training_configuration_s.html"},{"title":"network_configuration_s – Inference-Engine","text":"Uses assert_m sourcery_formats_m Ancestors: network_configuration_m module~~network_configuration_s~~UsesGraph module~network_configuration_s network_configuration_s assert_m assert_m module~network_configuration_s->assert_m module~network_configuration_m network_configuration_m module~network_configuration_s->module~network_configuration_m sourcery_formats_m sourcery_formats_m module~network_configuration_s->sourcery_formats_m sourcery_string_m sourcery_string_m module~network_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: activation_name_key = \"activation function\" character(len=*), private, parameter :: nodes_per_layer_key = \"nodes per layer\" character(len=*), private, parameter :: skip_connections_key = \"skip connections\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/network_configuration_s.html"},{"title":"learn_microphysics_procedures – Inference-Engine","text":"Uses thompson_tensors_m assert_m inference_engine_m sourcery_m iso_fortran_env program~~learn_microphysics_procedures~~UsesGraph program~learn_microphysics_procedures learn_microphysics_procedures assert_m assert_m program~learn_microphysics_procedures->assert_m iso_fortran_env iso_fortran_env program~learn_microphysics_procedures->iso_fortran_env module~inference_engine_m inference_engine_m program~learn_microphysics_procedures->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures->module~thompson_tensors_m sourcery_m sourcery_m program~learn_microphysics_procedures->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~thompson_tensors_m->assert_m module~thompson_tensors_m->module~inference_engine_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Train a neural network proxies for procedures in the Thompson microphysics model\nin of ICAR (https://github.com/BerkeleyLab/icar). Calls program~~learn_microphysics_procedures~~CallsGraph program~learn_microphysics_procedures learn_microphysics_procedures assert assert program~learn_microphysics_procedures->assert bin_t bin_t program~learn_microphysics_procedures->bin_t bins bins program~learn_microphysics_procedures->bins cost cost program~learn_microphysics_procedures->cost desired_outputs desired_outputs program~learn_microphysics_procedures->desired_outputs file_t file_t program~learn_microphysics_procedures->file_t first first program~learn_microphysics_procedures->first flag_value flag_value program~learn_microphysics_procedures->flag_value infer infer program~learn_microphysics_procedures->infer input_output_pairs input_output_pairs program~learn_microphysics_procedures->input_output_pairs inputs inputs program~learn_microphysics_procedures->inputs interface~shuffle input_output_pair_m::shuffle program~learn_microphysics_procedures->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_microphysics_procedures->intrinsic_array_t last last program~learn_microphysics_procedures->last mini_batches mini_batches program~learn_microphysics_procedures->mini_batches nodes_per_layer nodes_per_layer program~learn_microphysics_procedures->nodes_per_layer num_inputs num_inputs program~learn_microphysics_procedures->num_inputs num_outputs num_outputs program~learn_microphysics_procedures->num_outputs output_sizes output_sizes program~learn_microphysics_procedures->output_sizes proc~open_plot_file_for_appending learn_microphysics_procedures::open_plot_file_for_appending program~learn_microphysics_procedures->proc~open_plot_file_for_appending proc~output learn_microphysics_procedures::output program~learn_microphysics_procedures->proc~output proc~perturbed_identity_network learn_microphysics_procedures::perturbed_identity_network program~learn_microphysics_procedures->proc~perturbed_identity_network proc~print_diagnostics learn_microphysics_procedures::print_diagnostics program~learn_microphysics_procedures->proc~print_diagnostics proc~y thompson_tensors_m::y program~learn_microphysics_procedures->proc~y random_init random_init program~learn_microphysics_procedures->random_init random_numbers random_numbers program~learn_microphysics_procedures->random_numbers string string program~learn_microphysics_procedures->string string_t string_t program~learn_microphysics_procedures->string_t to_inference_engine to_inference_engine program~learn_microphysics_procedures->to_inference_engine train train program~learn_microphysics_procedures->train values values program~learn_microphysics_procedures->values proc~open_plot_file_for_appending->file_t proc~open_plot_file_for_appending->string proc~open_plot_file_for_appending->string_t lines lines proc~open_plot_file_for_appending->lines interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output->interface~to_json~3 write_lines write_lines proc~output->write_lines proc~perturbed_identity_network->string_t proc~e learn_microphysics_procedures::e proc~perturbed_identity_network->proc~e proc~y->assert interface~values tensor_m::tensor_t%values proc~y->interface~values proc~rsif module_mp_thompson::RSIF proc~y->proc~rsif proc~rslf module_mp_thompson::RSLF proc~y->proc~rslf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/learn_microphysics_procedures.html"},{"title":"learn_exponentiation – Inference-Engine","text":"Uses sourcery_m assert_m inference_engine_m exponentiation_m program~~learn_exponentiation~~UsesGraph program~learn_exponentiation learn_exponentiation assert_m assert_m program~learn_exponentiation->assert_m module~exponentiation_m exponentiation_m program~learn_exponentiation->module~exponentiation_m module~inference_engine_m inference_engine_m program~learn_exponentiation->module~inference_engine_m sourcery_m sourcery_m program~learn_exponentiation->sourcery_m module~exponentiation_m->assert_m module~exponentiation_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_exponentiation~~CallsGraph program~learn_exponentiation learn_exponentiation assert assert program~learn_exponentiation->assert bin_t bin_t program~learn_exponentiation->bin_t bins bins program~learn_exponentiation->bins cost cost program~learn_exponentiation->cost desired_outputs desired_outputs program~learn_exponentiation->desired_outputs first first program~learn_exponentiation->first flag_value flag_value program~learn_exponentiation->flag_value infer infer program~learn_exponentiation->infer input_output_pairs input_output_pairs program~learn_exponentiation->input_output_pairs inputs inputs program~learn_exponentiation->inputs interface~shuffle input_output_pair_m::shuffle program~learn_exponentiation->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_exponentiation->intrinsic_array_t last last program~learn_exponentiation->last mini_batches mini_batches program~learn_exponentiation->mini_batches num_inputs num_inputs program~learn_exponentiation->num_inputs num_outputs num_outputs program~learn_exponentiation->num_outputs output_sizes output_sizes program~learn_exponentiation->output_sizes proc~output~2 learn_exponentiation::output program~learn_exponentiation->proc~output~2 proc~perturbed_identity_network~2 learn_exponentiation::perturbed_identity_network program~learn_exponentiation->proc~perturbed_identity_network~2 proc~y~2 exponentiation_m::y program~learn_exponentiation->proc~y~2 random_init random_init program~learn_exponentiation->random_init random_numbers random_numbers program~learn_exponentiation->random_numbers string string program~learn_exponentiation->string string_t string_t program~learn_exponentiation->string_t to_inference_engine to_inference_engine program~learn_exponentiation->to_inference_engine train train program~learn_exponentiation->train values values program~learn_exponentiation->values interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~2->interface~to_json~3 write_lines write_lines proc~output~2->write_lines proc~perturbed_identity_network~2->string_t proc~e~2 learn_exponentiation::e proc~perturbed_identity_network~2->proc~e~2 proc~y~2->assert interface~values tensor_m::tensor_t%values proc~y~2->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_exponentiation.html"},{"title":"learn_power_series – Inference-Engine","text":"Uses sourcery_m power_series assert_m inference_engine_m program~~learn_power_series~~UsesGraph program~learn_power_series learn_power_series assert_m assert_m program~learn_power_series->assert_m module~inference_engine_m inference_engine_m program~learn_power_series->module~inference_engine_m module~power_series power_series program~learn_power_series->module~power_series sourcery_m sourcery_m program~learn_power_series->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~power_series->assert_m module~power_series->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_power_series~~CallsGraph program~learn_power_series learn_power_series assert assert program~learn_power_series->assert bin_t bin_t program~learn_power_series->bin_t bins bins program~learn_power_series->bins cost cost program~learn_power_series->cost desired_outputs desired_outputs program~learn_power_series->desired_outputs first first program~learn_power_series->first flag_value flag_value program~learn_power_series->flag_value infer infer program~learn_power_series->infer input_output_pairs input_output_pairs program~learn_power_series->input_output_pairs inputs inputs program~learn_power_series->inputs interface~shuffle input_output_pair_m::shuffle program~learn_power_series->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_power_series->intrinsic_array_t last last program~learn_power_series->last mini_batches mini_batches program~learn_power_series->mini_batches num_inputs num_inputs program~learn_power_series->num_inputs num_outputs num_outputs program~learn_power_series->num_outputs output_sizes output_sizes program~learn_power_series->output_sizes proc~output~3 learn_power_series::output program~learn_power_series->proc~output~3 proc~perturbed_identity_network~3 learn_power_series::perturbed_identity_network program~learn_power_series->proc~perturbed_identity_network~3 proc~y~3 power_series::y program~learn_power_series->proc~y~3 random_init random_init program~learn_power_series->random_init random_numbers random_numbers program~learn_power_series->random_numbers string string program~learn_power_series->string string_t string_t program~learn_power_series->string_t to_inference_engine to_inference_engine program~learn_power_series->to_inference_engine train train program~learn_power_series->train values values program~learn_power_series->values white_noise white_noise program~learn_power_series->white_noise interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~3->interface~to_json~3 write_lines write_lines proc~output~3->write_lines proc~perturbed_identity_network~3->string_t proc~e~3 learn_power_series::e proc~perturbed_identity_network~3->proc~e~3 proc~y~3->assert interface~values tensor_m::tensor_t%values proc~y~3->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_power_series.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses sourcery_m kind_parameters_m inference_engine_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m sourcery_m sourcery_m program~write_read_infer->sourcery_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->sourcery_string_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->sourcery_string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->sourcery_string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->sourcery_string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference.  The network performs an identity mapping from any\nnon-negative inputs to the corresponding outputs using a RELU activation\nfunction. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer flag_value flag_value program~write_read_infer->flag_value proc~write_read_query_infer write_read_infer::write_read_query_infer program~write_read_infer->proc~write_read_query_infer string string program~write_read_infer->string string_t string_t program~write_read_infer->string_t proc~write_read_query_infer->string file_t file_t proc~write_read_query_infer->file_t interface~activation_function_name inference_engine_m_::inference_engine_t%activation_function_name proc~write_read_query_infer->interface~activation_function_name interface~infer~2 inference_engine_m_::inference_engine_t%infer proc~write_read_query_infer->interface~infer~2 interface~nodes_per_layer~2 inference_engine_m_::inference_engine_t%nodes_per_layer proc~write_read_query_infer->interface~nodes_per_layer~2 interface~num_inputs~3 inference_engine_m_::inference_engine_t%num_inputs proc~write_read_query_infer->interface~num_inputs~3 interface~num_outputs~2 inference_engine_m_::inference_engine_t%num_outputs proc~write_read_query_infer->interface~num_outputs~2 interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~write_read_query_infer->interface~to_json~3 interface~values tensor_m::tensor_t%values proc~write_read_query_infer->interface~values proc~identity_network write_read_infer::identity_network proc~write_read_query_infer->proc~identity_network write_lines write_lines proc~write_read_query_infer->write_lines proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Functions function identity_network () result(inference_engine) Arguments None Return Value type( inference_engine_t ) Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"train_and_write – Inference-Engine","text":"Uses sourcery_m assert_m inference_engine_m program~~train_and_write~~UsesGraph program~train_and_write train_and_write assert_m assert_m program~train_and_write->assert_m module~inference_engine_m inference_engine_m program~train_and_write->module~inference_engine_m sourcery_m sourcery_m program~train_and_write->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to train a simple neural network starting from a randomized initial condition and \nhow to write the initial network and the trained network to separate JSON files.  The network has two hiden layers.\nThe input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match\nthe corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions,\nthe desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere.\nThe initial condition corresponds to the desired network with all weights and biases perturbed by a random variable\nthat is uniformly distributed on the range [0,0.1]. Calls program~~train_and_write~~CallsGraph program~train_and_write train_and_write assert assert program~train_and_write->assert bin_t bin_t program~train_and_write->bin_t bins bins program~train_and_write->bins cost cost program~train_and_write->cost first first program~train_and_write->first flag_value flag_value program~train_and_write->flag_value infer infer program~train_and_write->infer input_output_pairs input_output_pairs program~train_and_write->input_output_pairs inputs inputs program~train_and_write->inputs interface~shuffle input_output_pair_m::shuffle program~train_and_write->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_and_write->intrinsic_array_t last last program~train_and_write->last mini_batches mini_batches program~train_and_write->mini_batches num_inputs num_inputs program~train_and_write->num_inputs num_outputs num_outputs program~train_and_write->num_outputs proc~output~4 train_and_write::output program~train_and_write->proc~output~4 proc~perturbed_identity_network~4 train_and_write::perturbed_identity_network program~train_and_write->proc~perturbed_identity_network~4 random_init random_init program~train_and_write->random_init random_numbers random_numbers program~train_and_write->random_numbers string string program~train_and_write->string string_t string_t program~train_and_write->string_t to_inference_engine to_inference_engine program~train_and_write->to_inference_engine train train program~train_and_write->train values values program~train_and_write->values interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~4->interface~to_json~3 write_lines write_lines proc~output~4->write_lines proc~perturbed_identity_network~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_and_write.html"},{"title":"print_training_configuration – Inference-Engine","text":"Uses sourcery_m inference_engine_m program~~print_training_configuration~~UsesGraph program~print_training_configuration print_training_configuration module~inference_engine_m inference_engine_m program~print_training_configuration->module~inference_engine_m sourcery_m sourcery_m program~print_training_configuration->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Demonstrate how to construct and print a training_configuration_t object Calls program~~print_training_configuration~~CallsGraph program~print_training_configuration print_training_configuration file_t file_t program~print_training_configuration->file_t interface~to_json~4 training_configuration_m::training_configuration_t%to_json program~print_training_configuration->interface~to_json~4 write_lines write_lines program~print_training_configuration->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"program/print_training_configuration.html"},{"title":"learn_addition – Inference-Engine","text":"Uses sourcery_m addition_m assert_m inference_engine_m program~~learn_addition~~UsesGraph program~learn_addition learn_addition assert_m assert_m program~learn_addition->assert_m module~addition_m addition_m program~learn_addition->module~addition_m module~inference_engine_m inference_engine_m program~learn_addition->module~inference_engine_m sourcery_m sourcery_m program~learn_addition->sourcery_m module~addition_m->assert_m module~addition_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_addition~~CallsGraph program~learn_addition learn_addition assert assert program~learn_addition->assert bin_t bin_t program~learn_addition->bin_t bins bins program~learn_addition->bins cost cost program~learn_addition->cost desired_outputs desired_outputs program~learn_addition->desired_outputs first first program~learn_addition->first flag_value flag_value program~learn_addition->flag_value infer infer program~learn_addition->infer input_output_pairs input_output_pairs program~learn_addition->input_output_pairs inputs inputs program~learn_addition->inputs interface~shuffle input_output_pair_m::shuffle program~learn_addition->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_addition->intrinsic_array_t last last program~learn_addition->last mini_batches mini_batches program~learn_addition->mini_batches num_inputs num_inputs program~learn_addition->num_inputs num_outputs num_outputs program~learn_addition->num_outputs output_sizes output_sizes program~learn_addition->output_sizes proc~output~5 learn_addition::output program~learn_addition->proc~output~5 proc~perturbed_identity_network~5 learn_addition::perturbed_identity_network program~learn_addition->proc~perturbed_identity_network~5 proc~y~5 addition_m::y program~learn_addition->proc~y~5 random_init random_init program~learn_addition->random_init random_numbers random_numbers program~learn_addition->random_numbers string string program~learn_addition->string string_t string_t program~learn_addition->string_t to_inference_engine to_inference_engine program~learn_addition->to_inference_engine train train program~learn_addition->train values values program~learn_addition->values interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~5->interface~to_json~3 write_lines write_lines proc~output~5->write_lines proc~perturbed_identity_network~5->string_t proc~e~4 learn_addition::e proc~perturbed_identity_network~5->proc~e~4 proc~y~5->assert interface~values tensor_m::tensor_t%values proc~y~5->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_addition.html"},{"title":"concurrent_inferences – Inference-Engine","text":"Uses sourcery_m assert_m inference_engine_m iso_fortran_env program~~concurrent_inferences~~UsesGraph program~concurrent_inferences concurrent_inferences assert_m assert_m program~concurrent_inferences->assert_m iso_fortran_env iso_fortran_env program~concurrent_inferences->iso_fortran_env module~inference_engine_m inference_engine_m program~concurrent_inferences->module~inference_engine_m sourcery_m sourcery_m program~concurrent_inferences->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to read a neural network from a JSON file\nand use the network to perform concurrent inferences. Calls program~~concurrent_inferences~~CallsGraph program~concurrent_inferences concurrent_inferences assert assert program~concurrent_inferences->assert file_t file_t program~concurrent_inferences->file_t flag_value flag_value program~concurrent_inferences->flag_value infer infer program~concurrent_inferences->infer input_components input_components program~concurrent_inferences->input_components inputs inputs program~concurrent_inferences->inputs num_inputs num_inputs program~concurrent_inferences->num_inputs outputs outputs program~concurrent_inferences->outputs string string program~concurrent_inferences->string string_t string_t program~concurrent_inferences->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: network_file_name","tags":"","loc":"program/concurrent_inferences.html"},{"title":"train_saturated_mixture_ratio – Inference-Engine","text":"Uses saturated_mixing_ratio_m assert_m inference_engine_m sourcery_m iso_fortran_env program~~train_saturated_mixture_ratio~~UsesGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert_m assert_m program~train_saturated_mixture_ratio->assert_m iso_fortran_env iso_fortran_env program~train_saturated_mixture_ratio->iso_fortran_env module~inference_engine_m inference_engine_m program~train_saturated_mixture_ratio->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m sourcery_m sourcery_m program~train_saturated_mixture_ratio->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~saturated_mixing_ratio_m->assert_m module~saturated_mixing_ratio_m->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program trains a neural network to learn the saturated mixing ratio function of ICAR. Calls program~~train_saturated_mixture_ratio~~CallsGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert assert program~train_saturated_mixture_ratio->assert bin_t bin_t program~train_saturated_mixture_ratio->bin_t bins bins program~train_saturated_mixture_ratio->bins cost cost program~train_saturated_mixture_ratio->cost desired_outputs desired_outputs program~train_saturated_mixture_ratio->desired_outputs file_t file_t program~train_saturated_mixture_ratio->file_t first first program~train_saturated_mixture_ratio->first flag_value flag_value program~train_saturated_mixture_ratio->flag_value infer infer program~train_saturated_mixture_ratio->infer input_output_pairs input_output_pairs program~train_saturated_mixture_ratio->input_output_pairs inputs inputs program~train_saturated_mixture_ratio->inputs interface~shuffle input_output_pair_m::shuffle program~train_saturated_mixture_ratio->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_saturated_mixture_ratio->intrinsic_array_t last last program~train_saturated_mixture_ratio->last mini_batches mini_batches program~train_saturated_mixture_ratio->mini_batches nodes_per_layer nodes_per_layer program~train_saturated_mixture_ratio->nodes_per_layer num_inputs num_inputs program~train_saturated_mixture_ratio->num_inputs num_outputs num_outputs program~train_saturated_mixture_ratio->num_outputs output_sizes output_sizes program~train_saturated_mixture_ratio->output_sizes proc~open_plot_file_for_appending~2 train_saturated_mixture_ratio::open_plot_file_for_appending program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 proc~output~6 train_saturated_mixture_ratio::output program~train_saturated_mixture_ratio->proc~output~6 proc~perturbed_identity_network~6 train_saturated_mixture_ratio::perturbed_identity_network program~train_saturated_mixture_ratio->proc~perturbed_identity_network~6 proc~print_diagnostics~2 train_saturated_mixture_ratio::print_diagnostics program~train_saturated_mixture_ratio->proc~print_diagnostics~2 proc~y~4 saturated_mixing_ratio_m::y program~train_saturated_mixture_ratio->proc~y~4 random_init random_init program~train_saturated_mixture_ratio->random_init random_numbers random_numbers program~train_saturated_mixture_ratio->random_numbers string string program~train_saturated_mixture_ratio->string string_t string_t program~train_saturated_mixture_ratio->string_t to_inference_engine to_inference_engine program~train_saturated_mixture_ratio->to_inference_engine train train program~train_saturated_mixture_ratio->train values values program~train_saturated_mixture_ratio->values proc~open_plot_file_for_appending~2->file_t proc~open_plot_file_for_appending~2->string proc~open_plot_file_for_appending~2->string_t lines lines proc~open_plot_file_for_appending~2->lines interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~6->interface~to_json~3 write_lines write_lines proc~output~6->write_lines proc~perturbed_identity_network~6->string_t proc~e~5 train_saturated_mixture_ratio::e proc~perturbed_identity_network~6->proc~e~5 proc~y~4->assert interface~values tensor_m::tensor_t%values proc~y~4->interface~values proc~saturated_mixing_ratio saturated_mixing_ratio_m::saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/train_saturated_mixture_ratio.html"},{"title":"learn_multiplication – Inference-Engine","text":"Uses sourcery_m assert_m inference_engine_m multiply_inputs program~~learn_multiplication~~UsesGraph program~learn_multiplication learn_multiplication assert_m assert_m program~learn_multiplication->assert_m module~inference_engine_m inference_engine_m program~learn_multiplication->module~inference_engine_m module~multiply_inputs multiply_inputs program~learn_multiplication->module~multiply_inputs sourcery_m sourcery_m program~learn_multiplication->sourcery_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~multiply_inputs->assert_m module~multiply_inputs->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m sourcery_string_m sourcery_string_m module~activation_strategy_m->sourcery_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->sourcery_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m sourcery_file_m sourcery_file_m module~inference_engine_m_->sourcery_file_m module~inference_engine_m_->sourcery_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->sourcery_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->sourcery_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->sourcery_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->sourcery_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->sourcery_string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->sourcery_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->sourcery_file_m module~training_configuration_m->sourcery_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_multiplication~~CallsGraph program~learn_multiplication learn_multiplication assert assert program~learn_multiplication->assert bin_t bin_t program~learn_multiplication->bin_t bins bins program~learn_multiplication->bins cost cost program~learn_multiplication->cost desired_outputs desired_outputs program~learn_multiplication->desired_outputs first first program~learn_multiplication->first flag_value flag_value program~learn_multiplication->flag_value infer infer program~learn_multiplication->infer input_output_pairs input_output_pairs program~learn_multiplication->input_output_pairs inputs inputs program~learn_multiplication->inputs interface~shuffle input_output_pair_m::shuffle program~learn_multiplication->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_multiplication->intrinsic_array_t last last program~learn_multiplication->last mini_batches mini_batches program~learn_multiplication->mini_batches num_inputs num_inputs program~learn_multiplication->num_inputs num_outputs num_outputs program~learn_multiplication->num_outputs output_sizes output_sizes program~learn_multiplication->output_sizes proc~output~7 learn_multiplication::output program~learn_multiplication->proc~output~7 proc~perturbed_identity_network~7 learn_multiplication::perturbed_identity_network program~learn_multiplication->proc~perturbed_identity_network~7 proc~y~6 multiply_inputs::y program~learn_multiplication->proc~y~6 random_init random_init program~learn_multiplication->random_init random_numbers random_numbers program~learn_multiplication->random_numbers string string program~learn_multiplication->string string_t string_t program~learn_multiplication->string_t to_inference_engine to_inference_engine program~learn_multiplication->to_inference_engine train train program~learn_multiplication->train values values program~learn_multiplication->values interface~to_json~3 inference_engine_m_::inference_engine_t%to_json proc~output~7->interface~to_json~3 write_lines write_lines proc~output~7->write_lines proc~perturbed_identity_network~7->string_t proc~e~6 learn_multiplication::e proc~perturbed_identity_network~7->proc~e~6 proc~y~6->assert interface~values tensor_m::tensor_t%values proc~y~6->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_multiplication.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_string_m , only : string_t implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( sigmoid_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"thompson_tensors_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~thompson_tensors_m.f90~~EfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~thompson_tensors_m.f90~~AfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module thompson_tensors_m !! This module supports the program in the file example/learn-microphysics-procedures.f90. use module_mp_thompson , only : rslf , rsif use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains elemental impure function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) associate ( temperature => T_min + ( T_max - T_min ) * x ( 1 ), pressure => p_min + ( p_max - p_min ) * x ( 2 ) ) a = tensor_t ([ rslf ( pressure , temperature ), rsif ( pressure , temperature )]) end associate end associate end function end module","tags":"","loc":"sourcefile/thompson_tensors_m.f90.html"},{"title":"mp_thompson.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~mp_thompson.f90~~AfferentGraph sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. MODULE module_mp_thompson ! Adapted from https://github.com/BerkeleyLab/icar IMPLICIT NONE CONTAINS !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS ! A FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A ! FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ END MODULE module_mp_thompson !+---+-----------------------------------------------------------------+","tags":"","loc":"sourcefile/mp_thompson.f90.html"},{"title":"input_output_pair_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s use assert_m , only : assert implicit none contains module procedure construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure inputs my_inputs = self % inputs_ end procedure module procedure expected_outputs my_expected_outputs = self % expected_outputs_ end procedure module procedure shuffle type ( input_output_pair_t ) temp real harvest ( 2 : size ( pairs )) integer i , j call random_number ( harvest ) durstenfeld_shuffle : & do i = size ( pairs ), 2 , - 1 j = 1 + int ( harvest ( i ) * i ) temp = pairs ( i ) pairs ( i ) = pairs ( j ) pairs ( j ) = temp end do durstenfeld_shuffle end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"input_output_pair_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use kind_parameters_m , only : rkind use tensor_m , only : tensor_t implicit none private public :: input_output_pair_t public :: shuffle type input_output_pair_t private type ( tensor_t ) inputs_ , expected_outputs_ contains procedure :: inputs procedure :: expected_outputs end type interface input_output_pair_t elemental module function construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ) input_output_pair end function end interface interface elemental module function inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_inputs end function elemental module function expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_expected_outputs end function module subroutine shuffle ( pairs ) implicit none type ( input_output_pair_t ), intent ( inout ) :: pairs (:) end subroutine end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"relu_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_s.f90~~EfferentGraph sourcefile~relu_s.f90 relu_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( relu_m ) relu_s use kind_parameters_m , only : rkind implicit none real ( rkind ), parameter :: zero = 0._rkind , one = 1._rkind contains module procedure activation y = max ( zero , x ) end procedure module procedure activation_derivative y = merge ( one , zero , x > zero ) end procedure module procedure function_name string = string_t ( \"relu\" ) end procedure end submodule relu_s","tags":"","loc":"sourcefile/relu_s.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure module procedure function_name string = string_t ( \"swish\" ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use sourcery_string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"learn-microphysics-procedures.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-microphysics-procedures.f90~~EfferentGraph sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program learn_microphysics_procedures !! Train a neural network proxies for procedures in the Thompson microphysics model !! in of ICAR (https://github.com/BerkeleyLab/icar). use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , sigmoid_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use thompson_tensors_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run learn-microphysics-procedures --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 10 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 2 ] real , parameter :: cost_tolerance = 1.E-08 #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \" Inputs (normalized)          | Outputs                    | Desired outputs\" do p = 1 , num_pairs print \"(6(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do end associate end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = sigmoid_t (), & metadata = & [ string_t ( \"Thompson microphysics procedures\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"sigmoid\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-microphysics-procedures.f90.html"},{"title":"mini_batch_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"learn-exponentiation.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-exponentiation.f90~~EfferentGraph sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module exponentiation_m !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) ** 2 , x ( 2 ) ** 3 , x ( 3 ) ** 4 , x ( 4 ) ** 4 , x ( 5 ) ** 3 , x ( 6 ) ** 2 ]) end associate end function end module program learn_exponentiation !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use exponentiation_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-polynomials --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] ! nodes per layer (first layer = input, last layer = output) integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-exponentiation.f90.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Specify the user-facing modules, derived types, and type parameters use activation_strategy_m , only : activation_strategy_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use hyperparameters_m , only : hyperparameters_t use input_output_pair_m , only : input_output_pair_t , shuffle use inference_engine_m_ , only : inference_engine_t , difference_t , infer use kind_parameters_m , only : rkind use mini_batch_m , only : mini_batch_t use network_configuration_m , only : network_configuration_t use relu_m , only : relu_t use sigmoid_m , only : sigmoid_t use step_m , only : step_t use swish_m , only : swish_t use tensor_m , only : tensor_t use trainable_engine_m , only : trainable_engine_t use training_configuration_m , only : training_configuration_t use ubounds_m , only : ubounds_t implicit none end module","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"tensor_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_m.f90~~EfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tensor_m.f90~~AfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_m use kind_parameters_m , only : rkind implicit none private public :: tensor_t type tensor_t private real ( rkind ), allocatable :: values_ (:) contains procedure values procedure num_components end type interface tensor_t pure module function construct_from_components ( values ) result ( tensor ) implicit none real ( rkind ), intent ( in ) :: values (:) type ( tensor_t ) tensor end function end interface interface pure module function values ( self ) result ( tensor_values ) implicit none class ( tensor_t ), intent ( in ) :: self real ( rkind ), allocatable :: tensor_values (:) end function pure module function num_components ( self ) result ( n ) implicit none class ( tensor_t ), intent ( in ) :: self integer n end function end interface end module tensor_m","tags":"","loc":"sourcefile/tensor_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m ! External dependencies use kind_parameters_m , only : rkind use sourcery_string_m , only : string_t implicit none private public :: activation_strategy_t public :: activation_i public :: function_name_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation procedure ( function_name_i ), deferred :: function_name end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental function function_name_i ( self ) result ( string ) import string_t , activation_strategy_t implicit none class ( activation_strategy_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"learn-power-series.f90 – Inference-Engine","text":"This file depends on sourcefile~~learn-power-series.f90~~EfferentGraph sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module power_series !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ 1 + x ( 1 ) + ( x ( 1 ) ** 2 ) / 2 + ( x ( 1 ) ** 3 ) / 6 , x ( 2 ), x ( 3 ), x ( 4 ), x ( 5 ), x ( 6 )]) end associate end function end module program learn_power_series !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use power_series , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-power-series --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 10000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) real white_noise ( 1 : num_inputs , 1 : num_pairs ) call random_number ( white_noise ) inputs = [( tensor_t ( real ([( white_noise ( j , i ), j = 1 , num_inputs )])), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 196 , 196 , 196 , 196 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-power-series.f90.html"},{"title":"hyperparameters_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_s.f90~~EfferentGraph sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( hyperparameters_m ) hyperparameters_s use assert_m , only : assert implicit none character ( len =* ), parameter :: mini_batches_key = \"mini-batches\" character ( len =* ), parameter :: learning_rate_key = \"learning rate\" character ( len =* ), parameter :: optimizer_key = \"optimizer\" contains module procedure from_components hyperparameters % mini_batches_ = mini_batches hyperparameters % learning_rate_ = learning_rate hyperparameters % optimizer_ = optimizer end procedure module procedure equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % optimizer_ ) . and . allocated ( rhs % optimizer_ ), \"hyperparameters_s(equals): allocated optimizers\" ) lhs_equals_rhs = & lhs % mini_batches_ == rhs % mini_batches_ . and . & lhs % optimizer_ == rhs % optimizer_ . and . & abs ( lhs % learning_rate_ - rhs % learning_rate_ ) <= tolerance end procedure module procedure from_json integer l logical hyperparameters_key_found hyperparameters_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"hyperparameters\" ) then hyperparameters_key_found = . true . hyperparameters % mini_batches_ = lines ( l + 1 )% get_json_value ( string_t ( mini_batches_key ), mold = 0 ) hyperparameters % learning_rate_ = lines ( l + 2 )% get_json_value ( string_t ( learning_rate_key ), mold = 0. ) hyperparameters % optimizer_ = lines ( l + 3 )% get_json_value ( string_t ( optimizer_key ), mold = string_t ( \"\" )) return end if end do call assert ( hyperparameters_key_found , \"hyperparameters_s(from_json): hyperparameters_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_width = 18 character ( len = max_width ) mini_batches_string , learning_rate_string write ( mini_batches_string , * ) self % mini_batches_ write ( learning_rate_string , * ) self % learning_rate_ lines = [ & string_t ( indent // '\"hyperparameters\": {' ), & string_t ( indent // indent // '\"' // mini_batches_key // '\" : ' // trim ( adjustl ( mini_batches_string )) // \",\" ), & string_t ( indent // indent // '\"' // learning_rate_key // '\" : ' // trim ( adjustl ( learning_rate_string )) // \",\" ), & string_t ( indent // indent // '\"' // optimizer_key // '\" : \"' // trim ( adjustl ( self % optimizer_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure mini_batches num_mini_batches = self % mini_batches_ end procedure module procedure optimizer_name identifier = string_t ( self % optimizer_ ) end procedure module procedure learning_rate rate = self % learning_rate_ end procedure end submodule hyperparameters_s","tags":"","loc":"sourcefile/hyperparameters_s.f90.html"},{"title":"relu_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_m.f90~~EfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~relu_m.f90~~AfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module relu_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_string_m , only : string_t implicit none private public :: relu_t type , extends ( differentiable_activation_strategy_t ) :: relu_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( relu_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module relu_m","tags":"","loc":"sourcefile/relu_m.f90.html"},{"title":"ubounds_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~ubounds_m.f90~~AfferentGraph sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module ubounds_m !! This module serves only to support array bounds checking in the main program below implicit none type ubounds_t integer , allocatable :: ubounds_ (:) contains procedure equals generic :: operator ( == ) => equals end type contains elemental function equals ( lhs , rhs ) result ( lhs_equals_rhs ) class ( ubounds_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs lhs_equals_rhs = all ( lhs % ubounds_ == rhs % ubounds_ ) end function end module","tags":"","loc":"sourcefile/ubounds_m.f90.html"},{"title":"mini_batch_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : rkind implicit none private public :: mini_batch_t type mini_batch_t private type ( input_output_pair_t ), allocatable :: input_output_pairs_ (:) contains procedure :: input_output_pairs end type interface mini_batch_t pure module function construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function end interface interface pure module function input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference.  The network performs an identity mapping from any !! non-negative inputs to the corresponding outputs using a RELU activation !! function. use inference_engine_m , only : inference_engine_t , relu_t , tensor_t use sourcery_m , only : string_t , command_line_t , file_t use kind_parameters_m , only : rkind implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example write-read-infer --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains function identity_network () result ( inference_engine ) type ( inference_engine_t ) inference_engine integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) inference_engine = inference_engine_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = reshape ([ real ( rkind ) :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]), & biases = reshape ([ real ( rkind ) :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) end function subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"},{"title":"tensor_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_s.f90~~EfferentGraph sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_m ) tensor_s implicit none contains module procedure construct_from_components tensor % values_ = values end procedure module procedure values tensor_values = self % values_ end procedure module procedure num_components n = size ( self % values_ ) end procedure end submodule tensor_s","tags":"","loc":"sourcefile/tensor_s.f90.html"},{"title":"trainable_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_m.f90~~EfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~trainable_engine_m.f90~~AfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module trainable_engine_m !! Define an abstraction that supports training a neural network use sourcery_string_m , only : string_t use inference_engine_m_ , only : inference_engine_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use mini_batch_m , only : mini_batch_t use training_configuration_m , only : training_configuration_t implicit none private public :: trainable_engine_t type trainable_engine_t !! Encapsulate the information needed to perform training private type ( string_t ), allocatable :: metadata_ (:) real ( rkind ), allocatable :: w (:,:,:) ! weights real ( rkind ), allocatable :: b (:,:) ! biases integer , allocatable :: n (:) ! nodes per layer class ( differentiable_activation_strategy_t ), allocatable :: differentiable_activation_strategy_ contains procedure :: assert_consistent procedure :: train procedure :: infer procedure :: num_layers procedure :: num_inputs procedure :: num_outputs procedure :: to_inference_engine end type integer , parameter :: input_layer = 0 interface trainable_engine_t pure module function construct_from_padded_arrays ( nodes , weights , biases , differentiable_activation_strategy , metadata ) & result ( trainable_engine ) implicit none integer , intent ( in ) :: nodes ( input_layer :) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) class ( differentiable_activation_strategy_t ), intent ( in ) :: differentiable_activation_strategy type ( string_t ), intent ( in ) :: metadata (:) type ( trainable_engine_t ) trainable_engine end function pure module function construct_from_inference_engine ( inference_engine ) result ( trainable_engine ) implicit none type ( inference_engine_t ), intent ( in ) :: inference_engine type ( trainable_engine_t ) trainable_engine end function module function perturbed_identity_network ( training_configuration , perturbation_magnitude , metadata ) result ( trainable_engine ) implicit none type ( training_configuration_t ), intent ( in ) :: training_configuration type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: perturbation_magnitude type ( trainable_engine_t ) trainable_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( trainable_engine_t ), intent ( in ) :: self end subroutine pure module subroutine train ( self , mini_batches , cost , adam , learning_rate ) implicit none class ( trainable_engine_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches (:) real ( rkind ), intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ) :: adam real ( rkind ), intent ( in ) :: learning_rate end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_inputs ( self ) result ( n_in ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_in end function elemental module function num_outputs ( self ) result ( n_out ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_out end function elemental module function num_layers ( self ) result ( n_layers ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_layers end function module function to_inference_engine ( self ) result ( inference_engine ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( inference_engine_t ) :: inference_engine end function end interface end module trainable_engine_m","tags":"","loc":"sourcefile/trainable_engine_m.f90.html"},{"title":"train-and-write.F90 – Inference-Engine","text":"This file depends on sourcefile~~train-and-write.f90~~EfferentGraph sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_and_write !! This program demonstrates how to train a simple neural network starting from a randomized initial condition and !! how to write the initial network and the trained network to separate JSON files.  The network has two hiden layers. !! The input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match !! the corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions, !! the desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere. !! The initial condition corresponds to the desired network with all weights and biases perturbed by a random variable !! that is uniformly distributed on the range [0,0.1]. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-and-write --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 5 , num_epochs = 500 , num_mini_batches = 3 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.2 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) call assert ( num_inputs == num_outputs , \"trainable_engine_test_m(identity_mapping): # inputs == # outputs\" , & intrinsic_array_t ([ num_inputs , num_outputs ]) & ) block integer i , j inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] end block associate ( outputs => inputs ) input_output_pairs = input_output_pair_t ( inputs , outputs ) end associate block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \" Outputs                          |& Desired outputs                    |& Errors\" do p = 1 , num_pairs print * , network_outputs ( p )% values (), \"|\" , inputs ( p )% values (), \"|\" , network_outputs ( p )% values () - inputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) integer i real , parameter :: identity ( * , * , * ) = & reshape ( real ([( [ 1 , 0 ], [ 0 , 1 ], i = 1 , layers - 1 )]), [ max_n , max_n , layers - 1 ]) real w_harvest ( size ( identity , 1 ), size ( identity , 2 ), size ( identity , 3 )), b_harvest ( size ( identity , 1 ), size ( identity , 3 )) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = nodes_per_layer , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/train-and-write.f90.html"},{"title":"saturated_mixing_ratio_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~saturated_mixing_ratio_m.f90~~EfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~saturated_mixing_ratio_m.f90~~AfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. module saturated_mixing_ratio_m !! This module supports the program in the file example/learn-saturated-mixing-ratio.f90. !! The saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function !! in the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90. !! ICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: freezing_threshold = 27 3.15 ! [K] real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains pure function saturated_mixing_ratio ( T_normalized , p_normalized ) result ( sat_mr ) !! Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) real , intent ( in ) :: T_normalized , p_normalized real sat_mr associate ( & temperature => T_min + ( T_max - T_min ) * T_normalized , & pressure => p_min + ( p_max - p_min ) * p_normalized & ) associate ( below_freezing => temperature < freezing_threshold ) associate ( & a => merge ( 2 1.8745584 , 1 7.2693882 , below_freezing ), & b => merge ( 7.66 , 3 5.86 , below_freezing ) & ) associate ( p_threshold => 61 0.78 * exp ( a * ( temperature - 27 3.16 ) / ( temperature - b ))) !(Pa)) associate ( e_s => merge ( pressure * 0.99999 , p_threshold , ( pressure - p_threshold ) <= 0 )) sat_mr = 0.6219907 * e_s / ( pressure - e_s ) !(kg/kg) end associate end associate end associate end associate end associate end function elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ saturated_mixing_ratio ( x ( 1 ), x ( 2 ))]) end associate end function end module","tags":"","loc":"sourcefile/saturated_mixing_ratio_m.f90.html"},{"title":"network_configuration_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~network_configuration_m.f90~~AfferentGraph sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~network_configuration_s.f90 network_configuration_s.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module network_configuration_m use sourcery_string_m , only : string_t implicit none private public :: network_configuration_t type network_configuration_t private logical :: skip_connections_ = . false . integer , allocatable :: nodes_per_layer_ (:) character ( len = :), allocatable :: activation_name_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: activation_name procedure :: nodes_per_layer procedure :: skip_connections end type interface network_configuration_t pure module function from_json ( lines ) result ( network_configuration ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( network_configuration_t ) network_configuration end function pure module function from_components ( skip_connections , nodes_per_layer , activation_name ) result ( network_configuration ) implicit none logical , intent ( in ) :: skip_connections integer , intent ( in ) :: nodes_per_layer (:) character ( len =* ), intent ( in ) :: activation_name type ( network_configuration_t ) network_configuration end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( network_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function activation_name ( self ) result ( string ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ) string end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( network_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( network_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/network_configuration_m.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind use sourcery_string_m , only : string_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( step_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"neuron_s(construct): neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"neuron_s(construct): neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"neuron_s(construct): neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"neuron_s(construct): neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure module procedure function_name string = string_t ( \"step\" ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"hyperparameters_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_m.f90~~EfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~hyperparameters_m.f90~~AfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module hyperparameters_m use sourcery_string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: hyperparameters_t type hyperparameters_t private integer :: mini_batches_ = 10 real :: learning_rate_ = 1.5 character ( len = :), allocatable :: optimizer_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate end type interface hyperparameters_t pure module function from_json ( lines ) result ( hyperparameters ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( hyperparameters_t ) hyperparameters end function pure module function from_components ( mini_batches , learning_rate , optimizer ) result ( hyperparameters ) implicit none integer , intent ( in ) :: mini_batches real , intent ( in ) :: learning_rate character ( len =* ), intent ( in ) :: optimizer type ( hyperparameters_t ) hyperparameters end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( hyperparameters_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( hyperparameters_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( hyperparameters_t ), intent ( in ) :: self real ( rkind ) rate end function end interface end module","tags":"","loc":"sourcefile/hyperparameters_m.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use sourcery_string_m , only : string_t implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( swish_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"print-training-configuration.f90 – Inference-Engine","text":"This file depends on sourcefile~~print-training-configuration.f90~~EfferentGraph sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program print_training_configuration !! Demonstrate how to construct and print a training_configuration_t object use inference_engine_m , only : training_configuration_t , hyperparameters_t , network_configuration_t use sourcery_m , only : file_t implicit none associate ( training_configuration => training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" ) & )) associate ( json_file => file_t ( training_configuration % to_json ())) call json_file % write_lines () end associate end associate end program","tags":"","loc":"sourcefile/print-training-configuration.f90.html"},{"title":"learn-addition.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-addition.f90~~EfferentGraph sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module addition_m !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) + x ( 2 ), x ( 2 ) + x ( 3 ), x ( 3 ) + x ( 4 ), x ( 4 ) + x ( 5 ), x ( 5 ) + x ( 6 ), x ( 6 ) + x ( 8 )]) end associate end function end module program learn_addition !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use addition_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-addition --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-addition.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure module procedure function_name string = string_t ( \"sigmoid\" ) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"training_configuration_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_s.f90~~EfferentGraph sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( training_configuration_m ) training_configuration_s use assert_m , only : assert use inference_engine_m , only : relu_t , sigmoid_t , swish_t implicit none character ( len =* ), parameter :: header = \"{\" , footer = \"}\" , separator = \",\" contains module procedure from_components training_configuration % hyperparameters_ = hyperparameters training_configuration % network_configuration_ = network_configuration training_configuration % file_t = file_t ([ & string_t ( header ), & training_configuration % hyperparameters_ % to_json (), & string_t ( separator ), & training_configuration % network_configuration_ % to_json (), & string_t ( footer ) & ]) end procedure module procedure from_file integer , parameter :: hyperparameters_start = 2 , hyperparameters_end = 6 , separator_line = 7 ! line numbers integer , parameter :: net_config_start = 8 , net_config_end = 12 ! line numbers integer , parameter :: file_start = hyperparameters_start - 1 , file_end = net_config_end + 1 ! line numbers training_configuration % file_t = file_object associate ( lines => training_configuration % file_t % lines ()) call assert ( trim ( adjustl ( lines ( file_start )% string ())) == header , \"training_configuration_s(from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( trim ( adjustl ( lines ( separator_line )% string ())) == separator , \"training_configuration_s(from_file): separator\" , & lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( trim ( adjustl ( lines ( file_end )% string ())) == footer , \"training_configuration_s(from_file): footer\" , lines ( file_end )) end associate end procedure module procedure to_json json_lines = self % lines () end procedure module procedure equals lhs_eq_rhs = & lhs % hyperparameters_ == rhs % hyperparameters_ . and . & lhs % network_configuration_ == rhs % network_configuration_ end procedure module procedure mini_batches num_mini_batches = self % hyperparameters_ % mini_batches () end procedure module procedure optimizer_name identifier = self % hyperparameters_ % optimizer_name () end procedure module procedure learning_rate rate = self % hyperparameters_ % learning_rate () end procedure module procedure nodes_per_layer nodes = self % network_configuration_ % nodes_per_layer () end procedure module procedure skip_connections using_skip = self % network_configuration_ % skip_connections () end procedure module procedure differentiable_activation_strategy associate ( activation_name => self % network_configuration_ % activation_name ()) select case ( activation_name % string ()) case ( \"relu\" ) strategy = relu_t () case ( \"sigmoid\" ) strategy = sigmoid_t () case ( \"swish\" ) strategy = swish_t () case default error stop 'activation_strategy_factory_s(factory): unrecognized activation name \"' // activation_name % string () // '\"' end select end associate end procedure end submodule training_configuration_s","tags":"","loc":"sourcefile/training_configuration_s.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use sourcery_string_m , only : string_t use kind_parameters_m , only : rkind use inference_engine_m_ , only : inference_engine_t implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: inference_engine procedure :: count_layers procedure :: count_neurons procedure :: count_inputs procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function inference_engine ( hidden_layers , metadata , output_layer ) result ( inference_engine_ ) implicit none class ( layer_t ), intent ( in ), target :: hidden_layers type ( layer_t ), intent ( in ), target :: output_layer type ( string_t ), intent ( in ) :: metadata (:) type ( inference_engine_t ) inference_engine_ end function module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ), intent ( in ) :: layer integer num_inputs end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"inference_engine_m_.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m_.f90~~EfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~inference_engine_m_.f90~~AfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m_ !! Define an abstraction that supports inference operationsn on a neural network use activation_strategy_m , only : activation_strategy_t use sourcery_file_m , only : file_t use sourcery_string_m , only : string_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: inference_engine_t public :: difference_t public :: exchange_t public :: infer character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference private type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: infer procedure :: to_json procedure :: num_inputs procedure :: num_outputs procedure :: nodes_per_layer procedure :: assert_conformable_with procedure :: skip procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: activation_function_name procedure :: to_exchange end type type exchange_t type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation end type type difference_t private real ( rkind ), allocatable :: weights_difference_ (:,:,:), biases_difference_ (:,:) integer , allocatable :: nodes_difference_ (:) contains procedure :: norm end type interface inference_engine_t pure module function construct_from_padded_arrays ( metadata , weights , biases , nodes ) result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface pure module function to_exchange ( self ) result ( exchange ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( exchange_t ) exchange end function impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( difference_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( difference_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function pure module function nodes_per_layer ( self ) result ( node_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer , allocatable :: node_count (:) end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function pure module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function end interface end module inference_engine_m_","tags":"","loc":"sourcefile/inference_engine_m_.f90.html"},{"title":"training_configuration_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_m.f90~~EfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~training_configuration_m.f90~~AfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module training_configuration_m use sourcery_string_m , only : string_t use sourcery_file_m , only : file_t use hyperparameters_m , only : hyperparameters_t use network_configuration_m , only : network_configuration_t use kind_parameters_m , only : rkind use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: training_configuration_t type , extends ( file_t ) :: training_configuration_t private type ( hyperparameters_t ) hyperparameters_ type ( network_configuration_t ) network_configuration_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate procedure :: differentiable_activation_strategy procedure :: nodes_per_layer procedure :: skip_connections end type interface training_configuration_t module function from_components ( hyperparameters , network_configuration ) result ( training_configuration ) implicit none type ( hyperparameters_t ), intent ( in ) :: hyperparameters type ( network_configuration_t ), intent ( in ) :: network_configuration type ( training_configuration_t ) training_configuration end function module function from_file ( file_object ) result ( training_configuration ) implicit none type ( file_t ), intent ( in ) :: file_object type ( training_configuration_t ) training_configuration end function end interface interface pure module function to_json ( self ) result ( json_lines ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: json_lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_eq_rhs ) implicit none class ( training_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( training_configuration_t ), intent ( in ) :: self real ( rkind ) rate end function module function differentiable_activation_strategy ( self ) result ( strategy ) implicit none class ( training_configuration_t ), intent ( in ) :: self class ( differentiable_activation_strategy_t ), allocatable :: strategy end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( training_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/training_configuration_m.f90.html"},{"title":"concurrent-inferences.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent-inferences.f90~~EfferentGraph sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program concurrent_inferences !! This program demonstrates how to read a neural network from a JSON file !! and use the network to perform concurrent inferences. use inference_engine_m , only : inference_engine_t , tensor_t , infer use sourcery_m , only : string_t , command_line_t , file_t use assert_m , only : assert use iso_fortran_env , only : int64 , real64 implicit none type ( string_t ) network_file_name type ( command_line_t ) command_line network_file_name = string_t ( command_line % flag_value ( \"--network\" )) if ( len ( network_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example concurrent-inferences --profile release --flag \"-fopenmp\" -- --network \"<file-name>\"' end if block type ( inference_engine_t ) network , inference_engine type ( tensor_t ), allocatable :: inputs (:,:,:), outputs (:,:,:) real , allocatable :: input_components (:,:,:,:) integer , parameter :: lat = 263 , lon = 317 , lev = 15 ! latitudes, longitudes, levels (elevations) integer i , j , k print * , \"Constructing a new inference_engine_t object from the file \" // network_file_name % string () inference_engine = inference_engine_t ( file_t ( network_file_name )) print * , \"Defining an array of tensor_t input objects with random normalized components\" allocate ( inputs ( lat , lon , lev )) allocate ( input_components ( lat , lon , lev , inference_engine % num_inputs ())) call random_number ( input_components ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) inputs ( i , j , k ) = tensor_t ( input_components ( i , j , k ,:)) end do block integer ( int64 ) t_start , t_finish , clock_rate print * , \"Performing elemental inferences\" call system_clock ( t_start , clock_rate ) outputs = inference_engine % infer ( inputs ) ! implicit allocation of outputs array call system_clock ( t_finish ) print * , \"Elemental inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) call assert ( all ( shape ( outputs ) == shape ( inputs )), \"all(shape(outputs) == shape(inputs))\" ) print * , \"Performing loop-based inference\" call system_clock ( t_start ) do k = 1 , lev do j = 1 , lon do i = 1 , lat outputs ( i , j , k ) = inference_engine % infer ( inputs ( i , j , k )) end do end do end do call system_clock ( t_finish ) print * , \"Looping inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing concurrent inference\" call system_clock ( t_start ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = inference_engine % infer ( inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Concurrent inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing concurrent inference with a non-type-bound inference procedure\" call system_clock ( t_start ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = infer ( inference_engine , inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Concurrent inference time with non-type-bound procedure: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) end block end block end program","tags":"","loc":"sourcefile/concurrent-inferences.f90.html"},{"title":"learn-saturated-mixing-ratio.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-saturated-mixing-ratio.f90~~EfferentGraph sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_saturated_mixture_ratio !! This program trains a neural network to learn the saturated mixing ratio function of ICAR. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use saturated_mixing_ratio_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-saturated-mixing-ratio --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 6 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 1 ] real , parameter :: cost_tolerance = 1.E-08 #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print * , \"Inputs (normalized)          | Outputs      | Desired outputs\" do p = 1 , num_pairs print \"(4(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do end associate end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Saturated Mixing Ratio\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-saturated-mixing-ratio.f90.html"},{"title":"network_configuration_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~network_configuration_s.f90~~EfferentGraph sourcefile~network_configuration_s.f90 network_configuration_s.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( network_configuration_m ) network_configuration_s use assert_m , only : assert use sourcery_formats_m , only : csv implicit none character ( len =* ), parameter :: skip_connections_key = \"skip connections\" character ( len =* ), parameter :: nodes_per_layer_key = \"nodes per layer\" character ( len =* ), parameter :: activation_name_key = \"activation function\" contains module procedure from_components network_configuration % skip_connections_ = skip_connections network_configuration % nodes_per_layer_ = nodes_per_layer network_configuration % activation_name_ = activation_name end procedure module procedure equals call assert ( allocated ( lhs % activation_name_ ) . and . allocated ( rhs % activation_name_ ), & \"network_configuration_s(equals): allocated({lhs,rhs}%activation_name_)\" ) lhs_equals_rhs = & lhs % skip_connections_ . eqv . rhs % skip_connections_ . and . & lhs % activation_name_ == rhs % activation_name_ . and . & all ( lhs % nodes_per_layer_ == rhs % nodes_per_layer_ ) end procedure module procedure from_json integer l logical network_configuration_key_found network_configuration_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"network configuration\" ) then network_configuration_key_found = . true . network_configuration % skip_connections_ = lines ( l + 1 )% get_json_value ( string_t ( skip_connections_key ), mold = . true .) network_configuration % nodes_per_layer_ = lines ( l + 2 )% get_json_value ( string_t ( nodes_per_layer_key ), mold = [ integer :: ]) network_configuration % activation_name_ = lines ( l + 3 )% get_json_value ( string_t ( activation_name_key ), mold = string_t ( \"\" )) return end if end do call assert ( network_configuration_key_found , \"network_configuration_s(from_json): network_configuration_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_logical_width = 6 , char_per_elem = 10 , brackets = 2 character ( len = max_logical_width ) skip_connections_string character ( len = :), allocatable :: nodes_per_layer_string allocate ( character ( len = size ( self % nodes_per_layer_ ) * char_per_elem + brackets ) :: nodes_per_layer_string ) write ( skip_connections_string , * ) trim ( merge ( \"true \" , \"false\" , self % skip_connections_ )) write ( nodes_per_layer_string , csv ) self % nodes_per_layer_ lines = [ & string_t ( indent // '\"network configuration\": {' ), & string_t ( indent // indent // '\"' // skip_connections_key // '\" : ' // trim ( adjustl ( skip_connections_string )) // ',' ), & string_t ( indent // indent // '\"' // nodes_per_layer_key // '\" : [' // trim ( adjustl ( nodes_per_layer_string )) // '],' ), & string_t ( indent // indent // '\"' // activation_name_key // '\" : \"' // trim ( adjustl ( self % activation_name_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure activation_name string = self % activation_name_ end procedure module procedure nodes_per_layer nodes = self % nodes_per_layer_ end procedure module procedure skip_connections using_skip = self % skip_connections_ end procedure end submodule network_configuration_s","tags":"","loc":"sourcefile/network_configuration_s.f90.html"},{"title":"learn-multiplication.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-multiplication.f90~~EfferentGraph sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module multiply_inputs !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) * x ( 2 ), x ( 2 ) * x ( 3 ), x ( 3 ) * x ( 4 ), x ( 4 ) * x ( 5 ), x ( 5 ) * x ( 6 ), x ( 6 ) * x ( 8 )]) end associate end function end module program learn_multiplication !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use sourcery_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use multiply_inputs , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-multiplication --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) #ifndef NAGFOR call random_init ( image_distinct = . true ., repeatable = . true .) #endif trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p associate ( network_outputs => trainable_engine % infer ( inputs )) print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do end associate end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-multiplication.f90.html"}]}