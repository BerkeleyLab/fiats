var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine supports research in concurrent, large-batch inference and training of deep, feed-forward neural networks.  Inference-Engine targets high-performance computing (HPC) applications with performance-critical inference and training needs.  The initial target application is in situ training of a cloud microphysics model proxy for the Intermediate Complexity Atmospheric Research ( ICAR ) model.  Such a proxy must support concurrent inference at every grid point at every time step of an ICAR run.  For validation purposes, Inference-Engine also supports the export and import of neural networks to and from Python by the companion package nexport . The features of Inference-Engine that make it suitable for use in HPC applications include Implementation in Fortran 2018. Exposing concurrency via Elemental , implicitly pure inference procedures, An elemental and implicitly pure activation strategy, and A pure training subroutine, Gathering network weights and biases into contiguous arrays for efficient memory access patterns, and User-controlled mini-batch size facilitating in situ training at application runtime. Making Inference-Engine's infer functions and train subroutines pure facilitates invoking those procedures inside Fortran do concurrent constructs, which some compilers can offload automatically to graphics processing units (GPUs).  The use of contiguous arrays facilitates spatial locality in memory access patterns.  User control of mini-batch size facilitates in-situ training at application runtime. Downloading, Building and Testing To download, build, and test Inference-Engine, enter the following commands in a Linux, macOS, or Windows Subsystem for Linux shell: git clone https://github.com/berkeleylab/inference-engine\ncd inference-engine\n./setup.sh whereupon the trailing output will provide instructions for running the codes in the example subdirectory. Examples The example subdirectory contains demonstrations of several intended use cases. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Sourcery Institute","tags":"home","loc":"index.html"},{"title":"NetCDF_file_t – Inference-Engine ","text":"type, public :: NetCDF_file_t Contents Variables file_name_ Constructor NetCDF_file_t Type-Bound Procedures input input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_name_ Constructor public interface NetCDF_file_t private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t ) Type-Bound Procedures generic, public :: input => input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar private interface input_2D_integer () Arguments None private interface input_1D_double () Arguments None private interface input_4D_real () Arguments None private interface input_3D_real () Arguments None private interface input_real_scalar () Arguments None procedure, public :: input_1D_double interface private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) procedure, public :: input_2D_integer interface private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) procedure, public :: input_3D_real interface private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) procedure, public :: input_4D_real interface private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) procedure, public :: input_real_scalar interface private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"type/netcdf_file_t.html"},{"title":"trainable_engine_t – Inference-Engine ","text":"type, public :: trainable_engine_t Encapsulate the information needed to perform training Inherits type~~trainable_engine_t~~InheritsGraph type~trainable_engine_t trainable_engine_t string_t string_t type~trainable_engine_t->string_t metadata_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables b differentiable_activation_strategy_ metadata_ n w Constructor trainable_engine_t Type-Bound Procedures assert_consistent infer num_inputs num_layers to_inference_engine train Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor public interface trainable_engine_t private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) Type-Bound Procedures procedure, public :: assert_consistent interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self procedure, public :: infer interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_layers interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: to_inference_engine interface private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) procedure, public :: train interface private pure module module subroutine train(self, mini_batches, cost, adam) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in), optional :: adam","tags":"","loc":"type/trainable_engine_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~step_t step_t type~step_t->type~activation_strategy_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/sigmoid_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables neuron next Constructor layer_t Type-Bound Procedures count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target Type-Bound Procedures procedure, public :: count_inputs interface private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer procedure, public :: count_layers interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) procedure, public :: inference_engine interface private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) procedure, public :: neurons_per_layer interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"type/layer_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bias_ next weights_ Constructor neuron_t Type-Bound Procedures bias next_allocated next_pointer num_inputs weights Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer procedure, public :: num_inputs interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"tensor_t – Inference-Engine ","text":"type, public :: tensor_t Inherited by type~~tensor_t~~InheritedByGraph type~tensor_t tensor_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables num_components values values_ Constructor tensor_t Components Type Visibility Attributes Name Initial procedure, public :: num_components procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor public interface tensor_t private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"type/tensor_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/step_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: function_name interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"type/swish_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures activation activation_derivative function_name Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred, nopass :: function_name elemental module function function_name_i() result(string) Prototype Arguments None Return Value type(string_t)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"input_output_pair_t – Inference-Engine ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables expected_outputs_ inputs_ Constructor input_output_pair_t Type-Bound Procedures expected_outputs inputs Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) Type-Bound Procedures procedure, public :: expected_outputs interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, public :: inputs interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"type/input_output_pair_t.html"},{"title":"difference_t – Inference-Engine ","text":"type, public :: difference_t Contents Variables biases_difference_ nodes_difference_ weights_difference_ Type-Bound Procedures norm Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"type/difference_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_strategy_ biases_ metadata_ nodes_ weights_ Constructor inference_engine_t Type-Bound Procedures activation_function_name assert_conformable_with infer nodes_per_layer num_inputs num_outputs operator(-) skip to_json subtract Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor public interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine procedure, public :: infer interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: nodes_per_layer interface private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) procedure, public :: num_inputs interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private interface subtract () Arguments None procedure, public :: skip interface private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: subtract interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"mini_batch_t – Inference-Engine ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_output_pairs_ Constructor mini_batch_t Type-Bound Procedures input_output_pairs Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) Type-Bound Procedures procedure, public :: input_output_pairs interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"type/mini_batch_t.html"},{"title":"activation_i – Inference-Engine","text":"abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"function_name_i – Inference-Engine","text":"abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name_i.html"},{"title":"NetCDF_file_t – Inference-Engine","text":"public interface NetCDF_file_t Contents Functions construct Functions private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t )","tags":"","loc":"interface/netcdf_file_t.html"},{"title":"input_1D_double – Inference-Engine","text":"interface Calls interface~~input_1d_double~~CallsGraph interface~input_1d_double input_1D_double proc~input_1d_double input_1D_double interface~input_1d_double->proc~input_1d_double nf90_strerror nf90_strerror proc~input_1d_double->nf90_strerror assert assert proc~input_1d_double->assert intrinsic_array_t intrinsic_array_t proc~input_1d_double->intrinsic_array_t array_shape array_shape proc~input_1d_double->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:)","tags":"","loc":"interface/input_1d_double.html"},{"title":"input_2D_integer – Inference-Engine","text":"interface Calls interface~~input_2d_integer~~CallsGraph interface~input_2d_integer input_2D_integer proc~input_2d_integer input_2D_integer interface~input_2d_integer->proc~input_2d_integer nf90_strerror nf90_strerror proc~input_2d_integer->nf90_strerror assert assert proc~input_2d_integer->assert array_shape array_shape proc~input_2d_integer->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:)","tags":"","loc":"interface/input_2d_integer.html"},{"title":"input_3D_real – Inference-Engine","text":"interface Calls interface~~input_3d_real~~CallsGraph interface~input_3d_real input_3D_real proc~input_3d_real input_3D_real interface~input_3d_real->proc~input_3d_real nf90_strerror nf90_strerror proc~input_3d_real->nf90_strerror assert assert proc~input_3d_real->assert intrinsic_array_t intrinsic_array_t proc~input_3d_real->intrinsic_array_t array_shape array_shape proc~input_3d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:)","tags":"","loc":"interface/input_3d_real.html"},{"title":"input_4D_real – Inference-Engine","text":"interface Calls interface~~input_4d_real~~CallsGraph interface~input_4d_real input_4D_real proc~input_4d_real input_4D_real interface~input_4d_real->proc~input_4d_real nf90_strerror nf90_strerror proc~input_4d_real->nf90_strerror assert assert proc~input_4d_real->assert intrinsic_array_t intrinsic_array_t proc~input_4d_real->intrinsic_array_t array_shape array_shape proc~input_4d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:)","tags":"","loc":"interface/input_4d_real.html"},{"title":"input_real_scalar – Inference-Engine","text":"interface Calls interface~~input_real_scalar~~CallsGraph interface~input_real_scalar input_real_scalar proc~input_real_scalar input_real_scalar interface~input_real_scalar->proc~input_real_scalar nf90_strerror nf90_strerror proc~input_real_scalar->nf90_strerror assert assert proc~input_real_scalar->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"interface/input_real_scalar.html"},{"title":"trainable_engine_t – Inference-Engine","text":"public interface trainable_engine_t Contents Functions construct_from_padded_arrays Functions private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t )","tags":"","loc":"interface/trainable_engine_t.html"},{"title":"assert_consistent – Inference-Engine","text":"interface Calls interface~~assert_consistent~~CallsGraph interface~assert_consistent assert_consistent proc~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t assert assert proc~assert_consistent->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~~CallsGraph interface~infer infer proc~infer infer interface~infer->proc~infer n n proc~infer->n b b proc~infer->b w w proc~infer->w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~~CallsGraph interface~num_inputs num_inputs proc~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_layers – Inference-Engine","text":"interface Calls interface~~num_layers~~CallsGraph interface~num_layers num_layers proc~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_layers.html"},{"title":"to_inference_engine – Inference-Engine","text":"interface Calls interface~~to_inference_engine~~CallsGraph interface~to_inference_engine to_inference_engine proc~to_inference_engine to_inference_engine interface~to_inference_engine->proc~to_inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t )","tags":"","loc":"interface/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"interface Calls interface~~train~~CallsGraph interface~train train proc~train train interface~train->proc~train n n proc~train->n b b proc~train->b w w proc~train->w y y proc~train->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine train(self, mini_batches, cost, adam) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in), optional :: adam","tags":"","loc":"interface/train.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~~CallsGraph interface~activation activation proc~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~~CallsGraph interface~activation_derivative activation_derivative proc~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~~CallsGraph interface~function_name function_name proc~function_name function_name interface~function_name->proc~function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Contents Functions construct Functions private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target","tags":"","loc":"interface/layer_t.html"},{"title":"count_inputs – Inference-Engine","text":"interface Calls interface~~count_inputs~~CallsGraph interface~count_inputs count_inputs proc~count_inputs count_inputs interface~count_inputs->proc~count_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer","tags":"","loc":"interface/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"interface Calls interface~~count_layers~~CallsGraph interface~count_layers count_layers proc~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Calls interface~~count_neurons~~CallsGraph interface~count_neurons count_neurons proc~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"interface Calls interface~~inference_engine~~CallsGraph interface~inference_engine inference_engine proc~inference_engine inference_engine interface~inference_engine->proc~inference_engine assert assert proc~inference_engine->assert weights weights proc~inference_engine->weights biases biases proc~inference_engine->biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface Calls interface~~neurons_per_layer~~CallsGraph interface~neurons_per_layer neurons_per_layer proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~~CallsGraph interface~next_allocated next_allocated proc~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~~CallsGraph interface~next_pointer next_pointer proc~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Contents Functions construct Functions private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface Calls interface~~bias~~CallsGraph interface~bias bias proc~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Calls interface~~next_allocated~2~~CallsGraph interface~next_allocated~2 next_allocated proc~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Calls interface~~next_pointer~2~~CallsGraph interface~next_pointer~2 next_pointer proc~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~2~~CallsGraph interface~num_inputs~2 num_inputs proc~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"weights – Inference-Engine","text":"interface Calls interface~~weights~~CallsGraph interface~weights weights proc~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"get_shape – Inference-Engine","text":"function get_shape(ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable,(:) Calls proc~~get_shape~~CallsGraph proc~get_shape get_shape nf90_strerror nf90_strerror proc~get_shape->nf90_strerror assert assert proc~get_shape->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_shape.html"},{"title":"tensor_t – Inference-Engine","text":"public interface tensor_t Contents Functions construct_from_components Functions private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"interface/tensor_t.html"},{"title":"num_components – Inference-Engine","text":"interface Calls interface~~num_components~~CallsGraph interface~num_components num_components proc~num_components num_components interface~num_components->proc~num_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_components.html"},{"title":"values – Inference-Engine","text":"interface Calls interface~~values~~CallsGraph interface~values values proc~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/values.html"},{"title":"set_activation_strategy – Inference-Engine","text":"pure subroutine set_activation_strategy(inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Called by proc~~set_activation_strategy~~CalledByGraph proc~set_activation_strategy set_activation_strategy proc~construct_from_json construct_from_json proc~construct_from_json->proc~set_activation_strategy proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~construct_from_padded_arrays~2->proc~set_activation_strategy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_activation_strategy.html"},{"title":"assert_consistency – Inference-Engine","text":"private interface assert_consistency Calls interface~~assert_consistency~~CallsGraph interface~assert_consistency assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~assert_consistency~~CalledByGraph interface~assert_consistency assert_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~infer~2 infer proc~infer~2->interface~assert_consistency proc~num_inputs~3 num_inputs proc~num_inputs~3->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~construct_from_padded_arrays~2->interface~assert_consistency interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~infer~2 infer interface~infer~2->proc~infer~2 interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures inference_engine_consistency difference_consistency Module Procedures pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistency.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~2~~CallsGraph interface~activation~2 activation proc~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~2~~CallsGraph interface~function_name~2 function_name proc~function_name~2 function_name interface~function_name~2->proc~function_name~2 string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~2.html"},{"title":"activation – Inference-Engine","text":"interface Calls interface~~activation~3~~CallsGraph interface~activation~3 activation proc~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Calls interface~~activation_derivative~2~~CallsGraph interface~activation_derivative~2 activation_derivative proc~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"interface Calls interface~~function_name~3~~CallsGraph interface~function_name~3 function_name proc~function_name~3 function_name interface~function_name~3->proc~function_name~3 string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t)","tags":"","loc":"interface/function_name~3.html"},{"title":"input_output_pair_t – Inference-Engine","text":"public interface input_output_pair_t Contents Functions construct Functions private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"expected_outputs – Inference-Engine","text":"interface Calls interface~~expected_outputs~~CallsGraph interface~expected_outputs expected_outputs proc~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"interface Calls interface~~inputs~~CallsGraph interface~inputs inputs proc~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/inputs.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Contents Functions construct_from_json construct_from_padded_arrays Functions private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Calls interface~~activation_function_name~~CallsGraph interface~activation_function_name activation_function_name proc~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface Calls interface~~assert_conformable_with~~CallsGraph interface~assert_conformable_with assert_conformable_with proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~assert_consistency assert_consistency proc~assert_conformable_with->interface~assert_consistency assert assert proc~assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"infer – Inference-Engine","text":"interface Calls interface~~infer~2~~CallsGraph interface~infer~2 infer proc~infer~2 infer interface~infer~2->proc~infer~2 interface~assert_consistency assert_consistency proc~infer~2->interface~assert_consistency n n proc~infer~2->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Calls interface~~nodes_per_layer~~CallsGraph interface~nodes_per_layer nodes_per_layer proc~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~assert_consistency assert_consistency proc~nodes_per_layer->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"interface Calls interface~~norm~~CallsGraph interface~norm norm proc~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_inputs – Inference-Engine","text":"interface Calls interface~~num_inputs~3~~CallsGraph interface~num_inputs~3 num_inputs proc~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 interface~assert_consistency assert_consistency proc~num_inputs~3->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~3.html"},{"title":"num_outputs – Inference-Engine","text":"interface Calls interface~~num_outputs~~CallsGraph interface~num_outputs num_outputs proc~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~assert_consistency assert_consistency proc~num_outputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"skip – Inference-Engine","text":"interface Calls interface~~skip~~CallsGraph interface~skip skip proc~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract interface~assert_consistency assert_consistency proc~subtract->interface~assert_consistency n n proc~subtract->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_json – Inference-Engine","text":"interface Calls interface~~to_json~~CallsGraph interface~to_json to_json proc~to_json to_json interface~to_json->proc~to_json interface~assert_consistency assert_consistency proc~to_json->interface~assert_consistency assert assert proc~to_json->assert n n proc~to_json->n file_t file_t proc~to_json->file_t separated_values separated_values proc~to_json->separated_values string_t string_t proc~to_json->string_t hidden_layer_weights hidden_layer_weights proc~to_json->hidden_layer_weights intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json.html"},{"title":"mini_batch_t – Inference-Engine","text":"public interface mini_batch_t Contents Functions construct Functions private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"interface/mini_batch_t.html"},{"title":"input_output_pairs – Inference-Engine","text":"interface Calls interface~~input_output_pairs~~CallsGraph interface~input_output_pairs input_output_pairs proc~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/input_output_pairs.html"},{"title":"one_random_hidden_layer – Inference-Engine","text":"function one_random_hidden_layer() result(trainable_engine) Arguments None Return Value type( trainable_engine_t ) Calls proc~~one_random_hidden_layer~~CallsGraph proc~one_random_hidden_layer one_random_hidden_layer string_t string_t proc~one_random_hidden_layer->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~one_random_hidden_layer~~CalledByGraph proc~one_random_hidden_layer one_random_hidden_layer program~train_and_write train_and_write program~train_and_write->proc~one_random_hidden_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/one_random_hidden_layer.html"},{"title":"xor – Inference-Engine","text":"elemental function xor(inputs) result(expected_outputs) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Contents None","tags":"","loc":"proc/xor.html"},{"title":"single_hidden_layer_xor_network – Inference-Engine","text":"function single_hidden_layer_xor_network() result(inference_engine) Arguments None Return Value type( inference_engine_t ) Calls proc~~single_hidden_layer_xor_network~~CallsGraph proc~single_hidden_layer_xor_network single_hidden_layer_xor_network string_t string_t proc~single_hidden_layer_xor_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~single_hidden_layer_xor_network~~CalledByGraph proc~single_hidden_layer_xor_network single_hidden_layer_xor_network proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->proc~single_hidden_layer_xor_network program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/single_hidden_layer_xor_network.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer proc~single_hidden_layer_xor_network single_hidden_layer_xor_network proc~write_read_query_infer->proc~single_hidden_layer_xor_network file_t file_t proc~write_read_query_infer->file_t string_t string_t proc~single_hidden_layer_xor_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_query_infer Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) network_outputs real ( rkind ), parameter :: false = 0._rkind , true = 1._rkind print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = single_hidden_layer_xor_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ( tensor_t ([ real ( rkind ) :: false , true ])) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % values () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components module procedure construct_from_components() Arguments None Contents None","tags":"","loc":"proc/construct_from_components.html"},{"title":"num_components – Inference-Engine","text":"module procedure num_components pure module module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer Called by proc~~num_components~~CalledByGraph proc~num_components num_components interface~num_components num_components interface~num_components->proc~num_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_components.html"},{"title":"values – Inference-Engine","text":"module procedure values pure module module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~values~~CalledByGraph proc~values values interface~values values interface~values->proc~values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/values.html"},{"title":"assert_consistent – Inference-Engine","text":"module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t assert assert proc~assert_consistent->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_consistent~~CalledByGraph proc~assert_consistent assert_consistent interface~assert_consistent assert_consistent interface~assert_consistent->proc~assert_consistent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_consistent.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None Contents None","tags":"","loc":"proc/construct_from_padded_arrays.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~~CallsGraph proc~infer infer n n proc~infer->n b b proc~infer->b w w proc~infer->w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~~CalledByGraph proc~infer infer interface~infer infer interface~infer->proc~infer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~~CalledByGraph proc~num_inputs num_inputs interface~num_inputs num_inputs interface~num_inputs->proc~num_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs.html"},{"title":"num_layers – Inference-Engine","text":"module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer Called by proc~~num_layers~~CalledByGraph proc~num_layers num_layers interface~num_layers num_layers interface~num_layers->proc~num_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_layers.html"},{"title":"to_inference_engine – Inference-Engine","text":"module procedure to_inference_engine pure module module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) Called by proc~~to_inference_engine~~CalledByGraph proc~to_inference_engine to_inference_engine interface~to_inference_engine to_inference_engine interface~to_inference_engine->proc~to_inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"module procedure train pure module module subroutine train(self, mini_batches, cost, adam) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in), optional :: adam Calls proc~~train~~CallsGraph proc~train train n n proc~train->n b b proc~train->b w w proc~train->w y y proc~train->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~train~~CalledByGraph proc~train train interface~train train interface~train->proc~train Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/train.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct.html"},{"title":"input_1D_double – Inference-Engine","text":"module procedure input_1D_double module module subroutine input_1D_double(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) Calls proc~~input_1d_double~~CallsGraph proc~input_1d_double input_1D_double nf90_strerror nf90_strerror proc~input_1d_double->nf90_strerror assert assert proc~input_1d_double->assert intrinsic_array_t intrinsic_array_t proc~input_1d_double->intrinsic_array_t array_shape array_shape proc~input_1d_double->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_1d_double~~CalledByGraph proc~input_1d_double input_1D_double interface~input_1d_double input_1D_double interface~input_1d_double->proc~input_1d_double Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_1d_double.html"},{"title":"input_2D_integer – Inference-Engine","text":"module procedure input_2D_integer module module subroutine input_2D_integer(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) Calls proc~~input_2d_integer~~CallsGraph proc~input_2d_integer input_2D_integer nf90_strerror nf90_strerror proc~input_2d_integer->nf90_strerror assert assert proc~input_2d_integer->assert array_shape array_shape proc~input_2d_integer->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_2d_integer~~CalledByGraph proc~input_2d_integer input_2D_integer interface~input_2d_integer input_2D_integer interface~input_2d_integer->proc~input_2d_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_2d_integer.html"},{"title":"input_3D_real – Inference-Engine","text":"module procedure input_3D_real module module subroutine input_3D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) Calls proc~~input_3d_real~~CallsGraph proc~input_3d_real input_3D_real nf90_strerror nf90_strerror proc~input_3d_real->nf90_strerror assert assert proc~input_3d_real->assert intrinsic_array_t intrinsic_array_t proc~input_3d_real->intrinsic_array_t array_shape array_shape proc~input_3d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_3d_real~~CalledByGraph proc~input_3d_real input_3D_real interface~input_3d_real input_3D_real interface~input_3d_real->proc~input_3d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_3d_real.html"},{"title":"input_4D_real – Inference-Engine","text":"module procedure input_4D_real module module subroutine input_4D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) Calls proc~~input_4d_real~~CallsGraph proc~input_4d_real input_4D_real nf90_strerror nf90_strerror proc~input_4d_real->nf90_strerror assert assert proc~input_4d_real->assert intrinsic_array_t intrinsic_array_t proc~input_4d_real->intrinsic_array_t array_shape array_shape proc~input_4d_real->array_shape Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_4d_real~~CalledByGraph proc~input_4d_real input_4D_real interface~input_4d_real input_4D_real interface~input_4d_real->proc~input_4d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_4d_real.html"},{"title":"input_real_scalar – Inference-Engine","text":"module procedure input_real_scalar module module subroutine input_real_scalar(self, varname, scalar) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar Calls proc~~input_real_scalar~~CallsGraph proc~input_real_scalar input_real_scalar nf90_strerror nf90_strerror proc~input_real_scalar->nf90_strerror assert assert proc~input_real_scalar->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_real_scalar~~CalledByGraph proc~input_real_scalar input_real_scalar interface~input_real_scalar input_real_scalar interface~input_real_scalar->proc~input_real_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_real_scalar.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~bias~~CalledByGraph proc~bias bias interface~bias bias interface~bias->proc~bias Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~2~~CallsGraph proc~construct~2 construct neuron_lines neuron_lines proc~construct~2->neuron_lines assert assert proc~construct~2->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~2~~CalledByGraph proc~next_allocated~2 next_allocated interface~next_allocated~2 next_allocated interface~next_allocated~2->proc~next_allocated~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer Called by proc~~next_pointer~2~~CalledByGraph proc~next_pointer~2 next_pointer interface~next_pointer~2 next_pointer interface~next_pointer~2->proc~next_pointer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer Called by proc~~num_inputs~2~~CalledByGraph proc~num_inputs~2 num_inputs interface~num_inputs~2 num_inputs interface~num_inputs~2->proc~num_inputs~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~2.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:) Called by proc~~weights~~CalledByGraph proc~weights weights interface~weights weights interface~weights->proc~weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/weights.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~2~~CalledByGraph proc~activation~2 activation interface~activation~2 activation interface~activation~2->proc~activation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~2~~CallsGraph proc~function_name~2 function_name string_t string_t proc~function_name~2->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~2~~CalledByGraph proc~function_name~2 function_name interface~function_name~2 function_name interface~function_name~2->proc~function_name~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~2.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~~CalledByGraph proc~activation activation interface~activation activation interface~activation->proc~activation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~~CalledByGraph proc~activation_derivative activation_derivative interface~activation_derivative activation_derivative interface~activation_derivative->proc~activation_derivative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name function_name string_t string_t proc~function_name->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~~CalledByGraph proc~function_name function_name interface~function_name function_name interface~function_name->proc~function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~3~~CallsGraph proc~construct~3 construct layer_lines layer_lines proc~construct~3->layer_lines assert assert proc~construct~3->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct~3.html"},{"title":"count_inputs – Inference-Engine","text":"module procedure count_inputs module module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer Called by proc~~count_inputs~~CalledByGraph proc~count_inputs count_inputs interface~count_inputs count_inputs interface~count_inputs->proc~count_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer Called by proc~~count_layers~~CalledByGraph proc~count_layers count_layers interface~count_layers count_layers interface~count_layers->proc~count_layers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:) Called by proc~~count_neurons~~CalledByGraph proc~count_neurons count_neurons interface~count_neurons count_neurons interface~count_neurons->proc~count_neurons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"module procedure inference_engine module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) Calls proc~~inference_engine~~CallsGraph proc~inference_engine inference_engine assert assert proc~inference_engine->assert weights weights proc~inference_engine->weights biases biases proc~inference_engine->biases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inference_engine~~CalledByGraph proc~inference_engine inference_engine interface~inference_engine inference_engine interface~inference_engine->proc~inference_engine Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Called by proc~~neurons_per_layer~~CalledByGraph proc~neurons_per_layer neurons_per_layer interface~neurons_per_layer neurons_per_layer interface~neurons_per_layer->proc~neurons_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical Called by proc~~next_allocated~~CalledByGraph proc~next_allocated next_allocated interface~next_allocated next_allocated interface~next_allocated->proc~next_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Called by proc~~next_pointer~~CalledByGraph proc~next_pointer next_pointer interface~next_pointer next_pointer interface~next_pointer->proc~next_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/next_pointer.html"},{"title":"difference_consistency – Inference-Engine","text":"pure module subroutine difference_consistency(self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Calls proc~~difference_consistency~~CallsGraph proc~difference_consistency difference_consistency intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t assert assert proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~difference_consistency~~CalledByGraph proc~difference_consistency difference_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~difference_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~infer~2 infer proc~infer~2->interface~assert_consistency proc~num_inputs~3 num_inputs proc~num_inputs~3->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~construct_from_padded_arrays~2->interface~assert_consistency interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~infer~2 infer interface~infer~2->proc~infer~2 interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/difference_consistency.html"},{"title":"inference_engine_consistency – Inference-Engine","text":"pure module subroutine inference_engine_consistency(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~inference_engine_consistency~~CallsGraph proc~inference_engine_consistency inference_engine_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inference_engine_consistency~~CalledByGraph proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~inference_engine_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~infer~2 infer proc~infer~2->interface~assert_consistency proc~num_inputs~3 num_inputs proc~num_inputs~3->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~construct_from_padded_arrays~2->interface~assert_consistency interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with interface~infer~2 infer interface~infer~2->proc~infer~2 interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs interface~subtract subtract interface~subtract->proc~subtract interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inference_engine_consistency.html"},{"title":"activation_function_name – Inference-Engine","text":"module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) Called by proc~~activation_function_name~~CalledByGraph proc~activation_function_name activation_function_name interface~activation_function_name activation_function_name interface~activation_function_name->proc~activation_function_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Calls proc~~assert_conformable_with~~CallsGraph proc~assert_conformable_with assert_conformable_with interface~assert_consistency assert_consistency proc~assert_conformable_with->interface~assert_consistency assert assert proc~assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assert_conformable_with~~CalledByGraph proc~assert_conformable_with assert_conformable_with interface~assert_conformable_with assert_conformable_with interface~assert_conformable_with->proc~assert_conformable_with Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assert_conformable_with.html"},{"title":"construct_from_json – Inference-Engine","text":"module procedure construct_from_json module procedure construct_from_json() Arguments None Calls proc~~construct_from_json~~CallsGraph proc~construct_from_json construct_from_json assert assert proc~construct_from_json->assert interface~assert_consistency assert_consistency proc~construct_from_json->interface~assert_consistency string_t string_t proc~construct_from_json->string_t proc~set_activation_strategy set_activation_strategy proc~construct_from_json->proc~set_activation_strategy proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_json.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None Calls proc~~construct_from_padded_arrays~2~~CallsGraph proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~set_activation_strategy set_activation_strategy proc~construct_from_padded_arrays~2->proc~set_activation_strategy interface~assert_consistency assert_consistency proc~construct_from_padded_arrays~2->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_padded_arrays~2.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~2~~CallsGraph proc~infer~2 infer interface~assert_consistency assert_consistency proc~infer~2->interface~assert_consistency n n proc~infer~2->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~infer~2~~CalledByGraph proc~infer~2 infer interface~infer~2 infer interface~infer~2->proc~infer~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/infer~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:) Calls proc~~nodes_per_layer~~CallsGraph proc~nodes_per_layer nodes_per_layer interface~assert_consistency assert_consistency proc~nodes_per_layer->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nodes_per_layer~~CalledByGraph proc~nodes_per_layer nodes_per_layer interface~nodes_per_layer nodes_per_layer interface~nodes_per_layer->proc~nodes_per_layer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) Called by proc~~norm~~CalledByGraph proc~norm norm interface~norm norm interface~norm->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/norm.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~3~~CallsGraph proc~num_inputs~3 num_inputs interface~assert_consistency assert_consistency proc~num_inputs~3->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_inputs~3~~CalledByGraph proc~num_inputs~3 num_inputs interface~num_inputs~3 num_inputs interface~num_inputs~3->proc~num_inputs~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_inputs~3.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs interface~assert_consistency assert_consistency proc~num_outputs->interface~assert_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~num_outputs~~CalledByGraph proc~num_outputs num_outputs interface~num_outputs num_outputs interface~num_outputs->proc~num_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/num_outputs.html"},{"title":"skip – Inference-Engine","text":"module procedure skip pure module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical Called by proc~~skip~~CalledByGraph proc~skip skip interface~skip skip interface~skip->proc~skip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/skip.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract interface~assert_consistency assert_consistency proc~subtract->interface~assert_consistency n n proc~subtract->n proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t assert assert proc~inference_engine_consistency->assert proc~difference_consistency->intrinsic_array_t proc~difference_consistency->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Calls proc~~to_json~~CallsGraph proc~to_json to_json interface~assert_consistency assert_consistency proc~to_json->interface~assert_consistency assert assert proc~to_json->assert n n proc~to_json->n file_t file_t proc~to_json->file_t separated_values separated_values proc~to_json->separated_values string_t string_t proc~to_json->string_t hidden_layer_weights hidden_layer_weights proc~to_json->hidden_layer_weights intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~to_json~~CalledByGraph proc~to_json to_json interface~to_json to_json interface~to_json->proc~to_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/to_json.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation~3~~CalledByGraph proc~activation~3 activation interface~activation~3 activation interface~activation~3->proc~activation~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Called by proc~~activation_derivative~2~~CalledByGraph proc~activation_derivative~2 activation_derivative interface~activation_derivative~2 activation_derivative interface~activation_derivative~2->proc~activation_derivative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t) Calls proc~~function_name~3~~CallsGraph proc~function_name~3 function_name string_t string_t proc~function_name~3->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~function_name~3~~CalledByGraph proc~function_name~3 function_name interface~function_name~3 function_name interface~function_name~3->proc~function_name~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/function_name~3.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~4.html"},{"title":"input_output_pairs – Inference-Engine","text":"module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:) Called by proc~~input_output_pairs~~CalledByGraph proc~input_output_pairs input_output_pairs interface~input_output_pairs input_output_pairs interface~input_output_pairs->proc~input_output_pairs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/input_output_pairs.html"},{"title":"construct – Inference-Engine","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~5.html"},{"title":"expected_outputs – Inference-Engine","text":"module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Called by proc~~expected_outputs~~CalledByGraph proc~expected_outputs expected_outputs interface~expected_outputs expected_outputs interface~expected_outputs->proc~expected_outputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Called by proc~~inputs~~CalledByGraph proc~inputs inputs interface~inputs inputs interface~inputs->proc~inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inputs.html"},{"title":"inference_engine_m – Inference-Engine","text":"Specify the user-facing modules, derived types, and type parameters Uses step_m inference_engine_m_ NetCDF_file_m activation_strategy_m mini_batch_m differentiable_activation_strategy_m trainable_engine_m kind_parameters_m sigmoid_m swish_m tensor_m input_output_pair_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~step_m step_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m string_m string_m module~sigmoid_m->string_m module~tensor_m->module~kind_parameters_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m file_m file_m module~inference_engine_m_->file_m module~inference_engine_m_->string_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/inference_engine_m.html"},{"title":"NetCDF_file_m – Inference-Engine","text":"Used by Descendants: netCDF_file_s module~~netcdf_file_m~~UsedByGraph module~netcdf_file_m NetCDF_file_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~netcdf_file_m module~netcdf_file_s netCDF_file_s module~netcdf_file_s->module~netcdf_file_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces NetCDF_file_t input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Derived Types NetCDF_file_t Interfaces public interface NetCDF_file_t private pure module function construct(file_name) result(NetCDF_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( NetCDF_file_t ) interface private module module subroutine input_1D_double(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) interface private module module subroutine input_2D_integer(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) interface private module module subroutine input_3D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) interface private module module subroutine input_4D_real(self, varname, values) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) interface private module module subroutine input_real_scalar(self, varname, scalar) Implementation → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar Derived Types type, public :: NetCDF_file_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_name_ Constructor private pure,module function construct (file_name) Type-Bound Procedures generic, public :: input => input_2D_integer, input_1D_double, input_4D_real, input_3D_real, input_real_scalar procedure, public :: input_1D_double procedure, public :: input_2D_integer procedure, public :: input_3D_real procedure, public :: input_4D_real procedure, public :: input_real_scalar","tags":"","loc":"module/netcdf_file_m.html"},{"title":"trainable_engine_m – Inference-Engine","text":"Define an abstraction that supports training a neural network Uses inference_engine_m_ mini_batch_m sourcery_m differentiable_activation_strategy_m kind_parameters_m tensor_m module~~trainable_engine_m~~UsesGraph module~trainable_engine_m trainable_engine_m module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~trainable_engine_m->module~tensor_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m file_m file_m module~inference_engine_m_->file_m string_m string_m module~inference_engine_m_->string_m module~inference_engine_m_->module~activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: trainable_engine_s module~~trainable_engine_m~~UsedByGraph module~trainable_engine_m trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Interfaces trainable_engine_t assert_consistent infer num_inputs num_layers to_inference_engine train Derived Types trainable_engine_t Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Interfaces public interface trainable_engine_t private pure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) Return Value type( trainable_engine_t ) interface private pure module module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private elemental module module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private pure module module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) interface private pure module module subroutine train(self, mini_batches, cost, adam) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in), optional :: adam Derived Types type, public :: trainable_engine_t Encapsulate the information needed to perform training Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) real(kind=rkind), private, allocatable :: w (:,:,:) Constructor private pure,module function construct_from_padded_arrays (nodes, weights, biases, differentiable_activation_strategy, metadata) Type-Bound Procedures procedure, public :: assert_consistent procedure, public :: infer procedure, public :: num_inputs procedure, public :: num_layers procedure, public :: to_inference_engine procedure, public :: train","tags":"","loc":"module/trainable_engine_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses string_m kind_parameters_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m string_m string_m module~activation_strategy_m->string_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~step_m step_m module~step_m->module~activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~step_m module~inference_engine_m->module~inference_engine_m_ module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~differentiable_activation_strategy_m->module~activation_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m program~write_read_infer->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~layer_m->module~inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~step_m program~read_json read_json program~read_json->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~swish_m->module~differentiable_activation_strategy_m module~layer_s layer_s module~layer_s->module~layer_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces activation_i function_name_i Derived Types activation_strategy_t Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) abstract interface public elemental module function function_name_i() result(string) Arguments None Return Value type(string_t) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/activation_strategy_m.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m string_m kind_parameters_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types sigmoid_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/sigmoid_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses inference_engine_m_ kind_parameters_m neuron_m sourcery_m module~~layer_m~~UsesGraph module~layer_m layer_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m sourcery_m sourcery_m module~layer_m->sourcery_m module~inference_engine_m_->module~kind_parameters_m string_m string_m module~inference_engine_m_->string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m file_m file_m module~inference_engine_m_->file_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces layer_t count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Derived Types layer_t Interfaces public interface layer_t private recursive module function construct(layer_lines, start) result(layer) construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ),target interface private module module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer interface private module module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module module function count_neurons(layer) result(neurons_per_layer) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) interface private module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) interface private module module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private recursive,module function construct (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_inputs procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: inference_engine procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses string_m kind_parameters_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~inference_engine_s->module~layer_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces neuron_t bias next_allocated next_pointer num_inputs weights Derived Types neuron_t Interfaces public interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer interface private pure module module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private pure,recursive,module function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"tensor_m – Inference-Engine","text":"Uses kind_parameters_m module~~tensor_m~~UsesGraph module~tensor_m tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: tensor_s module~~tensor_m~~UsedByGraph module~tensor_m tensor_m module~trainable_engine_m trainable_engine_m module~trainable_engine_m->module~tensor_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m program~write_read_infer write_read_infer program~write_read_infer->module~tensor_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~inference_engine_m->module~tensor_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~mini_batch_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~inference_engine_m_->module~tensor_m module~input_output_pair_m->module~tensor_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~layer_m layer_m module~layer_m->module~inference_engine_m_ module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~layer_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m program~read_json read_json program~read_json->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces tensor_t num_components values Derived Types tensor_t Interfaces public interface tensor_t private pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) interface private pure module module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer interface private pure module module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:) Derived Types type, public :: tensor_t Components Type Visibility Attributes Name Initial procedure, public :: num_components procedure, public :: values real(kind=rkind), private, allocatable :: values_ (:) Constructor private pure,module function construct_from_components (values)","tags":"","loc":"module/tensor_m.html"},{"title":"step_m – Inference-Engine","text":"Uses string_m activation_strategy_m kind_parameters_m module~~step_m~~UsesGraph module~step_m step_m string_m string_m module~step_m->string_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~activation_strategy_m->string_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~step_m program~write_read_infer write_read_infer program~write_read_infer->module~step_m program~write_read_infer->module~inference_engine_m module~step_s step_s module~step_s->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m program~read_json read_json program~read_json->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation function_name Derived Types step_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: function_name","tags":"","loc":"module/step_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m string_m kind_parameters_m module~~swish_m~~UsesGraph module~swish_m swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m string_m string_m module~swish_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~swish_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces activation activation_derivative function_name Derived Types swish_t Interfaces interface private elemental module module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module module function function_name() result(string) Implementation → Arguments None Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public, nopass :: function_name","tags":"","loc":"module/swish_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m string_m string_m module~activation_strategy_m->string_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~layer_m->module~inference_engine_m_ program~read_json read_json program~read_json->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~sigmoid_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types differentiable_activation_strategy_t Derived Types type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure(activation_i), public, nopass :: activation procedure(activation_i), public, nopass :: activation_derivative procedure(function_name_i), public, nopass :: function_name","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"input_output_pair_m – Inference-Engine","text":"Uses tensor_m kind_parameters_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~input_output_pair_m module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_m->module~mini_batch_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m program~read_json read_json program~read_json->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces input_output_pair_t expected_outputs inputs Derived Types input_output_pair_t Interfaces public interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) interface private elemental module module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor private elemental,module function construct (inputs, expected_outputs) Type-Bound Procedures procedure, public :: expected_outputs procedure, public :: inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~mini_batch_m mini_batch_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~mini_batch_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~step_m step_m module~inference_engine_m->module~step_m module~inference_engine_m->module~input_output_pair_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~layer_m->module~inference_engine_m_ module~neuron_m neuron_m module~layer_m->module~neuron_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~inference_engine_m program~write_read_infer->module~tensor_m program~write_read_infer->module~step_m module~activation_strategy_m->module~kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~neuron_m->module~kind_parameters_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~layer_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~step_m module~inference_engine_s->module~swish_m module~inference_engine_s->module~neuron_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m program~read_json read_json program~read_json->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~sigmoid_m module~trainable_engine_s->module~trainable_engine_m module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~input_output_pair_m module~layer_s layer_s module~layer_s->module~layer_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"inference_engine_m_ – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses string_m activation_strategy_m differentiable_activation_strategy_m kind_parameters_m file_m tensor_m module~~inference_engine_m_~~UsesGraph module~inference_engine_m_ inference_engine_m_ string_m string_m module~inference_engine_m_->string_m module~kind_parameters_m kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m file_m file_m module~inference_engine_m_->file_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->string_m module~activation_strategy_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: inference_engine_s module~~inference_engine_m_~~UsedByGraph module~inference_engine_m_ inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~layer_m->module~inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m program~read_json read_json program~read_json->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~layer_s layer_s module~layer_s->module~layer_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables key Interfaces inference_engine_t activation_function_name assert_conformable_with infer nodes_per_layer norm num_inputs num_outputs skip subtract to_json Derived Types difference_t inference_engine_t Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces public interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private pure module function construct_from_padded_arrays(metadata, weights, biases, nodes) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) Return Value type( inference_engine_t ) interface private elemental module module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private elemental module module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private pure module module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) interface private elemental module module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private pure module module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) interface private impure elemental module module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), private, allocatable :: activation_strategy_ real(kind=rkind), private, allocatable :: biases_ (:,:) type(string_t), private :: metadata_ (size(key)) integer, private, allocatable :: nodes_ (:) real(kind=rkind), private, allocatable :: weights_ (:,:,:) Constructor private impure,elemental,module function construct_from_json (file_) private pure,module function construct_from_padded_arrays (metadata, weights, biases, nodes) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with procedure, public :: infer procedure, public :: nodes_per_layer procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: skip procedure, public :: to_json procedure, private :: subtract","tags":"","loc":"module/inference_engine_m_.html"},{"title":"mini_batch_m – Inference-Engine","text":"Uses kind_parameters_m input_output_pair_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~trainable_engine_m->module~mini_batch_m program~read_json read_json program~read_json->module~inference_engine_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces mini_batch_t input_output_pairs Derived Types mini_batch_t Interfaces public interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) interface private pure module module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor private pure,module function construct (input_output_pairs) Type-Bound Procedures procedure, public :: input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"tensor_s – Inference-Engine","text":"Uses Ancestors: tensor_m module~~tensor_s~~UsesGraph module~tensor_s tensor_s module~tensor_m tensor_m module~tensor_s->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_components num_components values Module Procedures module procedure construct_from_components module procedure construct_from_components() Arguments None module procedure num_components pure module module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer module procedure values pure module module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/tensor_s.html"},{"title":"trainable_engine_s – Inference-Engine","text":"Uses assert_m sigmoid_m tensor_m input_output_pair_m intrinsic_array_m Ancestors: trainable_engine_m module~~trainable_engine_s~~UsesGraph module~trainable_engine_s trainable_engine_s assert_m assert_m module~trainable_engine_s->assert_m module~sigmoid_m sigmoid_m module~trainable_engine_s->module~sigmoid_m module~tensor_m tensor_m module~trainable_engine_s->module~tensor_m module~trainable_engine_m trainable_engine_m module~trainable_engine_s->module~trainable_engine_m intrinsic_array_m intrinsic_array_m module~trainable_engine_s->intrinsic_array_m module~input_output_pair_m input_output_pair_m module~trainable_engine_s->module~input_output_pair_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~input_output_pair_m->module~tensor_m module~input_output_pair_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->string_m module~inference_engine_m_->module~activation_strategy_m file_m file_m module~inference_engine_m_->file_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables input_layer Module Procedures assert_consistent construct_from_padded_arrays infer num_inputs num_layers to_inference_engine train Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure assert_consistent pure module module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure num_inputs elemental module module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure num_layers elemental module module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure to_inference_engine pure module module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) module procedure train pure module module subroutine train(self, mini_batches, cost, adam) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches (:) real(kind=rkind), intent(out), optional allocatable :: cost (:) logical, intent(in), optional :: adam","tags":"","loc":"module/trainable_engine_s.html"},{"title":"netCDF_file_s – Inference-Engine","text":"Uses assert_m netcdf Ancestors: NetCDF_file_m module~~netcdf_file_s~~UsesGraph module~netcdf_file_s netCDF_file_s assert_m assert_m module~netcdf_file_s->assert_m netcdf netcdf module~netcdf_file_s->netcdf module~netcdf_file_m NetCDF_file_m module~netcdf_file_s->module~netcdf_file_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions get_shape Module Procedures construct input_1D_double input_2D_integer input_3D_real input_4D_real input_real_scalar Functions function get_shape (ncid, varname) result(array_shape) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varname Return Value integer,allocatable, (:) Module Procedures module procedure construct module procedure construct() Arguments None module procedure input_1D_double module module subroutine input_1D_double(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname double precision, intent(out), allocatable :: values (:) module procedure input_2D_integer module module subroutine input_2D_integer(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname integer, intent(out), allocatable :: values (:,:) module procedure input_3D_real module module subroutine input_3D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:) module procedure input_4D_real module module subroutine input_4D_real(self, varname, values) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out), allocatable :: values (:,:,:,:) module procedure input_real_scalar module module subroutine input_real_scalar(self, varname, scalar) Interface → Arguments Type Intent Optional Attributes Name class( NetCDF_file_t ), intent(in) :: self character(len=*), intent(in) :: varname real, intent(out) :: scalar","tags":"","loc":"module/netcdf_file_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m string_m string_m module~neuron_m->string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bias construct next_allocated next_pointer num_inputs weights Module Procedures module procedure bias module module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure construct module procedure construct() Arguments None module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer module procedure num_inputs pure module module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure weights module module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m string_m string_m module~step_m->string_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/step_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/sigmoid_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses assert_m intrinsic_array_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s assert_m assert_m module~layer_s->assert_m intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m module~layer_m layer_m module~layer_s->module~layer_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m sourcery_m sourcery_m module~layer_m->sourcery_m module~inference_engine_m_->module~kind_parameters_m string_m string_m module~inference_engine_m_->string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m file_m file_m module~inference_engine_m_->file_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct count_inputs count_layers count_neurons inference_engine neurons_per_layer next_allocated next_pointer Module Procedures module procedure construct module procedure construct() Arguments None module procedure count_inputs module module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer module procedure count_layers module module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure count_neurons module module function count_neurons(layer) result(neurons_per_layer) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable, (:) module procedure inference_engine module module function inference_engine(hidden_layers, metadata, output_layer) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer Return Value type( inference_engine_t ) module procedure neurons_per_layer module module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure next_allocated module module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure next_pointer module module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"module/layer_s.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses assert_m step_m neuron_m formats_m sigmoid_m swish_m layer_m file_m intrinsic_array_m Ancestors: inference_engine_m_ module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s assert_m assert_m module~inference_engine_s->assert_m module~layer_m layer_m module~inference_engine_s->module~layer_m module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m module~step_m step_m module~inference_engine_s->module~step_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m formats_m formats_m module~inference_engine_s->formats_m module~swish_m swish_m module~inference_engine_s->module~swish_m file_m file_m module~inference_engine_s->file_m intrinsic_array_m intrinsic_array_m module~inference_engine_s->intrinsic_array_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_s->module~inference_engine_m_ module~layer_m->module~neuron_m module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m sourcery_m sourcery_m module~layer_m->sourcery_m module~sigmoid_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m string_m string_m module~sigmoid_m->string_m module~step_m->module~kind_parameters_m module~step_m->string_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~neuron_m->module~kind_parameters_m module~neuron_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->string_m module~inference_engine_m_->file_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->string_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces assert_consistency Subroutines set_activation_strategy Module Subroutines difference_consistency inference_engine_consistency Module Procedures activation_function_name assert_conformable_with construct_from_json construct_from_padded_arrays infer nodes_per_layer norm num_inputs num_outputs skip subtract to_json Interfaces interface assert_consistency pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Subroutines pure subroutine set_activation_strategy (inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Module Subroutines pure module subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self pure module subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Module Procedures module procedure activation_function_name elemental module module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) module procedure assert_conformable_with elemental module module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine module procedure construct_from_json module procedure construct_from_json() Arguments None module procedure construct_from_padded_arrays module procedure construct_from_padded_arrays() Arguments None module procedure infer elemental module module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure nodes_per_layer pure module module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable, (:) module procedure norm elemental module module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) module procedure num_inputs elemental module module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure num_outputs elemental module module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure skip pure module module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical module procedure subtract elemental module module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) module procedure to_json impure elemental module module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/inference_engine_s.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m string_m string_m module~sigmoid_m->string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->string_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures activation activation_derivative function_name Module Procedures module procedure activation elemental module module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure activation_derivative elemental module module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure function_name elemental module module function function_name() result(string) Interface → Arguments None Return Value type(string_t)","tags":"","loc":"module/swish_s.html"},{"title":"mini_batch_s – Inference-Engine","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct input_output_pairs Module Procedures module procedure construct module procedure construct() Arguments None module procedure input_output_pairs pure module module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"input_output_pair_s – Inference-Engine","text":"Uses Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct expected_outputs inputs Module Procedures module procedure construct module procedure construct() Arguments None module procedure expected_outputs elemental module module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure inputs elemental module module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"module/input_output_pair_s.html"},{"title":"read_json – Inference-Engine","text":"Uses file_m string_m inference_engine_m command_line_m program~~read_json~~UsesGraph program~read_json read_json file_m file_m program~read_json->file_m module~inference_engine_m inference_engine_m program~read_json->module~inference_engine_m string_m string_m program~read_json->string_m command_line_m command_line_m program~read_json->command_line_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~step_m step_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~sigmoid_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~step_m->string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~inference_engine_m_->file_m module~inference_engine_m_->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~activation_strategy_m->string_m module~activation_strategy_m->module~kind_parameters_m module~swish_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to read a neural network from a JSON file.\nquery the network for a some of its properties. Calls program~~read_json~~CallsGraph program~read_json read_json string_t string_t program~read_json->string_t file_t file_t program~read_json->file_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables activation_name command_line inference_engine input_file_name Variables Type Attributes Name Initial type(string_t) :: activation_name type(command_line_t) :: command_line type( inference_engine_t ) :: inference_engine type(string_t) :: input_file_name","tags":"","loc":"program/read_json.html"},{"title":"train_and_write – Inference-Engine","text":"Uses inference_engine_m sourcery_m program~~train_and_write~~UsesGraph program~train_and_write train_and_write module~inference_engine_m inference_engine_m program~train_and_write->module~inference_engine_m sourcery_m sourcery_m program~train_and_write->sourcery_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~step_m step_m module~inference_engine_m->module~step_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->sourcery_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m string_m string_m module~sigmoid_m->string_m module~tensor_m->module~kind_parameters_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->string_m file_m file_m module~inference_engine_m_->file_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to train a neural network and write it to a JSON file. Calls program~~train_and_write~~CallsGraph program~train_and_write train_and_write training_inputs training_inputs program~train_and_write->training_inputs tmp2 tmp2 program~train_and_write->tmp2 harvest harvest program~train_and_write->harvest inputs inputs program~train_and_write->inputs string_t string_t program~train_and_write->string_t mini_batches mini_batches program~train_and_write->mini_batches tmp tmp program~train_and_write->tmp training_outputs training_outputs program~train_and_write->training_outputs expected_outputs expected_outputs program~train_and_write->expected_outputs proc~one_random_hidden_layer one_random_hidden_layer program~train_and_write->proc~one_random_hidden_layer outputs outputs program~train_and_write->outputs proc~one_random_hidden_layer->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line false file_name true Functions one_random_hidden_layer xor Variables Type Attributes Name Initial type(command_line_t) :: command_line real(kind=rkind), parameter :: false = 0._rkind type(string_t) :: file_name real(kind=rkind), parameter :: true = 1._rkind Functions function one_random_hidden_layer () result(trainable_engine) Arguments None Return Value type( trainable_engine_t ) elemental function xor (inputs) result(expected_outputs) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"program/train_and_write.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses string_m tensor_m step_m inference_engine_m kind_parameters_m command_line_m file_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer string_m string_m program~write_read_infer->string_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m command_line_m command_line_m program~write_read_infer->command_line_m module~tensor_m tensor_m program~write_read_infer->module~tensor_m module~step_m step_m program~write_read_infer->module~step_m file_m file_m program~write_read_infer->file_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~tensor_m module~inference_engine_m->module~step_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~netcdf_file_m NetCDF_file_m module~inference_engine_m->module~netcdf_file_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~step_m->string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ sourcery_m sourcery_m module~trainable_engine_m->sourcery_m module~sigmoid_m->string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~inference_engine_m_->string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->file_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~activation_strategy_m->string_m module~activation_strategy_m->module~kind_parameters_m module~swish_m->string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer string_t string_t program~write_read_infer->string_t proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer proc~single_hidden_layer_xor_network single_hidden_layer_xor_network proc~write_read_query_infer->proc~single_hidden_layer_xor_network file_t file_t proc~write_read_query_infer->file_t proc~single_hidden_layer_xor_network->string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables command_line file_name Functions single_hidden_layer_xor_network Subroutines write_read_query_infer Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Functions function single_hidden_layer_xor_network () result(inference_engine) Arguments None Return Value type( inference_engine_t ) Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m Source Code inference_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Specify the user-facing modules, derived types, and type parameters use activation_strategy_m , only : activation_strategy_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use input_output_pair_m , only : input_output_pair_t use inference_engine_m_ , only : inference_engine_t , difference_t use kind_parameters_m , only : rkind use mini_batch_m , only : mini_batch_t use NetCDF_file_m , only : NetCDF_file_t use sigmoid_m , only : sigmoid_t use step_m , only : step_t use swish_m , only : swish_t use tensor_m , only : tensor_t use trainable_engine_m , only : trainable_engine_t implicit none end module","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"NetCDF_file_m.f90 – Inference-Engine","text":"Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro\neffectively eliminates this file's source code when building with an Intel compiler. Files dependent on this one sourcefile~~netcdf_file_m.f90~~AfferentGraph sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~netcdf_file_s.f90 NetCDF_file_s.f90 sourcefile~netcdf_file_s.f90->sourcefile~netcdf_file_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules NetCDF_file_m Source Code NetCDF_file_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #ifndef __INTEL_FORTRAN !! Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro !! effectively eliminates this file's source code when building with an Intel compiler. module NetCDF_file_m implicit none private public :: NetCDF_file_t type NetCDF_file_t private character ( len = :), allocatable :: file_name_ contains procedure :: input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar generic :: input => input_2D_integer , input_1D_double , input_4D_real , input_3D_real , input_real_scalar end type interface NetCDF_file_t pure module function construct ( file_name ) result ( NetCDF_file ) implicit none character ( len =* ), intent ( in ) :: file_name type ( NetCDF_file_t ) NetCDF_file end function end interface interface module subroutine input_real_scalar ( self , varname , scalar ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ) :: scalar end subroutine module subroutine input_2D_integer ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname integer , intent ( out ), allocatable :: values (:,:) end subroutine module subroutine input_1D_double ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname double precision , intent ( out ), allocatable :: values (:) end subroutine module subroutine input_4D_real ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ), allocatable :: values (:,:,:,:) end subroutine module subroutine input_3D_real ( self , varname , values ) implicit none class ( NetCDF_file_t ), intent ( in ) :: self character ( len =* ), intent ( in ) :: varname real , intent ( out ), allocatable :: values (:,:,:) end subroutine end interface end module NetCDF_file_m #endif // __INTEL_FORTRAN","tags":"","loc":"sourcefile/netcdf_file_m.f90.html"},{"title":"trainable_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_m.f90~~EfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~trainable_engine_m.f90~~AfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules trainable_engine_m Source Code trainable_engine_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module trainable_engine_m !! Define an abstraction that supports training a neural network use sourcery_m , only : string_t use inference_engine_m_ , only : inference_engine_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use mini_batch_m , only : mini_batch_t implicit none private public :: trainable_engine_t type trainable_engine_t !! Encapsulate the information needed to perform training private type ( string_t ), allocatable :: metadata_ (:) real ( rkind ), allocatable :: w (:,:,:) ! weights real ( rkind ), allocatable :: b (:,:) ! biases integer , allocatable :: n (:) ! nuerons per layer class ( differentiable_activation_strategy_t ), allocatable :: differentiable_activation_strategy_ contains procedure :: assert_consistent procedure :: train procedure :: infer procedure :: num_layers procedure :: num_inputs procedure :: to_inference_engine end type integer , parameter :: input_layer = 0 interface trainable_engine_t pure module function construct_from_padded_arrays ( nodes , weights , biases , differentiable_activation_strategy , metadata ) & result ( trainable_engine ) implicit none integer , intent ( in ) :: nodes ( input_layer :) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) class ( differentiable_activation_strategy_t ), intent ( in ) :: differentiable_activation_strategy type ( string_t ), intent ( in ) :: metadata (:) type ( trainable_engine_t ) trainable_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( trainable_engine_t ), intent ( in ) :: self end subroutine pure module subroutine train ( self , mini_batches , cost , adam ) implicit none class ( trainable_engine_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches (:) real ( rkind ), intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ), optional :: adam end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_inputs ( self ) result ( n_in ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_in end function elemental module function num_layers ( self ) result ( n_layers ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_layers end function pure module function to_inference_engine ( self ) result ( inference_engine ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( inference_engine_t ) :: inference_engine end function end interface end module trainable_engine_m","tags":"","loc":"sourcefile/trainable_engine_m.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules activation_strategy_m Source Code activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m ! External dependencies use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: activation_strategy_t public :: activation_i public :: function_name_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation procedure ( function_name_i ), nopass , deferred :: function_name end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name_i () result ( string ) implicit none type ( string_t ) string end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sigmoid_m Source Code sigmoid_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"tensor_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_s.f90~~EfferentGraph sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules tensor_s Source Code tensor_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_m ) tensor_s implicit none contains module procedure construct_from_components tensor % values_ = values end procedure module procedure values tensor_values = self % values_ end procedure module procedure num_components n = size ( self % values_ ) end procedure end submodule tensor_s","tags":"","loc":"sourcefile/tensor_s.f90.html"},{"title":"trainable_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_s.f90~~EfferentGraph sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules trainable_engine_s Source Code trainable_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( trainable_engine_m ) trainable_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use input_output_pair_m , only : input_output_pair_t use sigmoid_m , only : sigmoid_t use tensor_m , only : tensor_t implicit none integer , parameter :: input_layer = 0 contains module procedure num_inputs n_in = self % n ( input_layer ) end procedure module procedure num_layers n_layers = size ( self % n , 1 ) end procedure module procedure assert_consistent associate ( & fully_allocated => [ allocated ( self % w ), allocated ( self % b ), allocated ( self % n ), allocated ( self % differentiable_activation_strategy_ )] & ) call assert ( all ( fully_allocated ), \"trainable_engine_s(assert_consistent): fully_allocated\" , intrinsic_array_t ( fully_allocated )) end associate associate ( max_width => maxval ( self % n ), component_dims => [ size ( self % b , 1 ), size ( self % w , 1 ), size ( self % w , 2 )]) call assert ( all ( component_dims == max_width ), \"trainable_engine_s(assert_consistent): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate call assert ( lbound ( self % n , 1 ) == input_layer , \"trainable_engine_s(assert_consistent): n base subsscript\" , lbound ( self % n , 1 )) end procedure module procedure infer real ( rkind ), allocatable :: z (:,:), a (:,:) integer l call self % assert_consistent associate ( w => self % w , b => self % b , n => self % n , output_layer => ubound ( self % n , 1 )) allocate ( z , mold = b ) allocate ( a ( maxval ( n ), input_layer : output_layer )) ! Activations a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end procedure module procedure train integer l , batch , mini_batch_size , pair real ( rkind ), parameter :: eta = 1.5e0 ! Learning parameter real ( rkind ), allocatable :: & z (:,:), a (:,:), delta (:,:), dcdw (:,:,:), dcdb (:,:), vdw (:,:,:), sdw (:,:,:), vdb (:,:), sdb (:,:), vdwc (:,:,:), sdwc (:,:,:), & vdbc (:,:), sdbc (:,:) type ( tensor_t ), allocatable :: inputs (:), expected_outputs (:) call self % assert_consistent associate ( output_layer => ubound ( self % n , 1 )) allocate ( a ( maxval ( self % n ), input_layer : output_layer )) ! Activations allocate ( dcdw , mold = self % w ) ! Gradient of cost function with respect to weights allocate ( vdw , mold = self % w ) allocate ( sdw , mold = self % w ) allocate ( vdwc , mold = self % w ) allocate ( sdwc , mold = self % w ) allocate ( z , mold = self % b ) ! z-values: Sum z_j&#94;l = w_jk&#94;{l} a_k&#94;{l-1} + b_j&#94;l allocate ( delta , mold = self % b ) allocate ( dcdb , mold = self % b ) ! Gradient of cost function with respect with biases allocate ( vdb , mold = self % b ) allocate ( sdb , mold = self % b ) allocate ( vdbc , mold = self % b ) allocate ( sdbc , mold = self % b ) vdw = 0.d0 sdw = 1.d0 vdb = 0.d0 sdb = 1.d0 associate ( w => self % w , b => self % b , n => self % n , num_mini_batches => size ( mini_batches )) if ( present ( cost )) allocate ( cost ( num_mini_batches )) iterate_across_batches : & do batch = 1 , num_mini_batches if ( present ( cost )) cost ( batch ) = 0. dcdw = 0. ; dcdb = 0. associate ( input_output_pairs => mini_batches ( batch )% input_output_pairs ()) inputs = input_output_pairs % inputs () expected_outputs = input_output_pairs % expected_outputs () mini_batch_size = size ( input_output_pairs ) end associate iterate_through_batch : & do pair = 1 , mini_batch_size a ( 1 : self % num_inputs (), input_layer ) = inputs ( pair )% values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward associate ( y => expected_outputs ( pair )% values ()) if ( present ( cost )) & cost ( batch ) = cost ( batch ) + sum (( y ( 1 : n ( output_layer )) - a ( 1 : n ( output_layer ), output_layer )) ** 2 ) / ( 2.e0 * mini_batch_size ) delta ( 1 : n ( output_layer ), output_layer ) = & ( a ( 1 : n ( output_layer ), output_layer ) - y ( 1 : n ( output_layer ))) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( output_layer ), output_layer )) end associate associate ( n_hidden => self % num_layers () - 2 ) back_propagate_error : & do l = n_hidden , 1 , - 1 delta ( 1 : n ( l ), l ) = matmul ( transpose ( w ( 1 : n ( l + 1 ), 1 : n ( l ), l + 1 )), delta ( 1 : n ( l + 1 ), l + 1 )) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( l ), l )) end do back_propagate_error end associate block integer j sum_gradients : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) + delta ( 1 : n ( l ), l ) do concurrent ( j = 1 : n ( l )) dcdw ( j , 1 : n ( l - 1 ), l ) = dcdw ( j , 1 : n ( l - 1 ), l ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do end do sum_gradients end block end do iterate_through_batch if ( present ( adam )) then if ( adam ) then block ! Adam parameters real , parameter :: beta1 = . 9 real , parameter :: beta2 = . 999 real , parameter :: obeta1 = 1.d0 - beta1 real , parameter :: obeta2 = 1.d0 - beta2 real , parameter :: epsilon = 1.d-8 real , parameter :: alpha = 1.5d0 ! Learning parameter adjust_weights_and_biases : & do l = 1 , output_layer dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( mini_batch_size ) vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta1 * vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta1 * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta2 * sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta2 * ( dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ** 2 ) vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1.D0 - beta1 ** num_mini_batches ) sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1.D0 - beta2 ** num_mini_batches ) w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) & - alpha * vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( sqrt ( sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l )) + epsilon ) ! Adjust weights dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size vdb ( 1 : n ( l ), l ) = beta1 * vdb ( 1 : n ( l ), l ) + obeta1 * dcdb ( 1 : n ( l ), l ) sdb ( 1 : n ( l ), l ) = beta2 * sdb ( 1 : n ( l ), l ) + obeta2 * ( dcdb ( 1 : n ( l ), l ) ** 2 ) vdbc ( 1 : n ( l ), l ) = vdb ( 1 : n ( l ), l ) / ( 1.D0 - beta1 ** num_mini_batches ) sdbc ( 1 : n ( l ), l ) = sdb ( 1 : n ( l ), l ) / ( 1.D0 - beta2 ** num_mini_batches ) b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - alpha * vdbc ( 1 : n ( l ), l ) / ( sqrt ( sdbc ( 1 : n ( l ), l )) + epsilon ) ! Adjust weights end do adjust_weights_and_biases end block else error stop \"trainable_engine_s(train): for non-adam runs, please rerun without adam argument present\" end if else adjust_weights_and_biases : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - eta * dcdb ( 1 : n ( l ), l ) ! Adjust biases dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / mini_batch_size w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - eta * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ! Adjust weights end do adjust_weights_and_biases end if end do iterate_across_batches end associate end associate end procedure module procedure construct_from_padded_arrays trainable_engine % metadata_ = metadata trainable_engine % n = nodes trainable_engine % w = weights trainable_engine % b = biases trainable_engine % differentiable_activation_strategy_ = differentiable_activation_strategy call trainable_engine % assert_consistent end procedure module procedure to_inference_engine inference_engine = inference_engine_t ( metadata = self % metadata_ , weights = self % w , biases = self % b , nodes = self % n ) end procedure end submodule trainable_engine_s","tags":"","loc":"sourcefile/trainable_engine_s.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layer_m Source Code layer_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use sourcery_m , only : string_t use kind_parameters_m , only : rkind use inference_engine_m_ , only : inference_engine_t implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: inference_engine procedure :: count_layers procedure :: count_neurons procedure :: count_inputs procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function inference_engine ( hidden_layers , metadata , output_layer ) result ( inference_engine_ ) implicit none class ( layer_t ), intent ( in ), target :: hidden_layers type ( layer_t ), intent ( in ), target :: output_layer type ( string_t ), intent ( in ) :: metadata (:) type ( inference_engine_t ) inference_engine_ end function module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer (:) end function module function count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ), intent ( in ) :: layer integer num_inputs end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules neuron_m Source Code neuron_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"NetCDF_file_s.f90 – Inference-Engine","text":"Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro\neffectively eliminates this file's source code when building with an Intel compiler. This file depends on sourcefile~~netcdf_file_s.f90~~EfferentGraph sourcefile~netcdf_file_s.f90 NetCDF_file_s.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~netcdf_file_s.f90->sourcefile~netcdf_file_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules netCDF_file_s Source Code NetCDF_file_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #ifndef __INTEL_FORTRAN !! Due to a suspected bug in the Intel ifx compiler, the above C preprocessor macro !! effectively eliminates this file's source code when building with an Intel compiler. submodule ( netCDF_file_m ) netCDF_file_s use netcdf , only : & nf90_create , nf90_def_dim , nf90_def_var , nf90_enddef , nf90_put_var , nf90_inquire_dimension , & ! functions nf90_close , nf90_open , nf90_inq_varid , nf90_get_var , nf90_inquire_variable , & nf90_clobber , nf90_noerr , nf90_strerror , nf90_int , nf90_nowrite ! constants use assert_m , only : assert , intrinsic_array_t implicit none contains module procedure construct netCDF_file % file_name_ = file_name end procedure function get_shape ( ncid , varname ) result ( array_shape ) implicit none character ( len =* ), intent ( in ) :: varname integer , intent ( in ) :: ncid integer , allocatable :: array_shape (:) character ( len = 32 ) varid_string integer varid , dimlen , i , var_rank integer , parameter :: max_rank = 15 integer , dimension ( max_rank + 1 ) :: dims , dimIds associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , ndims = var_rank )) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_variable\" // trim ( nf90_strerror ( nf_status )), & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate associate ( nf_status => nf90_inquire_variable ( ncid , varid , dimids = dimIds (: var_rank ))) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_variable\" // trim ( nf90_strerror ( nf_status )), & trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate do i = 1 , var_rank associate ( nf_status => nf90_inquire_dimension ( ncid , dimIds ( i ), len = dimlen )) call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(get_shape): nf90_inquire_dimension\" // trim ( nf90_strerror ( nf_status )),& trim ( nf90_strerror ( nf_status )) // \"(\" // varname // \")\" ) end associate dims ( i + 1 ) = dimlen end do array_shape = dims ( 2 : var_rank + 1 ) end function module procedure input_real_scalar character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , & \"Net_CDF_file_m(input_real_scalar): nf90_open\" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_real_scalar): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( nf_status => nf90_get_var ( ncid , varid , scalar )) ! read data call assert ( nf_status == nf90_noerr , \"NetCDF_file_s(input_real_scalar): nf90_get_var\" , trim ( nf90_strerror ( nf_status ))) end associate end procedure module procedure input_2D_integer character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , & \"Net_CDF_file_m(input_2D_integer): nf90_open\" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_2D_integer): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_2D_integer): size(array_shape)==rank(values)\" ) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"NetCDF_file_s(input_2D_integer): nf90_get_var\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_1D_double character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_1D_double): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_1D_double): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_4D_real character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_4D_real): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_4D_real): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ), array_shape ( 3 ), array_shape ( 4 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure module procedure input_3D_real character ( len = 32 ) varid_string integer ncid , varid associate ( nf_status => nf90_open ( self % file_name_ , nf90_nowrite , ncid ) ) ! open file with read-only acces call assert ( nf_status == nf90_noerr , \"nf90_open(self%file_name_, NF90_NOWRITE, ncid)\" , & trim ( nf90_strerror ( nf_status )) // self % file_name_ ) end associate associate ( nf_status => nf90_inq_varid ( ncid , varname , varid )) ! get variable's ID write ( varid_string , * ) varid call assert ( nf_status == nf90_noerr , \"Net_CDF_file_m(input_3D_real): nf90_inq_varid \" // trim ( nf90_strerror ( nf_status )), & diagnostic_data = \"varname '\" // varname // \"', varid \" // trim ( adjustl ( varid_string ))) end associate associate ( array_shape => get_shape ( ncid , varname )) call assert ( size ( array_shape ) == rank ( values ), \"netCDF_file_s(input_3D_real): size(array_shape)==rank(values)\" , & intrinsic_array_t ([ size ( array_shape ), rank ( values )])) allocate ( values ( array_shape ( 1 ), array_shape ( 2 ), array_shape ( 3 ))) associate ( nf_status => nf90_get_var ( ncid , varid , values )) ! read data call assert ( nf_status == nf90_noerr , \"nf90_get_var(ncid, varid, array)\" , trim ( nf90_strerror ( nf_status ))) end associate end associate end procedure end submodule netCDF_file_s #endif // __INTEL_FORTRAN","tags":"","loc":"sourcefile/netcdf_file_s.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules neuron_s Source Code neuron_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"read_json: neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"read_json: neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"read_json: neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"read_json: neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"tensor_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_m.f90~~EfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~tensor_m.f90~~AfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~tensor_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules tensor_m Source Code tensor_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_m use kind_parameters_m , only : rkind implicit none private public :: tensor_t type tensor_t private real ( rkind ), allocatable :: values_ (:) contains procedure values procedure num_components end type interface tensor_t pure module function construct_from_components ( values ) result ( tensor ) implicit none real ( rkind ), intent ( in ) :: values (:) type ( tensor_t ) tensor end function end interface interface pure module function values ( self ) result ( tensor_values ) implicit none class ( tensor_t ), intent ( in ) :: self real ( rkind ), allocatable :: tensor_values (:) end function pure module function num_components ( self ) result ( n ) implicit none class ( tensor_t ), intent ( in ) :: self integer n end function end interface end module tensor_m","tags":"","loc":"sourcefile/tensor_m.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules step_s Source Code step_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure module procedure function_name string = string_t ( \"step\" ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules sigmoid_s Source Code sigmoid_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure module procedure function_name string = string_t ( \"sigmoid\" ) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules layer_s Source Code layer_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_t construct: layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure inference_engine associate ( & num_inputs => hidden_layers % count_inputs (), & num_outputs => output_layer % count_neurons (), & neurons_per_hidden_layer => hidden_layers % count_neurons (), & num_hidden_layers => hidden_layers % count_layers (), & num_output_layers => output_layer % count_layers () & ) call assert ( num_output_layers == 1 , \"inference_engine_s(construct_from_json): 1 output layer\" , num_output_layers ) associate ( nodes => [ num_inputs , neurons_per_hidden_layer , num_outputs ]) associate ( n_max => maxval ( nodes )) block real ( rkind ), allocatable :: weights (:,:,:), biases (:,:) type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer j , l allocate ( weights ( n_max , n_max , num_hidden_layers + num_output_layers )) allocate ( biases ( n_max , num_hidden_layers + num_output_layers )) layer_ptr => hidden_layers l = 0 loop_over_hidden_Layers : & do l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_hidden_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_hidden_neurons if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next_pointer () end do loop_over_hidden_Layers layer_ptr => output_layer l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_output_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_output_neurons inference_engine_ = inference_engine_t ( metadata , weights , biases , nodes ) end block end associate end associate end associate end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer = [ neurons_per_layer , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure count_inputs num_inputs = layer % neuron % num_inputs () ! assume fully connected input layer end procedure module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"inference_engine_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules inference_engine_s Source Code inference_engine_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m_ ) inference_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use step_m , only : step_t use swish_m , only : swish_t use sigmoid_m , only : sigmoid_t use layer_m , only : layer_t use neuron_m , only : neuron_t use file_m , only : file_t use formats_m , only : separated_values implicit none interface assert_consistency module procedure inference_engine_consistency module procedure difference_consistency end interface contains module procedure infer real ( rkind ), allocatable :: z (:,:), a (:,:) integer , parameter :: input_layer = 0 integer j , k , l call assert_consistency ( self ) associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , output_layer => ubound ( self % nodes_ , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) a ( 1 : n ( l ), l ) = self % activation_strategy_ % activation ( z ) end associate end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end procedure pure module subroutine inference_engine_consistency ( self ) type ( inference_engine_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_ ), allocated ( self % biases_ ), allocated ( self % nodes_ ), allocated ( self % activation_strategy_ )]& ) call assert ( all ( all_allocated ), \"inference_engine_s(inference_engine_consistency): fully_allocated\" , & intrinsic_array_t ( all_allocated )) end associate associate ( max_width => maxval ( self % nodes_ ), component_dims => [ size ( self % biases_ , 1 ), size ( self % weights_ , 1 ), size ( self % weights_ , 2 )]) call assert ( all ( component_dims == max_width ), \"inference_engine_s(inference_engine_consistency): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate associate ( input_subscript => lbound ( self % nodes_ , 1 )) call assert ( input_subscript == input_layer , \"inference_engine_s(inference_engine_consistency): n base subsscript\" , & input_subscript ) end associate end subroutine pure module subroutine difference_consistency ( self ) type ( difference_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_difference_ ), allocated ( self % biases_difference_ ), allocated ( self % nodes_difference_ )] & ) call assert ( all ( all_allocated ), \"inference_engine_s(difference_consistency): fully_allocated\" , intrinsic_array_t ( all_allocated )) end associate call assert ( all ( size ( self % biases_difference_ , 1 ) == [ size ( self % weights_difference_ , 1 ), size ( self % weights_difference_ , 2 )]), & \"inference_engine_s(difference_consistency): conformable arrays\" & ) end subroutine pure subroutine set_activation_strategy ( inference_engine ) type ( inference_engine_t ), intent ( inout ) :: inference_engine ! This code is called in both constructors and and can't be refactored into a factory method ! pattern because the result would need to be allocatable and polymorphic, which would preclude ! the function being pure so it wouldn't be possible to call it from inside the pure constructor ! functions. select case ( inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string ()) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case default error stop \"inference_engine_s(set_activation_strategy): unrecognized activation strategy\" end select end subroutine module procedure construct_from_padded_arrays inference_engine % metadata_ = metadata inference_engine % weights_ = weights inference_engine % biases_ = biases inference_engine % nodes_ = nodes call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) end procedure construct_from_padded_arrays module procedure construct_from_json type ( string_t ), allocatable :: lines (:), metadata (:) type ( layer_t ) hidden_layers , output_layer type ( neuron_t ) output_neuron real ( rkind ), allocatable :: hidden_weights (:,:,:) integer l lines = file_ % lines () l = 1 call assert ( adjustl ( lines ( l )% string ()) == \"{\" , \"construct_from_json: expecting '{' to start outermost object\" , lines ( l )% string ()) l = 2 metadata = [ string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"false\" )] if ( adjustl ( lines ( l )% string ()) == '\"metadata\": {' ) then block character ( len = :), allocatable :: justified_line do l = l + 1 justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == \"},\" ) exit metadata ( findloc ( key , trim ( get_key_string ( justified_line )), dim = 1 )) = get_key_value ( justified_line ) end do l = l + 1 end block end if call assert ( adjustl ( lines ( l )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( l )% string ()) l = l + 1 block integer , parameter :: lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l ) associate ( output_layer_line_number => l + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end block inference_engine = hidden_layers % inference_engine ( metadata , output_layer ) call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) contains pure function get_key_string ( line ) result ( unquoted_key ) character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: unquoted_key associate ( opening_key_quotes => index ( line , '\"' ), separator => index ( line , ':' )) associate ( closing_key_quotes => opening_key_quotes + index ( line ( opening_key_quotes + 1 :), '\"' )) unquoted_key = trim ( line ( opening_key_quotes + 1 : closing_key_quotes - 1 )) end associate end associate end function function get_key_value ( line ) result ( value_ ) character ( len =* ), intent ( in ) :: line type ( string_t ) value_ associate ( text_after_colon => line ( index ( line , ':' ) + 1 :)) associate ( opening_value_quotes => index ( text_after_colon , '\"' )) associate ( closing_value_quotes => opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' )) if ( any ([ opening_value_quotes , closing_value_quotes ] == 0 )) then value_ = string_t ( trim ( adjustl (( text_after_colon )))) else value_ = string_t ( text_after_colon ( opening_value_quotes + 1 : closing_value_quotes - 1 )) end if end associate end associate end associate end function end procedure construct_from_json module procedure assert_conformable_with call assert_consistency ( self ) call assert_consistency ( inference_engine ) associate ( equal_shapes => [ & shape ( self % weights_ ) == shape ( inference_engine % weights_ ), & shape ( self % biases_ ) == shape ( inference_engine % biases_ ), & shape ( self % nodes_ ) == shape ( inference_engine % nodes_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( same_type_as ( self % activation_strategy_ , inference_engine % activation_strategy_ ), \"assert_conformable_with: types)\" ) end procedure module procedure subtract call assert_consistency ( self ) call assert_consistency ( rhs ) call self % assert_conformable_with ( rhs ) block integer l allocate ( difference % weights_difference_ , mold = self % weights_ ) allocate ( difference % biases_difference_ , mold = self % biases_ ) allocate ( difference % nodes_difference_ , mold = self % nodes_ ) difference % weights_difference_ = 0. difference % biases_difference_ = 0. difference % nodes_difference_ = 0. l = 0 difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) associate ( n => self % nodes_ ) do concurrent ( l = 1 : ubound ( n , 1 )) difference % weights_difference_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = self % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - rhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) difference % biases_difference_ ( 1 : n ( l ), l ) = self % biases_ ( 1 : n ( l ), l ) - rhs % biases_ ( 1 : n ( l ), l ) difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) end do end associate end block call assert_consistency ( difference ) end procedure module procedure norm norm_of_self = maxval ([ abs ( self % weights_difference_ ), abs ( self % biases_difference_ ), real ( abs ( self % nodes_difference_ ))]) end procedure module procedure num_outputs call assert_consistency ( self ) output_count = self % nodes_ ( ubound ( self % nodes_ , 1 )) end procedure module procedure num_inputs call assert_consistency ( self ) input_count = self % nodes_ ( lbound ( self % nodes_ , 1 )) end procedure module procedure nodes_per_layer call assert_consistency ( self ) node_count = self % nodes_ end procedure module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , metadata_outer_braces = 2 call assert_consistency ( self ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => size ( self % nodes_ ) - 2 , & neurons_per_layer => self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 ), & num_outputs => self % num_outputs (), & num_inputs => self % num_inputs () & ) call assert ( all ( neurons_per_layer == self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 : ubound ( self % nodes_ , 1 ) - 1 )), & \"to_json: uniform hidden layers\" ) associate ( num_lines => & outer_object_braces & + metadata_outer_braces + size ( key ) & + hidden_layer_outer_brackets + ( num_hidden_layers ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '    \"metadata\": {' ) line = line + 1 lines ( line ) = string_t ( '        \"modelName\": \"' // & self % metadata_ ( findloc ( key , \"modelName\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"modelAuthor\": \"' // & self % metadata_ ( findloc ( key , \"modelAuthor\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"compilationDate\": \"' // & self % metadata_ ( findloc ( key , \"compilationDate\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"activationFunction\": \"' // & self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"usingSkipConnections\": ' // & self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string ()) line = line + 1 lines ( line ) = string_t ( '    },' ) line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) block integer l associate ( n => self % nodes_ ) l = 1 write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate end block lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ] \" , \"         ],\" , any ( num_hidden_layers == [ 1 , line ])))) do layer = 1 , num_hidden_layers - 1 line = line + 1 lines ( line ) = string_t ( '         [' ) block real ( rkind ), allocatable :: hidden_layer_weights (:,:) integer j , l associate ( n => self % nodes_ , l => layer + 1 ) allocate ( hidden_layer_weights ( n ( l ), n ( l - 1 ))) do concurrent ( j = 1 : n ( l )) hidden_layer_weights ( j , 1 : n ( l - 1 )) = self % weights_ ( j , 1 : n ( l - 1 ), l ) end do hidden_layer_weights = transpose ( hidden_layer_weights ) end associate do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) hidden_layer_weights (:, neuron ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do end block line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers - 1 ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) associate ( n => self % nodes_ , l => ubound ( self % nodes_ , 1 )) write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , ubound ( self % biases_ , 2 )) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == num_outputs ))) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure skip use_skip_connections = self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string () == \"true\" end procedure module procedure activation_function_name activation_name = self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 )) end procedure end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules step_m Source Code step_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules swish_m Source Code swish_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use string_m , only : string_t implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure , nopass :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name () result ( string ) implicit none type ( string_t ) string end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules differentiable_activation_strategy_m Source Code differentiable_activation_strategy_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules swish_s Source Code swish_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure module procedure function_name string = string_t ( \"swish\" ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"mini_batch_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules mini_batch_s Source Code mini_batch_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"input_output_pair_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules input_output_pair_m Source Code input_output_pair_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use kind_parameters_m , only : rkind use tensor_m , only : tensor_t implicit none private public :: input_output_pair_t type input_output_pair_t private type ( tensor_t ) inputs_ , expected_outputs_ contains procedure :: inputs procedure :: expected_outputs end type interface input_output_pair_t elemental module function construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ) input_output_pair end function end interface interface elemental module function inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_inputs end function elemental module function expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_expected_outputs end function end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~write-read-infer.f90->sourcefile~tensor_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kind_parameters_m Source Code kind_parameters_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"inference_engine_m_.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m_.f90~~EfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~inference_engine_m_.f90~~AfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90 inference_engine_s.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inference_engine_m_ Source Code inference_engine_m_.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m_ !! Define an abstraction that supports inference operationsn on a neural network use string_m , only : string_t use activation_strategy_m , only : activation_strategy_t use file_m , only : file_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: inference_engine_t public :: difference_t character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference private type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: infer procedure :: to_json procedure :: num_inputs procedure :: num_outputs procedure :: nodes_per_layer procedure :: assert_conformable_with procedure :: skip procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: activation_function_name end type type difference_t private real ( rkind ), allocatable :: weights_difference_ (:,:,:), biases_difference_ (:,:) integer , allocatable :: nodes_difference_ (:) contains procedure :: norm end type interface inference_engine_t pure module function construct_from_padded_arrays ( metadata , weights , biases , nodes ) result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( difference_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( difference_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function pure module function nodes_per_layer ( self ) result ( node_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer , allocatable :: node_count (:) end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function pure module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function end interface end module inference_engine_m_","tags":"","loc":"sourcefile/inference_engine_m_.f90.html"},{"title":"mini_batch_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mini_batch_m Source Code mini_batch_m.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : rkind implicit none private public :: mini_batch_t type mini_batch_t private type ( input_output_pair_t ), allocatable :: input_output_pairs_ (:) contains procedure :: input_output_pairs end type interface mini_batch_t pure module function construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function end interface interface pure module function input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"input_output_pair_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules input_output_pair_s Source Code input_output_pair_s.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s implicit none contains module procedure construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure inputs my_inputs = self % inputs_ end procedure module procedure expected_outputs my_expected_outputs = self % expected_outputs_ end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"read.f90 – Inference-Engine","text":"This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~read.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs read_json Source Code read.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_json !! This program demonstrates how to read a neural network from a JSON file. !! query the network for a some of its properties. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use file_m , only : file_t implicit none type ( string_t ) input_file_name type ( command_line_t ) command_line type ( inference_engine_t ) inference_engine type ( string_t ) activation_name input_file_name = string_t ( command_line % flag_value ( \"--input-file\" )) if ( len ( input_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example read -- --input-file \"<file-name>\"' end if print * , \"Constructing a new inference_engine_t object by parameters from '\" // input_file_name % string () // \"'.\" inference_engine = inference_engine_t ( file_t ( input_file_name )) print * , \"number of inputs: \" , inference_engine % num_inputs () print * , \"number of outputs: \" , inference_engine % num_outputs () print * , \"number of nodes per layer: \" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) end program","tags":"","loc":"sourcefile/read.f90.html"},{"title":"train-and-write.f90 – Inference-Engine","text":"This file depends on sourcefile~~train-and-write.f90~~EfferentGraph sourcefile~train-and-write.f90 train-and-write.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs train_and_write Source Code train-and-write.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_and_write !! This program demonstrates how to train a neural network and write it to a JSON file. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , rkind , sigmoid_t , mini_batch_t , tensor_t , input_output_pair_t use sourcery_m , only : string_t , file_t , command_line_t implicit none type ( string_t ) file_name type ( command_line_t ) command_line real ( rkind ), parameter :: false = 0._rkind , true = 1._rkind file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example train-and-write -- --output-file \"<file-name>\"' end if block type ( trainable_engine_t ) trainable_engine type ( inference_engine_t ) inference_engine type ( file_t ) json_file type ( mini_batch_t ), allocatable :: mini_batches (:) type ( tensor_t ), allocatable :: training_inputs (:,:), tmp (:), inputs (:) type ( tensor_t ), allocatable :: training_outputs (:,:), tmp2 (:), expected_outputs (:) real ( rkind ) t_start , t_end real ( rkind ), allocatable :: harvest (:,:,:) integer , parameter :: num_inputs = 2 , mini_batch_size = 1 , num_iterations = 8000000 integer batch , iter , i allocate ( harvest ( num_inputs , mini_batch_size , num_iterations )) call random_number ( harvest ) ! The following temporary copies are required by gfortran bug 100650 and possibly 49324 ! See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100650 and https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49324 tmp = [([( tensor_t ( merge ( true , false , harvest (:, batch , iter ) < 0.5E0 )), batch = 1 , mini_batch_size )], iter = 1 , num_iterations )] training_inputs = reshape ( tmp , [ mini_batch_size , num_iterations ]) tmp2 = [([( xor ( training_inputs ( batch , iter )), batch = 1 , mini_batch_size )], iter = 1 , num_iterations )] training_outputs = reshape ( tmp2 , [ mini_batch_size , num_iterations ]) mini_batches = [( mini_batch_t ( input_output_pair_t ( training_inputs (:, iter ), training_outputs (:, iter ))), iter = 1 , num_iterations )] trainable_engine = one_random_hidden_layer () call cpu_time ( t_start ) call trainable_engine % train ( mini_batches ) call cpu_time ( t_end ) print * , \"Training time: \" , t_end - t_start inputs = [ tensor_t ([ true , true ]), tensor_t ([ true , false ]), tensor_t ([ false , true ]), tensor_t ([ false , false ])] print * , \"sample inputs:    \" ,( \"[\" , inputs ( i )% values (), \"]\" , i = 1 , size ( inputs )) expected_outputs = xor ( inputs ) print * , \"expected outputs: \" ,( expected_outputs ( i )% values (), i = 1 , size ( expected_outputs )) associate ( outputs => trainable_engine % infer ( inputs )) print * , \"actual outputs:   \" ,( outputs ( i )% values (), i = 1 , size ( outputs )) end associate inference_engine = trainable_engine % to_inference_engine () json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end block contains elemental function xor ( inputs ) result ( expected_outputs ) type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) expected_outputs associate ( sum_inputs => sum ( inputs % values ())) expected_outputs = tensor_t ([ merge ( true , false , sum_inputs > 0.99 . and . sum_inputs < 1.01 )]) end associate end function function one_random_hidden_layer () result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine integer , parameter :: inputs = 2 , outputs = 1 , hidden = 2 ! number of neurons in input, output, and hidden layers integer , parameter :: n ( * ) = [ inputs , hidden , outputs ] ! neurons per layer integer , parameter :: n_max = maxval ( n ), layers = size ( n ) ! max layer width, number of layers real ( rkind ) w ( n_max , n_max , layers - 1 ), b ( n_max , n_max ) call random_number ( b ) call random_number ( w ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = sigmoid_t (), & metadata = [ string_t ( \"1 hide|2 wide\" ), string_t ( \"D. Rouson\" ), string_t ( \"2023-06-30\" ), string_t ( \"sigmoid\" ), string_t ( \"false\" )]& ) end function end program","tags":"","loc":"sourcefile/train-and-write.f90.html"},{"title":"write-read-infer.f90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~write-read-infer.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~write-read-infer.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~netcdf_file_m.f90 NetCDF_file_m.f90 sourcefile~inference_engine_m.f90->sourcefile~netcdf_file_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs write_read_infer Source Code write-read-infer.f90 Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference. use command_line_m , only : command_line_t use inference_engine_m , only : inference_engine_t use string_m , only : string_t use step_m , only : step_t use file_m , only : file_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: ./build/run-fpm.sh run --example write-read-infer -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains function single_hidden_layer_xor_network () result ( inference_engine ) type ( inference_engine_t ) inference_engine integer , parameter :: nodes_per_layer ( * ) = [ 2 , 3 , 1 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) inference_engine = inference_engine_t ( & metadata = [ string_t ( \"XOR\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-07-02\" ), string_t ( \"step\" ), string_t ( \"false\" )], & weights = reshape ([ real ( rkind ) :: [ 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 1 , 0 , 0 , - 2 , 0 , 0 , 1 , 0 , 0 ]], [ max_n , max_n , layers - 1 ]), & biases = reshape ([[ 0. , - 1.99 , 0. ], [ 0. , 0. , 0. ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) end function subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 integer , parameter :: identity ( * , * , * ) = & reshape ([(( merge ( 1 , 0 , i == j ), i = 1 , num_neurons ), j = 1 , num_neurons )], shape = [ num_neurons , num_neurons , num_hidden_layers - 1 ]) type ( inference_engine_t ) xor_network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) network_outputs real ( rkind ), parameter :: false = 0._rkind , true = 1._rkind print * , \"Constructing an inference_engine_t neural-network object from scratch.\" xor_network = single_hidden_layer_xor_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = xor_network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"number of outputs:\" , inference_engine % num_outputs () print * , \"nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"activation function: \" , activation_name % string () print * , \"using skip connections: \" , merge ( \"true \" , \"false\" , inference_engine % skip ()) print * , \"Performing inference:\" network_outputs = inference_engine % infer ( tensor_t ([ real ( rkind ) :: false , true ])) print * , \"inference_engine%infer([0.,1.]) =\" , network_outputs % values () print * , \"Correct answer for the XOR neural network: \" , 1. end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"}]}